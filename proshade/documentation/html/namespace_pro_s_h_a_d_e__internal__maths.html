<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ProSHADE: ProSHADE_internal_maths Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Logo_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ProSHADE
   &#160;<span id="projectnumber">0.7.5.1 (JAN 2021) - DEVELOPMENT</span>
   </div>
   <div id="projectbrief">Protein Shape Detection</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespace_pro_s_h_a_d_e__internal__maths.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ProSHADE_internal_maths Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This namespace contains the internal functions for common mathematical operations.  
<a href="namespace_pro_s_h_a_d_e__internal__maths.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pro_s_h_a_d_e__internal__maths_1_1_bicubic_interpolator.html">BicubicInterpolator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a254fece06e1cfce122a11ddea4f71970"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a254fece06e1cfce122a11ddea4f71970">complexMultiplication</a> (proshade_double *r1, proshade_double *i1, proshade_double *r2, proshade_double *i2, proshade_double *retReal, proshade_double *retImag)</td></tr>
<tr class="memdesc:a254fece06e1cfce122a11ddea4f71970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to multiply two complex numbers.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a254fece06e1cfce122a11ddea4f71970">More...</a><br /></td></tr>
<tr class="separator:a254fece06e1cfce122a11ddea4f71970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca5a3aedba75f52aaf707edc4e790f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ca5a3aedba75f52aaf707edc4e790f7">complexMultiplicationConjug</a> (proshade_double *r1, proshade_double *i1, proshade_double *r2, proshade_double *i2, proshade_double *retReal, proshade_double *retImag)</td></tr>
<tr class="memdesc:a2ca5a3aedba75f52aaf707edc4e790f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to multiply two complex numbers by using the second number's conjugate.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ca5a3aedba75f52aaf707edc4e790f7">More...</a><br /></td></tr>
<tr class="separator:a2ca5a3aedba75f52aaf707edc4e790f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b05344ffead449c29a333a57b404f6"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#ac9b05344ffead449c29a333a57b404f6">complexMultiplicationRealOnly</a> (proshade_double *r1, proshade_double *i1, proshade_double *r2, proshade_double *i2)</td></tr>
<tr class="memdesc:ac9b05344ffead449c29a333a57b404f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to multiply two complex numbers and return the real part only.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#ac9b05344ffead449c29a333a57b404f6">More...</a><br /></td></tr>
<tr class="separator:ac9b05344ffead449c29a333a57b404f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc59a55f5ed21de90e351005c58a871e"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#abc59a55f5ed21de90e351005c58a871e">complexMultiplicationConjugRealOnly</a> (proshade_double *r1, proshade_double *i1, proshade_double *r2, proshade_double *i2)</td></tr>
<tr class="memdesc:abc59a55f5ed21de90e351005c58a871e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to conjuggate multiply two complex numbers and return the real part only.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#abc59a55f5ed21de90e351005c58a871e">More...</a><br /></td></tr>
<tr class="separator:abc59a55f5ed21de90e351005c58a871e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7c6330e101fb6d729aaf6f545db9c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a8a7c6330e101fb6d729aaf6f545db9c8">vectorMeanAndSD</a> (std::vector&lt; proshade_double &gt; *vec, proshade_double *&amp;ret)</td></tr>
<tr class="memdesc:a8a7c6330e101fb6d729aaf6f545db9c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get vector mean and standard deviation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a8a7c6330e101fb6d729aaf6f545db9c8">More...</a><br /></td></tr>
<tr class="separator:a8a7c6330e101fb6d729aaf6f545db9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af185ca14eb5d82fb126092767746e00a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#af185ca14eb5d82fb126092767746e00a">vectorMedianAndIQR</a> (std::vector&lt; proshade_double &gt; *vec, proshade_double *&amp;ret)</td></tr>
<tr class="memdesc:af185ca14eb5d82fb126092767746e00a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get vector median and inter-quartile range.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#af185ca14eb5d82fb126092767746e00a">More...</a><br /></td></tr>
<tr class="separator:af185ca14eb5d82fb126092767746e00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a356017340781739a3bd66c716cfa5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#aa5a356017340781739a3bd66c716cfa5">arrayMedianAndIQR</a> (proshade_double *vec, proshade_unsign vecSize, proshade_double *&amp;ret)</td></tr>
<tr class="memdesc:aa5a356017340781739a3bd66c716cfa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get array median and inter-quartile range.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#aa5a356017340781739a3bd66c716cfa5">More...</a><br /></td></tr>
<tr class="separator:aa5a356017340781739a3bd66c716cfa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894d87e94446db04492b663e54a74bff"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a894d87e94446db04492b663e54a74bff">pearsonCorrCoeff</a> (proshade_double *valSet1, proshade_double *valSet2, proshade_unsign length)</td></tr>
<tr class="memdesc:a894d87e94446db04492b663e54a74bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for computing the Pearson's correlation coefficient.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a894d87e94446db04492b663e54a74bff">More...</a><br /></td></tr>
<tr class="separator:a894d87e94446db04492b663e54a74bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2f7de1bba288270ce2cc772d28d065"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a6e2f7de1bba288270ce2cc772d28d065">getLegendreAbscAndWeights</a> (proshade_unsign order, proshade_double *abscissas, proshade_double *weights, proshade_unsign taylorSeriesCap)</td></tr>
<tr class="memdesc:a6e2f7de1bba288270ce2cc772d28d065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to prepare abscissas and weights for Gauss-Legendre integration.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a6e2f7de1bba288270ce2cc772d28d065">More...</a><br /></td></tr>
<tr class="separator:a6e2f7de1bba288270ce2cc772d28d065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affab74b910cda2ee3faa461740a7a432"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#affab74b910cda2ee3faa461740a7a432">getGLPolyAtZero</a> (proshade_unsign order, proshade_double *polyValue, proshade_double *deriValue)</td></tr>
<tr class="memdesc:affab74b910cda2ee3faa461740a7a432"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function obtains the Legendre polynomial values and its derivative at zero for any positive integer order polynomial.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#affab74b910cda2ee3faa461740a7a432">More...</a><br /></td></tr>
<tr class="separator:affab74b910cda2ee3faa461740a7a432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1823adaca871244e42347ecb8ed834a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a1823adaca871244e42347ecb8ed834a2">getGLFirstEvenRoot</a> (proshade_double polyAtZero, proshade_unsign order, proshade_double *abscAtZero, proshade_double *weighAtZero, proshade_unsign taylorSeriesCap)</td></tr>
<tr class="memdesc:a1823adaca871244e42347ecb8ed834a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds the first root for Legendre polynomials of odd order.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a1823adaca871244e42347ecb8ed834a2">More...</a><br /></td></tr>
<tr class="separator:a1823adaca871244e42347ecb8ed834a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e69b64278319ae1a1268d1a55545675"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a7e69b64278319ae1a1268d1a55545675">evaluateGLSeries</a> (proshade_double *series, proshade_double target, proshade_unsign terms)</td></tr>
<tr class="memdesc:a7e69b64278319ae1a1268d1a55545675"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function evaluates the Taylor expansion.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a7e69b64278319ae1a1268d1a55545675">More...</a><br /></td></tr>
<tr class="separator:a7e69b64278319ae1a1268d1a55545675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2619c7f3b8d628af9cb356778e9807"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a4f2619c7f3b8d628af9cb356778e9807">advanceGLPolyValue</a> (proshade_double from, proshade_double to, proshade_double valAtFrom, proshade_unsign noSteps, proshade_unsign taylorSeriesCap)</td></tr>
<tr class="memdesc:a4f2619c7f3b8d628af9cb356778e9807"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds the next value of the polynomial.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a4f2619c7f3b8d628af9cb356778e9807">More...</a><br /></td></tr>
<tr class="separator:a4f2619c7f3b8d628af9cb356778e9807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c91064de64aef9f8278d533f8188ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a31c91064de64aef9f8278d533f8188ad">completeLegendreSeries</a> (proshade_unsign order, proshade_double *abscissa, proshade_double *weights, proshade_unsign taylorSeriesCap)</td></tr>
<tr class="memdesc:a31c91064de64aef9f8278d533f8188ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function completes the Legendre polynomial series assuming you have obtained the first values.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a31c91064de64aef9f8278d533f8188ad">More...</a><br /></td></tr>
<tr class="separator:a31c91064de64aef9f8278d533f8188ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62133f51851217e3cb28dff2f520d192"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a62133f51851217e3cb28dff2f520d192">gaussLegendreIntegrationReal</a> (proshade_double *vals, proshade_unsign valsSize, proshade_unsign order, proshade_double *abscissas, proshade_double *weights, proshade_double integralOverRange, proshade_double maxSphereDists)</td></tr>
<tr class="memdesc:a62133f51851217e3cb28dff2f520d192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute real part of the Gauss-Legendre integration over spherical harmonic values in different shells.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a62133f51851217e3cb28dff2f520d192">More...</a><br /></td></tr>
<tr class="separator:a62133f51851217e3cb28dff2f520d192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4604176a61820f5fcb95e372861c1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a3d4604176a61820f5fcb95e372861c1d">gaussLegendreIntegration</a> (proshade_complex *vals, proshade_unsign valsSize, proshade_unsign order, proshade_double *abscissas, proshade_double *weights, proshade_double integralOverRange, proshade_double maxSphereDists, proshade_double *retReal, proshade_double *retImag)</td></tr>
<tr class="memdesc:a3d4604176a61820f5fcb95e372861c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute the complete complex Gauss-Legendre integration over spherical harmonic values in different shells.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a3d4604176a61820f5fcb95e372861c1d">More...</a><br /></td></tr>
<tr class="separator:a3d4604176a61820f5fcb95e372861c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98abe6f7fac976a70b608951dbdf993"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#ab98abe6f7fac976a70b608951dbdf993">complexMatrixSVDSigmasOnly</a> (proshade_complex **mat, int dim, double *&amp;singularValues)</td></tr>
<tr class="memdesc:ab98abe6f7fac976a70b608951dbdf993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute the complete complex matrix SVD and return only the sigmas.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#ab98abe6f7fac976a70b608951dbdf993">More...</a><br /></td></tr>
<tr class="separator:ab98abe6f7fac976a70b608951dbdf993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc79bf2506934c9ebbda9c13a2722ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#acdc79bf2506934c9ebbda9c13a2722ad">complexMatrixSVDUandVOnly</a> (proshade_double *mat, int dim, proshade_double *uAndV, bool fail=true)</td></tr>
<tr class="memdesc:acdc79bf2506934c9ebbda9c13a2722ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute the real matrix SVD and return the U and V matrices.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#acdc79bf2506934c9ebbda9c13a2722ad">More...</a><br /></td></tr>
<tr class="separator:acdc79bf2506934c9ebbda9c13a2722ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6c5376edac98e54ef0e418cd05d706"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#acf6c5376edac98e54ef0e418cd05d706">getEulerZXZFromSOFTPosition</a> (proshade_signed band, proshade_signed x, proshade_signed y, proshade_signed z, proshade_double *eulerAlpha, proshade_double *eulerBeta, proshade_double *eulerGamma)</td></tr>
<tr class="memdesc:acf6c5376edac98e54ef0e418cd05d706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to find Euler angles (ZXZ convention) from index position in the inverse SOFT map.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#acf6c5376edac98e54ef0e418cd05d706">More...</a><br /></td></tr>
<tr class="separator:acf6c5376edac98e54ef0e418cd05d706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea245a9b2b305f970be1ed62b141cce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#adea245a9b2b305f970be1ed62b141cce">getSOFTPositionFromEulerZXZ</a> (proshade_signed band, proshade_double eulerAlpha, proshade_double eulerBeta, proshade_double eulerGamma, proshade_double *x, proshade_double *y, proshade_double *z)</td></tr>
<tr class="memdesc:adea245a9b2b305f970be1ed62b141cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to find the index position in the inverse SOFT map from given Euler angles (ZXZ convention).  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#adea245a9b2b305f970be1ed62b141cce">More...</a><br /></td></tr>
<tr class="separator:adea245a9b2b305f970be1ed62b141cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9fe573a48f499dd7d1df4f779222f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#abd9fe573a48f499dd7d1df4f779222f1">getRotationMatrixFromEulerZXZAngles</a> (proshade_double eulerAlpha, proshade_double eulerBeta, proshade_double eulerGamma, proshade_double *matrix)</td></tr>
<tr class="memdesc:abd9fe573a48f499dd7d1df4f779222f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to find the rotation matrix from Euler angles (ZXZ convention).  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#abd9fe573a48f499dd7d1df4f779222f1">More...</a><br /></td></tr>
<tr class="separator:abd9fe573a48f499dd7d1df4f779222f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc6f1626c7463de53c9f4f6fa11db22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#aafc6f1626c7463de53c9f4f6fa11db22">getAxisAngleFromRotationMatrix</a> (proshade_double *rotMat, proshade_double *x, proshade_double *y, proshade_double *z, proshade_double *ang)</td></tr>
<tr class="memdesc:aafc6f1626c7463de53c9f4f6fa11db22"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts rotation matrix to the axis-angle representation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#aafc6f1626c7463de53c9f4f6fa11db22">More...</a><br /></td></tr>
<tr class="separator:aafc6f1626c7463de53c9f4f6fa11db22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a379ad8635541b0c7f7f6349822b2a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a4a379ad8635541b0c7f7f6349822b2a4">getAxisAngleFromRotationMatrix</a> (std::vector&lt; proshade_double &gt; *rotMat, proshade_double *x, proshade_double *y, proshade_double *z, proshade_double *ang)</td></tr>
<tr class="memdesc:a4a379ad8635541b0c7f7f6349822b2a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts rotation matrix to the axis-angle representation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a4a379ad8635541b0c7f7f6349822b2a4">More...</a><br /></td></tr>
<tr class="separator:a4a379ad8635541b0c7f7f6349822b2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39eafef902a49cc0816a2ed675c14a49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a39eafef902a49cc0816a2ed675c14a49">getRotationMatrixFromAngleAxis</a> (proshade_double *rotMat, proshade_double x, proshade_double y, proshade_double z, proshade_double ang)</td></tr>
<tr class="memdesc:a39eafef902a49cc0816a2ed675c14a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts the axis-angle representation to the rotation matrix representation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a39eafef902a49cc0816a2ed675c14a49">More...</a><br /></td></tr>
<tr class="separator:a39eafef902a49cc0816a2ed675c14a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f6afcef5b90ca77d7d6a9e91824e28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#ae6f6afcef5b90ca77d7d6a9e91824e28">getEulerZXZFromRotMatrix</a> (proshade_double *rotMat, proshade_double *eA, proshade_double *eB, proshade_double *eG)</td></tr>
<tr class="memdesc:ae6f6afcef5b90ca77d7d6a9e91824e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts rotation matrix to the Euler ZXZ angles representation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#ae6f6afcef5b90ca77d7d6a9e91824e28">More...</a><br /></td></tr>
<tr class="separator:ae6f6afcef5b90ca77d7d6a9e91824e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5750d6f0bf8e4a4b1d26552e8719dfd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a5750d6f0bf8e4a4b1d26552e8719dfd4">getEulerZXZFromAngleAxis</a> (proshade_double axX, proshade_double axY, proshade_double axZ, proshade_double axAng, proshade_double *eA, proshade_double *eB, proshade_double *eG, proshade_unsign angDim)</td></tr>
<tr class="memdesc:a5750d6f0bf8e4a4b1d26552e8719dfd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts angle-axis representation to the Euler ZXZ angles representation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a5750d6f0bf8e4a4b1d26552e8719dfd4">More...</a><br /></td></tr>
<tr class="separator:a5750d6f0bf8e4a4b1d26552e8719dfd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ade24485a9272a2d08dd6efb7a54d83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a0ade24485a9272a2d08dd6efb7a54d83">getEulerZXZFromAngleAxisFullSearch</a> (proshade_double axX, proshade_double axY, proshade_double axZ, proshade_double axAng, proshade_double *eA, proshade_double *eB, proshade_double *eG, proshade_signed angDim)</td></tr>
<tr class="memdesc:a0ade24485a9272a2d08dd6efb7a54d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts angle-axis representation to the Euler ZXZ angles representation using full search.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a0ade24485a9272a2d08dd6efb7a54d83">More...</a><br /></td></tr>
<tr class="separator:a0ade24485a9272a2d08dd6efb7a54d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac211e762a46e4c7e25235a651acfdc77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#ac211e762a46e4c7e25235a651acfdc77">multiplyTwoSquareMatrices</a> (proshade_double *A, proshade_double *B, proshade_double *res, proshade_unsign dim)</td></tr>
<tr class="memdesc:ac211e762a46e4c7e25235a651acfdc77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute matrix multiplication.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#ac211e762a46e4c7e25235a651acfdc77">More...</a><br /></td></tr>
<tr class="separator:ac211e762a46e4c7e25235a651acfdc77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6359dd366cdd986f5ad155bff8235a8e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; proshade_signed &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a6359dd366cdd986f5ad155bff8235a8e">primeFactorsDecomp</a> (proshade_signed number)</td></tr>
<tr class="memdesc:a6359dd366cdd986f5ad155bff8235a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to find prime factors of an integer.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a6359dd366cdd986f5ad155bff8235a8e">More...</a><br /></td></tr>
<tr class="separator:a6359dd366cdd986f5ad155bff8235a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01087ea3e0db56758d1771618e2e4a45"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a01087ea3e0db56758d1771618e2e4a45">normalDistributionValue</a> (proshade_double mean, proshade_double standardDev, proshade_double value)</td></tr>
<tr class="memdesc:a01087ea3e0db56758d1771618e2e4a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to the heiht of normal distribution given by mean and standard deviation for a given value.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a01087ea3e0db56758d1771618e2e4a45">More...</a><br /></td></tr>
<tr class="separator:a01087ea3e0db56758d1771618e2e4a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac3b534f974de25b092e9d48d9f7dea"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">computeDotProduct</a> (proshade_double *x1, proshade_double *y1, proshade_double *z1, proshade_double *x2, proshade_double *y2, proshade_double *z2)</td></tr>
<tr class="memdesc:a2ac3b534f974de25b092e9d48d9f7dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple 3D vector dot product computation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">More...</a><br /></td></tr>
<tr class="separator:a2ac3b534f974de25b092e9d48d9f7dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b37ae1c35d048fd5dbff0a2cfcc4601"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a3b37ae1c35d048fd5dbff0a2cfcc4601">computeDotProduct</a> (proshade_double x1, proshade_double y1, proshade_double z1, proshade_double x2, proshade_double y2, proshade_double z2)</td></tr>
<tr class="memdesc:a3b37ae1c35d048fd5dbff0a2cfcc4601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple 3D vector dot product computation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a3b37ae1c35d048fd5dbff0a2cfcc4601">More...</a><br /></td></tr>
<tr class="separator:a3b37ae1c35d048fd5dbff0a2cfcc4601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45fbcfaeaabf9bae2fbd7d46a5fb4bc7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; proshade_double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a45fbcfaeaabf9bae2fbd7d46a5fb4bc7">findVectorFromTwoVAndTwoD</a> (proshade_double x1, proshade_double y1, proshade_double z1, proshade_double x2, proshade_double y2, proshade_double z2, proshade_double dot1, proshade_double dot2)</td></tr>
<tr class="memdesc:a45fbcfaeaabf9bae2fbd7d46a5fb4bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for finding a vector which would have a given two dot products to two other vectors.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a45fbcfaeaabf9bae2fbd7d46a5fb4bc7">More...</a><br /></td></tr>
<tr class="separator:a45fbcfaeaabf9bae2fbd7d46a5fb4bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f376bb341b192fff008b9b4ef5c603"><td class="memItemLeft" align="right" valign="top">std::vector&lt; proshade_double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#ae9f376bb341b192fff008b9b4ef5c603">findVectorFromThreeVAndThreeD</a> (proshade_double x1, proshade_double y1, proshade_double z1, proshade_double x2, proshade_double y2, proshade_double z2, proshade_double x3, proshade_double y3, proshade_double z3, proshade_double dot1, proshade_double dot2, proshade_double dot3)</td></tr>
<tr class="memdesc:ae9f376bb341b192fff008b9b4ef5c603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for finding a vector which would have a given three dot products to three other vectors.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#ae9f376bb341b192fff008b9b4ef5c603">More...</a><br /></td></tr>
<tr class="separator:ae9f376bb341b192fff008b9b4ef5c603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18222a942e5fff8eecd15f1235c609e1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; proshade_double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a18222a942e5fff8eecd15f1235c609e1">multiplyGroupElementMatrices</a> (std::vector&lt; proshade_double &gt; *el1, std::vector&lt; proshade_double &gt; *el2)</td></tr>
<tr class="memdesc:a18222a942e5fff8eecd15f1235c609e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes matrix multiplication using the ProSHADE group element matrix format as input and output.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a18222a942e5fff8eecd15f1235c609e1">More...</a><br /></td></tr>
<tr class="separator:a18222a942e5fff8eecd15f1235c609e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4348a7a36275c9cea20b5c27093c9b7e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a4348a7a36275c9cea20b5c27093c9b7e">rotationMatrixSimilarity</a> (std::vector&lt; proshade_double &gt; *mat1, std::vector&lt; proshade_double &gt; *mat2, proshade_double tolerance=0.1)</td></tr>
<tr class="memdesc:a4348a7a36275c9cea20b5c27093c9b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compares the distance between two rotation matrices and decides if they are similar using tolerance.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a4348a7a36275c9cea20b5c27093c9b7e">More...</a><br /></td></tr>
<tr class="separator:a4348a7a36275c9cea20b5c27093c9b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2f67cba1eea57f19fdaf062db74fde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2b2f67cba1eea57f19fdaf062db74fde">vectorOrientationSimilarity</a> (proshade_double a1, proshade_double a2, proshade_double a3, proshade_double b1, proshade_double b2, proshade_double b3, proshade_double tolerance=0.1)</td></tr>
<tr class="memdesc:a2b2f67cba1eea57f19fdaf062db74fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compares two vectors using cosine distance and decides if they are similar using tolerance.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2b2f67cba1eea57f19fdaf062db74fde">More...</a><br /></td></tr>
<tr class="separator:a2b2f67cba1eea57f19fdaf062db74fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e789452e327bb07a53c5358f4d3eb0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a79e789452e327bb07a53c5358f4d3eb0">vectorOrientationSimilaritySameDirection</a> (proshade_double a1, proshade_double a2, proshade_double a3, proshade_double b1, proshade_double b2, proshade_double b3, proshade_double tolerance=0.1)</td></tr>
<tr class="memdesc:a79e789452e327bb07a53c5358f4d3eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compares two vectors using cosine distance and decides if they are similar using tolerance.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a79e789452e327bb07a53c5358f4d3eb0">More...</a><br /></td></tr>
<tr class="separator:a79e789452e327bb07a53c5358f4d3eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51486f6276c28c1b503f19c36007b9e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a51486f6276c28c1b503f19c36007b9e2">optimiseAxisBiCubicInterpolation</a> (proshade_double *bestLattitude, proshade_double *bestLongitude, proshade_double *bestSum, std::vector&lt; proshade_unsign &gt; *sphereList, std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere.html">ProSHADE_internal_spheres::ProSHADE_rotFun_sphere</a> * &gt; *sphereMappedRotFun, proshade_double step=0.05)</td></tr>
<tr class="memdesc:a51486f6276c28c1b503f19c36007b9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides axis optimisation given starting lattitude and longitude indices.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a51486f6276c28c1b503f19c36007b9e2">More...</a><br /></td></tr>
<tr class="separator:a51486f6276c28c1b503f19c36007b9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac027bbd2cde68eb9d677e8b11b90cc2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#ac027bbd2cde68eb9d677e8b11b90cc2e">prepareBiCubicInterpolatorsMinusMinus</a> (proshade_double bestLattitude, proshade_double bestLongitude, std::vector&lt; proshade_unsign &gt; *sphereList, std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__maths_1_1_bicubic_interpolator.html">ProSHADE_internal_maths::BicubicInterpolator</a> * &gt; *interpols, std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere.html">ProSHADE_internal_spheres::ProSHADE_rotFun_sphere</a> * &gt; *sphereMappedRotFun)</td></tr>
<tr class="memdesc:ac027bbd2cde68eb9d677e8b11b90cc2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prepares the interpolation objects for the bi-cubic interpolation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#ac027bbd2cde68eb9d677e8b11b90cc2e">More...</a><br /></td></tr>
<tr class="separator:ac027bbd2cde68eb9d677e8b11b90cc2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c2321ffcef5079634493d9bf65749b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a73c2321ffcef5079634493d9bf65749b">prepareBiCubicInterpolatorsMinusPlus</a> (proshade_double bestLattitude, proshade_double bestLongitude, std::vector&lt; proshade_unsign &gt; *sphereList, std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__maths_1_1_bicubic_interpolator.html">ProSHADE_internal_maths::BicubicInterpolator</a> * &gt; *interpols, std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere.html">ProSHADE_internal_spheres::ProSHADE_rotFun_sphere</a> * &gt; *sphereMappedRotFun)</td></tr>
<tr class="memdesc:a73c2321ffcef5079634493d9bf65749b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prepares the interpolation objects for the bi-cubic interpolation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a73c2321ffcef5079634493d9bf65749b">More...</a><br /></td></tr>
<tr class="separator:a73c2321ffcef5079634493d9bf65749b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f12eb80331377a36ee6b3a4f8e65147"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a3f12eb80331377a36ee6b3a4f8e65147">prepareBiCubicInterpolatorsPlusMinus</a> (proshade_double bestLattitude, proshade_double bestLongitude, std::vector&lt; proshade_unsign &gt; *sphereList, std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__maths_1_1_bicubic_interpolator.html">ProSHADE_internal_maths::BicubicInterpolator</a> * &gt; *interpols, std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere.html">ProSHADE_internal_spheres::ProSHADE_rotFun_sphere</a> * &gt; *sphereMappedRotFun)</td></tr>
<tr class="memdesc:a3f12eb80331377a36ee6b3a4f8e65147"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prepares the interpolation objects for the bi-cubic interpolation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a3f12eb80331377a36ee6b3a4f8e65147">More...</a><br /></td></tr>
<tr class="separator:a3f12eb80331377a36ee6b3a4f8e65147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b355465dd2244b51e579dcb8669b3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#ac3b355465dd2244b51e579dcb8669b3a">prepareBiCubicInterpolatorsPlusPlus</a> (proshade_double bestLattitude, proshade_double bestLongitude, std::vector&lt; proshade_unsign &gt; *sphereList, std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__maths_1_1_bicubic_interpolator.html">ProSHADE_internal_maths::BicubicInterpolator</a> * &gt; *interpols, std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere.html">ProSHADE_internal_spheres::ProSHADE_rotFun_sphere</a> * &gt; *sphereMappedRotFun)</td></tr>
<tr class="memdesc:ac3b355465dd2244b51e579dcb8669b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prepares the interpolation objects for the bi-cubic interpolation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#ac3b355465dd2244b51e579dcb8669b3a">More...</a><br /></td></tr>
<tr class="separator:ac3b355465dd2244b51e579dcb8669b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2380a3710f7dbe672519c3adda30f7cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2380a3710f7dbe672519c3adda30f7cd">isAxisUnique</a> (std::vector&lt; proshade_double * &gt; *CSymList, proshade_double *axis, proshade_double tolerance=0.1, bool improve=false)</td></tr>
<tr class="memdesc:a2380a3710f7dbe672519c3adda30f7cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if new axis is unique, or already detected.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2380a3710f7dbe672519c3adda30f7cd">More...</a><br /></td></tr>
<tr class="separator:a2380a3710f7dbe672519c3adda30f7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f093fbdd34498d27a4d8998b620c91"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a49f093fbdd34498d27a4d8998b620c91">isAxisUnique</a> (std::vector&lt; proshade_double * &gt; *CSymList, proshade_double X, proshade_double Y, proshade_double Z, proshade_double fold, proshade_double tolerance)</td></tr>
<tr class="memdesc:a49f093fbdd34498d27a4d8998b620c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if new axis is unique, or already detected.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a49f093fbdd34498d27a4d8998b620c91">More...</a><br /></td></tr>
<tr class="separator:a49f093fbdd34498d27a4d8998b620c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2454c19169bb38d616e52b99f1dc4495"><td class="memItemLeft" align="right" valign="top">std::vector&lt; proshade_unsign &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2454c19169bb38d616e52b99f1dc4495">findAllPrimes</a> (proshade_unsign upTo)</td></tr>
<tr class="memdesc:a2454c19169bb38d616e52b99f1dc4495"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds all prime numbers up to the supplied limit.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2454c19169bb38d616e52b99f1dc4495">More...</a><br /></td></tr>
<tr class="separator:a2454c19169bb38d616e52b99f1dc4495"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace contains the internal functions for common mathematical operations. </p>
<p>The <a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html" title="This namespace contains the internal functions for common mathematical operations.">ProSHADE_internal_maths</a> namespace contains a set of common mathematical operations used in many places by ProSHADE. These typically include complex number operations and angle conversions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a4f2619c7f3b8d628af9cb356778e9807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2619c7f3b8d628af9cb356778e9807">&#9670;&nbsp;</a></span>advanceGLPolyValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">proshade_double ProSHADE_internal_maths::advanceGLPolyValue </td>
          <td>(</td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>valAtFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>noSteps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>taylorSeriesCap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function finds the next value of the polynomial. </p>
<p>Given the previous value of the polynomial, the distance to proceed and the number of steps to take, this function finds the next value of the polynomial using the Taylor series.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>Current polynomial position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>Polynomial position to move to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valAtFrom</td><td>The current value of the polynomial at the &lt;from&gt; position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noSteps</td><td>Number of steps in which to reach the &lt;to&gt; position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">taylorSeriesCap</td><td>The limit on the Taylor series. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>The polynomial value at the &lt;to&gt; position. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00477">477</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;{</div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;    proshade_double hlpVal                            = 0.0;</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;    proshade_double stepSize                          = 0.0;</div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;    proshade_double valChange                         = 0.0;</div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;    proshade_double valSecChange                      = 0.0;</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;    proshade_double squareSteps                       = 0.0;</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;    proshade_double curVal                            = 0.0;</div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;    </div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;    <span class="comment">//================================================ Set initial values</span></div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;    stepSize                                          = ( to - from ) / <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( taylorSeriesCap );</div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;    squareSteps                                       = sqrt ( <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( noSteps * ( noSteps + 1 ) ) );</div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;    curVal                                            = from;</div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;    </div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;    <span class="comment">//================================================ Go through the series and iteratively improve the estimate</span></div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; taylorSeriesCap; iter++ )</div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;    {</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;        hlpVal                                        = ( 1.0 - valAtFrom ) * ( 1.0 + valAtFrom );</div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;        valChange                                     = - stepSize * hlpVal / ( squareSteps * sqrt ( hlpVal ) - 0.5 * valAtFrom * sin ( 2.0 * curVal ) );</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;        valAtFrom                                     = valAtFrom + valChange;</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;                </div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;        curVal                                        = curVal + stepSize;</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;                </div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;        hlpVal                                        = ( 1.0 - valAtFrom ) * ( 1.0 + valAtFrom );</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;        valSecChange                                  = - stepSize * hlpVal / ( squareSteps * sqrt ( hlpVal ) - 0.5 * valAtFrom * sin ( 2.0 * curVal ) );</div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;        valAtFrom                                     = valAtFrom + 0.5 * ( valSecChange - valChange );</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;    }</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;    </div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;    <span class="keywordflow">return</span> valAtFrom;</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;    </div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa5a356017340781739a3bd66c716cfa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a356017340781739a3bd66c716cfa5">&#9670;&nbsp;</a></span>arrayMedianAndIQR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::arrayMedianAndIQR </td>
          <td>(</td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>vecSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get array median and inter-quartile range. </p>
<p>This function takes a pointer to a array of proshade_double's and returns the median and the inter-quartile range of such vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>Pointer to an array of proshade_double's for which median and IQR should be obtained. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vecSize</td><td>The length of the array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>Pointer to array of 2 proshade_double's, which will be the return values - first median and second IQR. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00198">198</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;{</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    <span class="comment">//================================================ Sort the vector</span></div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;    std::sort                                         ( vec, vec + vecSize );</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    </div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;    <span class="comment">//================================================ Get median</span></div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    <span class="keywordflow">if</span> ( vecSize % 2 == 0)</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    {</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;        ret[0]                                        = ( vec[ ( vecSize / 2 ) - 1 ] + vec[ vecSize / 2 ] ) / 2.0;</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    }</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    {</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;        ret[0]                                        = vec[ vecSize / 2 ];</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    }</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    </div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    <span class="comment">//================================================ Get first and third quartile</span></div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    proshade_double Q1, Q3;</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;    <span class="keywordflow">if</span> ( vecSize % 2 == 0)</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;    {</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;        Q1                                            = ( vec[ ( vecSize / 4 ) - 1 ] + vec[ vecSize / 4 ] ) / 2.0;</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;        Q3                                            = ( vec[ ( ( vecSize / 4 ) * 3 ) - 1 ] + vec[ ( vecSize / 4 ) * 3 ] ) / 2.0;</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    }</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    {</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;        Q1                                            = vec[ vecSize / 4 ];</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;        Q3                                            = vec[ ( vecSize / 4 ) * 3 ];</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    }</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;    </div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;    <span class="comment">//================================================ And now save the IQR</span></div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    ret[1]                                            = Q3 -  Q1;</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;    </div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    <span class="comment">//================================================ Return</span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    return ;</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    </div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a31c91064de64aef9f8278d533f8188ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c91064de64aef9f8278d533f8188ad">&#9670;&nbsp;</a></span>completeLegendreSeries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::completeLegendreSeries </td>
          <td>(</td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>abscissas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>taylorSeriesCap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function completes the Legendre polynomial series assuming you have obtained the first values. </p>
<p>Given that the polynomial value at zero is known, this function will complete the Legendre polynomial and with it the absicassas and weights for the Gauss-Legendre integration using the other functions defined above.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>The positive integer value of the polynomial order. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">abscissas</td><td>Pointer to an array of abscissas containing the first value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>Pointer to an array of weights containing the first value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">taylorSeriesCap</td><td>The limit on the Taylor series. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00521">521</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;{</div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;    <span class="comment">//================================================ Initialise internal variables</span></div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;    proshade_double hlpTaylorVal                      = 0.0;</div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;    proshade_double hlpOrderVal                       = <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( order );</div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;    proshade_double abscValueChange                   = 0.0;</div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;    proshade_double prevAbsc                          = 0.0;</div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;    proshade_double *hlpAbscSeries;</div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;    proshade_double *hlpWeightSeries;</div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;    proshade_unsign noSeriesElems                     = 0;</div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;    proshade_unsign oddEvenSwitch                     = 0;</div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;    </div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;    <span class="comment">//================================================ Pre-set internal values</span></div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;    <span class="keywordflow">if</span> ( order % 2 == 1 )</div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;    {</div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;        noSeriesElems                                 = ( order - 1 ) / 2 - 1;</div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;        oddEvenSwitch                                 = 1;</div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;    }</div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;    {</div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;        noSeriesElems                                 = order / 2 - 1;</div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;        oddEvenSwitch                                 = 0;</div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;    }</div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;    </div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;    <span class="comment">//================================================ Allocate memory</span></div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;    hlpAbscSeries                                     = <span class="keyword">new</span> proshade_double[taylorSeriesCap+2];</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;    hlpWeightSeries                                   = <span class="keyword">new</span> proshade_double[taylorSeriesCap+1];</div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;    </div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;    <span class="comment">//================================================ For each series element</span></div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign serIt = noSeriesElems + 1; serIt &lt; order - 1; serIt++ )</div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;    {</div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;        <span class="comment">//============================================ Init loop</span></div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;        prevAbsc                                      = abscissas[serIt];</div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;        abscValueChange                               = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a4f2619c7f3b8d628af9cb356778e9807">advanceGLPolyValue</a> ( M_PI/2.0, -M_PI/2.0, prevAbsc, order, taylorSeriesCap ) - prevAbsc;</div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;        </div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;        <span class="comment">//============================================ Init abscissas</span></div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;        hlpAbscSeries[0]                              = 0.0;</div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;        hlpAbscSeries[1]                              = 0.0;</div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;        hlpAbscSeries[2]                              = weights[serIt];</div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;        </div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;        <span class="comment">//============================================ Init weights</span></div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;        hlpWeightSeries[0]                            = 0.0;</div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;        hlpWeightSeries[1]                            = hlpAbscSeries[2];</div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;        </div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;        <span class="comment">//============================================ Taylor expansion</span></div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign tayIt = 0; tayIt &lt;= taylorSeriesCap - 2; tayIt++ )</div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;        {</div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;            hlpTaylorVal                              = <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( tayIt );</div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;                    </div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;            hlpAbscSeries[tayIt+3]                    = ( 2.0 * prevAbsc * ( hlpTaylorVal + 1.0 ) * hlpAbscSeries[tayIt+2] + ( hlpTaylorVal * ( hlpTaylorVal + 1.0 ) - hlpOrderVal *</div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;                                                        ( hlpOrderVal + 1.0 ) ) * hlpAbscSeries[tayIt+1] / ( hlpTaylorVal + 1.0 ) ) / ( 1.0 - prevAbsc ) / ( 1.0 + prevAbsc ) /</div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;                                                        ( hlpTaylorVal + 2.0 );</div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;            </div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;            hlpWeightSeries[tayIt+2]                  = ( hlpTaylorVal + 2.0 ) * hlpAbscSeries[tayIt+3];</div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;        }</div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;        </div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;        <span class="comment">//============================================ Sum over results</span></div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; 5; iter++ )</div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;        {</div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;            abscValueChange                           = abscValueChange - <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a7e69b64278319ae1a1268d1a55545675">evaluateGLSeries</a> ( hlpAbscSeries,   abscValueChange, taylorSeriesCap   ) /</div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;                                                                          <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a7e69b64278319ae1a1268d1a55545675">evaluateGLSeries</a> ( hlpWeightSeries, abscValueChange, taylorSeriesCap-1 );</div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;        }</div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;        </div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;        <span class="comment">//============================================ Save results</span></div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;        abscissas[serIt+1]                            = prevAbsc + abscValueChange;</div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;        weights[serIt+1]                              = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a7e69b64278319ae1a1268d1a55545675">evaluateGLSeries</a> ( hlpWeightSeries, abscValueChange, taylorSeriesCap - 1 );</div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;    }</div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;    </div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign serIt = 0; serIt &lt;= noSeriesElems + oddEvenSwitch; serIt++ )</div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;    {</div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;        abscissas[serIt]                              = -abscissas[order-serIt-1];</div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;        weights[serIt]                                = weights[order-serIt-1];</div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;    }</div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;    </div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;    <span class="comment">//================================================ Free memory</span></div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;    <span class="keyword">delete</span> hlpAbscSeries;</div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;    <span class="keyword">delete</span> hlpWeightSeries;</div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;    </div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;    return ;</div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;    </div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab98abe6f7fac976a70b608951dbdf993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab98abe6f7fac976a70b608951dbdf993">&#9670;&nbsp;</a></span>complexMatrixSVDSigmasOnly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::complexMatrixSVDSigmasOnly </td>
          <td>(</td>
          <td class="paramtype">proshade_complex **&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>singularValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute the complete complex matrix SVD and return only the sigmas. </p>
<p>This function converts the input proshade_complex matrix of dimensions dim onto the LAPACK compatible std::complex&lt;double&gt; matrix. It then proceeds to create a dummy variables for the U and V matrices for saving the SVD results as well as other required variables. It finally proceeds to call LAPACK ZGESDD function to compute the SVD of the complex matrix input, checks the results and terminates. Note that this function does not make use of most of the LAPACK capabilities and is limitted onto square matrices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>Pointer to a complex square matrix with dimensions dim * dim. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>The dimension of the complex matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">singularValues</td><td>Empty array of size dim where the singular values will be saved. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00802">802</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;{</div>
<div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;    <span class="comment">//================================================ Initialise local variables</span></div>
<div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;    <span class="keywordtype">char</span> job                                          = <span class="charliteral">&#39;N&#39;</span>;                                   <span class="comment">// Save computation of parts of U and V matrices, they are not needed here</span></div>
<div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;    std::complex&lt;double&gt; *rotMatU                     = <span class="keyword">new</span> std::complex&lt;double&gt; [dim*dim];    <span class="comment">// The U matrix space</span></div>
<div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;    std::complex&lt;double&gt; *rotMatV                     = <span class="keyword">new</span> std::complex&lt;double&gt; [dim*dim];    <span class="comment">// The V^T matrix space</span></div>
<div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;    std::complex&lt;double&gt; *work                        = <span class="keyword">new</span> std::complex&lt;double&gt; [( 4 * dim)]; <span class="comment">// Workspace, minimum required is 3*dim, using more for performance</span></div>
<div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;    <span class="keywordtype">int</span> workDim                                       = ( 4 * dim);                            <span class="comment">// Formalism stating just that</span></div>
<div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;    <span class="keywordtype">double</span>* rwork                                     = <span class="keyword">new</span> <span class="keywordtype">double</span>[(7 * dim)];                 <span class="comment">// Required by LAPACK, from 3.7 requires 7 * dim</span></div>
<div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;    <span class="keywordtype">int</span>* iwork                                        = <span class="keyword">new</span> <span class="keywordtype">int</span>[(8 * dim)];                    <span class="comment">// Required by LAPACK</span></div>
<div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;    <span class="keywordtype">int</span> returnValue                                   = 0;                                     <span class="comment">// This will tell if operation succeeded</span></div>
<div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;    </div>
<div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;    <span class="comment">//================================================ Check memory allocation</span></div>
<div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( rotMatU, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( rotMatV, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( work,    __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( rwork,   __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( iwork,   __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;    </div>
<div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;    <span class="comment">//================================================ Load input data into array in column-major order</span></div>
<div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;    std::complex&lt;double&gt; *matrixToDecompose           = <span class="keyword">new</span> std::complex&lt;double&gt;[dim*dim];</div>
<div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( matrixToDecompose, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;    <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> rowIt = 0; rowIt &lt; dim; rowIt++ )</div>
<div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;    {</div>
<div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;        <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> colIt = 0; colIt &lt; dim; colIt++ )</div>
<div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;        {</div>
<div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;            matrixToDecompose[(colIt*dim)+rowIt]      = std::complex&lt;double&gt; ( mat[rowIt][colIt][0], mat[rowIt][colIt][1] );</div>
<div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;        }</div>
<div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;    }</div>
<div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;    </div>
<div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;    <span class="comment">//================================================ Run LAPACK ZGESDD</span></div>
<div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;    zgesdd_                                           ( &amp;job, &amp;dim, &amp;dim, matrixToDecompose, &amp;dim, singularValues, rotMatU, &amp;dim, rotMatV, &amp;dim,</div>
<div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;                                                        work, &amp;workDim, rwork, iwork, &amp;returnValue );</div>
<div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;    </div>
<div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;    <span class="comment">//================================================ Free memory</span></div>
<div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;    <span class="keyword">delete</span>[] rotMatU;</div>
<div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;    <span class="keyword">delete</span>[] rotMatV;</div>
<div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;    <span class="keyword">delete</span>[] work;</div>
<div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;    <span class="keyword">delete</span>[] rwork;</div>
<div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;    <span class="keyword">delete</span>[] iwork;</div>
<div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;    <span class="keyword">delete</span>[] matrixToDecompose;</div>
<div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;    </div>
<div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;    <span class="comment">//================================================ Check result</span></div>
<div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;    <span class="keywordflow">if</span> ( returnValue != 0 )</div>
<div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;    {</div>
<div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;        <span class="keywordflow">throw</span> <a class="code" href="class_pro_s_h_a_d_e__exception.html">ProSHADE_exception</a> ( <span class="stringliteral">&quot;The LAPACK complex SVD algorithm did not converge!&quot;</span>, <span class="stringliteral">&quot;EL00021&quot;</span>, __FILE__, __LINE__, __func__, <span class="stringliteral">&quot;LAPACK algorithm for computing the singular value\n                    : decomposition of complex matrices did not converge and\n                    : therefore it was not possible to combine SH coefficients\n                    : from multiple shells. Changing the resolution may help,\n                    : contact me if this error persists.&quot;</span> );</div>
<div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;    }</div>
<div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;    </div>
<div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;    return ;</div>
<div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;    </div>
<div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="acdc79bf2506934c9ebbda9c13a2722ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc79bf2506934c9ebbda9c13a2722ad">&#9670;&nbsp;</a></span>complexMatrixSVDUandVOnly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::complexMatrixSVDUandVOnly </td>
          <td>(</td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>uAndV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fail</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute the real matrix SVD and return the U and V matrices. </p>
<p>This function converts the input proshade_double array of dimensions dim*dim onto the LAPACK compatible std::complex&lt;double&gt; matrix. It then proceeds to create a dummy variables for the U and V matrices for saving the SVD results as well as other required variables. It finally proceeds to call LAPACK ZGESDD function to compute the SVD of the real matrix input, checks the results and saves the U and V matrices for output. Note that this function does not make use of most of the LAPACK capabilities and is limitted onto square matrices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>Pointer to a real square matrix with dimensions dim * dim. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>The dimension of the real matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uAndV</td><td>Empty and allocated array of size dim*6 where the U and V matrices will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fail</td><td>If true and an error is encountered (typically algorithm not converging), this function will stop the program (useful for distances computations). However, if false, the function will simply return -777 as the first matrix element and not fail. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00869">869</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;{</div>
<div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;    <span class="comment">//================================================ Initialise local variables</span></div>
<div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;    <span class="keywordtype">char</span> job                                          = <span class="charliteral">&#39;A&#39;</span>;                                 <span class="comment">// Save computation of parts of U and V matrices, they are not needed here</span></div>
<div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;    <span class="keywordtype">double</span>* singularValues                            = <span class="keyword">new</span> <span class="keywordtype">double</span>[dim];                     <span class="comment">// The array of singular values</span></div>
<div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;    std::complex&lt;double&gt; *rotMatU                     = <span class="keyword">new</span> std::complex&lt;double&gt; [dim*dim];  <span class="comment">// The U matrix space</span></div>
<div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;    std::complex&lt;double&gt; *rotMatV                     = <span class="keyword">new</span> std::complex&lt;double&gt; [dim*dim];  <span class="comment">// The V^T matrix space</span></div>
<div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;    std::complex&lt;double&gt; *work                        = <span class="keyword">new</span> std::complex&lt;double&gt; [<span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span>( ( 3 * dim) + pow( dim, 2 ) * dim)]; <span class="comment">// Workspace, minimum required is 3*dim, using more for performance</span></div>
<div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;    <span class="keywordtype">int</span> workDim                                       = ( 3 * dim) + pow( dim, 2 );          <span class="comment">// Formalism stating just that</span></div>
<div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;    <span class="keywordtype">double</span>* rwork                                     = <span class="keyword">new</span> <span class="keywordtype">double</span>[<span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span>((5 * dim) + 5 * pow(dim,2))]; <span class="comment">// Required by LAPACK</span></div>
<div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;    <span class="keywordtype">int</span>* iwork                                        = <span class="keyword">new</span> <span class="keywordtype">int</span>[(8 * dim)];                  <span class="comment">// Required by LAPACK</span></div>
<div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;    <span class="keywordtype">int</span> returnValue                                   = 0;                                   <span class="comment">// This will tell if operation succeeded</span></div>
<div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( singularValues, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( rotMatU,        __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( rotMatV,        __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( work,           __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( rwork,          __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( iwork,          __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;    </div>
<div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;    <span class="comment">//================================================ Load input data into array in column-major order</span></div>
<div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;    std::complex&lt;double&gt; *matrixToDecompose           = <span class="keyword">new</span> std::complex&lt;double&gt;[dim*dim];</div>
<div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( matrixToDecompose, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;    <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> rowIt = 0; rowIt &lt; dim; rowIt++ )</div>
<div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;    {</div>
<div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;        <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> colIt = 0; colIt &lt; dim; colIt++ )</div>
<div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;        {</div>
<div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;            matrixToDecompose[(colIt*dim)+rowIt]      = std::complex&lt;double&gt; ( mat[(rowIt*dim)+colIt], 0.0 );</div>
<div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;        }</div>
<div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;    }</div>
<div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;    </div>
<div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;    <span class="comment">//================================================ Run LAPACK ZGESDD</span></div>
<div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;    zgesdd_                                           ( &amp;job, &amp;dim, &amp;dim, matrixToDecompose, &amp;dim, singularValues, rotMatU, &amp;dim, rotMatV, &amp;dim,</div>
<div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;                                                        work, &amp;workDim, rwork, iwork, &amp;returnValue );</div>
<div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;    </div>
<div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;    <span class="comment">//================================================ Free memory</span></div>
<div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;    <span class="keyword">delete</span>[] work;</div>
<div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;    <span class="keyword">delete</span>[] rwork;</div>
<div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;    <span class="keyword">delete</span>[] iwork;</div>
<div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;    <span class="keyword">delete</span>[] matrixToDecompose;</div>
<div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;    <span class="keyword">delete</span>[] singularValues;</div>
<div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;    </div>
<div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;    <span class="comment">//================================================ Check result</span></div>
<div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;    <span class="keywordflow">if</span> ( ( returnValue != 0 ) &amp;&amp; ( fail ) )</div>
<div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;    {</div>
<div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;        <span class="keywordflow">throw</span> <a class="code" href="class_pro_s_h_a_d_e__exception.html">ProSHADE_exception</a> ( <span class="stringliteral">&quot;The LAPACK complex SVD algorithm did not converge!&quot;</span>, <span class="stringliteral">&quot;EL00022&quot;</span>, __FILE__, __LINE__, __func__, <span class="stringliteral">&quot;LAPACK algorithm for computing the singular value\n                    : decomposition of complex matrices did not converge and\n                    : therefore it was not possible to optimise the peak\n                    : positions in the (self-)rotation function. Changing the\n                    : resolution may help, contact me if this error persists.&quot;</span> );</div>
<div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;    }</div>
<div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;    <span class="keywordflow">if</span> ( ( returnValue != 0 ) &amp;&amp; ( !fail ) )</div>
<div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;    {</div>
<div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;        uAndV[0]                                      =  -777.7;</div>
<div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;        return ;</div>
<div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;    }</div>
<div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;    </div>
<div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;    <span class="comment">//================================================ Save U</span></div>
<div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;    <span class="keywordflow">for</span> ( proshade_signed rowIt = 0; rowIt &lt; dim; rowIt++ )</div>
<div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;    {</div>
<div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;        <span class="keywordflow">for</span> ( proshade_signed colIt = 0; colIt &lt; dim; colIt++ )</div>
<div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;        {</div>
<div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;            uAndV[(rowIt*3)+colIt]                    = rotMatU[( rowIt * 3 ) + colIt].real();</div>
<div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;        }</div>
<div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;    }</div>
<div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;    </div>
<div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;    <span class="comment">//================================================ Save V</span></div>
<div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;    <span class="keywordflow">for</span> ( proshade_signed rowIt = 0; rowIt &lt; dim; rowIt++ )</div>
<div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;    {</div>
<div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;        <span class="keywordflow">for</span> ( proshade_signed colIt = 0; colIt &lt; dim; colIt++ )</div>
<div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;        {</div>
<div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;            uAndV[(rowIt*3)+colIt+9]                  = rotMatV[( rowIt * 3 ) + colIt].real();</div>
<div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;        }</div>
<div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;    }</div>
<div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;    </div>
<div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;    <span class="comment">//================================================ Release the rest of the memory</span></div>
<div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;    <span class="keyword">delete</span>[] rotMatU;</div>
<div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;    <span class="keyword">delete</span>[] rotMatV;</div>
<div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;    </div>
<div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;    return ;</div>
<div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;    </div>
<div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a254fece06e1cfce122a11ddea4f71970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254fece06e1cfce122a11ddea4f71970">&#9670;&nbsp;</a></span>complexMultiplication()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::complexMultiplication </td>
          <td>(</td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>retReal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>retImag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to multiply two complex numbers. </p>
<p>This function takes pointers to the real and imaginary parts of two complex numbers and returns the result of their multiplication.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r1</td><td>Pointer to the real value of number 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i1</td><td>Pointer to the imaginary value of number 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r2</td><td>Pointer to the real value of number 2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i2</td><td>Pointer to the imaginary value of number 2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">retReal</td><td>Pointer to the real part of the complex variable to which the result will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">retImag</td><td>Pointer to the imaginary part of the complex variable to which the result will be saved. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00038">38</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;{</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    <span class="comment">//================================================ Multiplication</span></div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    *retReal                                          = (*r1)*(*r2) - (*i1)*(*i2);</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    *retImag                                          = (*r1)*(*i2) + (*i1)*(*r2);</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    </div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <span class="comment">//================================================ Return</span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    return ;</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    </div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2ca5a3aedba75f52aaf707edc4e790f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ca5a3aedba75f52aaf707edc4e790f7">&#9670;&nbsp;</a></span>complexMultiplicationConjug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::complexMultiplicationConjug </td>
          <td>(</td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>retReal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>retImag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to multiply two complex numbers by using the second number's conjugate. </p>
<p>This function takes pointers to the real and imaginary parts of two complex numbers and returns the result of their multiplication, while using the conjugate of the second complex number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r1</td><td>Pointer to the real value of number 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i1</td><td>Pointer to the imaginary value of number 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r2</td><td>Pointer to the real value of number 2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i2</td><td>Pointer to the imaginary value of number 2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">retReal</td><td>Pointer to the real part of the complex variable to which the result will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">retImag</td><td>Pointer to the imaginary part of the complex variable to which the result will be saved. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00062">62</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;{</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    <span class="comment">//================================================ Multiplication</span></div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    *retReal                                          =  (*r1)*(*r2) + (*i1)*(*i2);</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    *retImag                                          = -(*r1)*(*i2) + (*i1)*(*r2);</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    </div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    <span class="comment">//================================================ Return</span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    return ;</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    </div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="abc59a55f5ed21de90e351005c58a871e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc59a55f5ed21de90e351005c58a871e">&#9670;&nbsp;</a></span>complexMultiplicationConjugRealOnly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">proshade_double ProSHADE_internal_maths::complexMultiplicationConjugRealOnly </td>
          <td>(</td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to conjuggate multiply two complex numbers and return the real part only. </p>
<p>This function takes pointers to the real and imaginary parts of two complex numbers and returns the real part of the result of their conjugate multiplication.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r1</td><td>Pointer to the real value of number 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i1</td><td>Pointer to the imaginary value of number 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r2</td><td>Pointer to the real value of number 2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i2</td><td>Pointer to the imaginary value of number 2. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00103">103</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;{</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    <span class="comment">//================================================ Multiplication</span></div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    proshade_double ret                               = (*r1)*(*r2) + (*i1)*(*i2);</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    </div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    <span class="comment">//================================================ Return</span></div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    <span class="keywordflow">return</span>                                            ( ret );</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    </div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac9b05344ffead449c29a333a57b404f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b05344ffead449c29a333a57b404f6">&#9670;&nbsp;</a></span>complexMultiplicationRealOnly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">proshade_double ProSHADE_internal_maths::complexMultiplicationRealOnly </td>
          <td>(</td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to multiply two complex numbers and return the real part only. </p>
<p>This function takes pointers to the real and imaginary parts of two complex numbers and returns the real part of the result of their multiplication.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r1</td><td>Pointer to the real value of number 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i1</td><td>Pointer to the imaginary value of number 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r2</td><td>Pointer to the real value of number 2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i2</td><td>Pointer to the imaginary value of number 2. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00083">83</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;{</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    <span class="comment">//================================================ Multiplication</span></div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    proshade_double ret                               = (*r1)*(*r2) - (*i1)*(*i2);</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    </div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    <span class="comment">//================================================ Return</span></div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    <span class="keywordflow">return</span>                                            ( ret );</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    </div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2ac3b534f974de25b092e9d48d9f7dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac3b534f974de25b092e9d48d9f7dea">&#9670;&nbsp;</a></span>computeDotProduct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">proshade_double ProSHADE_internal_maths::computeDotProduct </td>
          <td>(</td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>z1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>z2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple 3D vector dot product computation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x1</td><td>The x-axis element of the first vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y1</td><td>The y-axis element of the first vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z1</td><td>The z-axis element of the first vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x2</td><td>The x-axis element of the second vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y2</td><td>The y-axis element of the second vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z2</td><td>The z-axis element of the second vector. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01701">1701</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01702"></a><span class="lineno"> 1702</span>&#160;{</div>
<div class="line"><a name="l01703"></a><span class="lineno"> 1703</span>&#160;    <span class="comment">//================================================ Compute and return</span></div>
<div class="line"><a name="l01704"></a><span class="lineno"> 1704</span>&#160;    <span class="keywordflow">return</span>                                            ( (*x1 * *x2) + (*y1 * *y2) + (*z1 * *z2) );</div>
<div class="line"><a name="l01705"></a><span class="lineno"> 1705</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3b37ae1c35d048fd5dbff0a2cfcc4601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b37ae1c35d048fd5dbff0a2cfcc4601">&#9670;&nbsp;</a></span>computeDotProduct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">proshade_double ProSHADE_internal_maths::computeDotProduct </td>
          <td>(</td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>z1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>z2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple 3D vector dot product computation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x1</td><td>The x-axis element of the first vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y1</td><td>The y-axis element of the first vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z1</td><td>The z-axis element of the first vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x2</td><td>The x-axis element of the second vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y2</td><td>The y-axis element of the second vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z2</td><td>The z-axis element of the second vector. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01716">1716</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01717"></a><span class="lineno"> 1717</span>&#160;{</div>
<div class="line"><a name="l01718"></a><span class="lineno"> 1718</span>&#160;    <span class="comment">//================================================ Compute and return</span></div>
<div class="line"><a name="l01719"></a><span class="lineno"> 1719</span>&#160;    <span class="keywordflow">return</span>                                            ( (x1 * x2) + (y1 * y2) + (z1 * z2) );</div>
<div class="line"><a name="l01720"></a><span class="lineno"> 1720</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7e69b64278319ae1a1268d1a55545675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e69b64278319ae1a1268d1a55545675">&#9670;&nbsp;</a></span>evaluateGLSeries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">proshade_double ProSHADE_internal_maths::evaluateGLSeries </td>
          <td>(</td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>series</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>terms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function evaluates the Taylor expansion. </p>
<p>This function takes the series array, the target value and the cap on Taylor expansion and proceeds to evaluate the series. The main use of this is to evaluate the series twice, one where the series evaluation 'overshoots' and once where it 'undershoots' and taking value in between those, thus adding accuracy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">series</td><td>Pointer to array with the series values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>The target location on the series value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">terms</td><td>The Taylor expansion cap. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>The value of the series at the target location. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00447">447</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;{</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;    <span class="comment">//================================================ Initalise</span></div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;    proshade_double factorialValue                    = 1.0;</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;    proshade_double value                             = 0.0;</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;    </div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;    <span class="comment">//================================================ Compute</span></div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 1; iter &lt;= terms; iter++ )</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;    {</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;        value                                         = value + series[iter] * factorialValue;</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;        factorialValue                                = factorialValue * target;</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;    }</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;    </div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;    <span class="keywordflow">return</span> ( value );</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;    </div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2454c19169bb38d616e52b99f1dc4495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2454c19169bb38d616e52b99f1dc4495">&#9670;&nbsp;</a></span>findAllPrimes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; proshade_unsign &gt; ProSHADE_internal_maths::findAllPrimes </td>
          <td>(</td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>upTo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function finds all prime numbers up to the supplied limit. </p>
<p>This function uses the sieve of Eratosthenes algorithm to find all prime numbers from 2 to the supplied limit. This is not the fastest algorithm and it may become slow when the limit is high, but it is fine for small numbers and given that we will use it for symmetry folds, which should not got much over 20, this should be more than fast enough.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">upTo</td><td>The limit to which prime numbers should be sought. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l02476">2476</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02477"></a><span class="lineno"> 2477</span>&#160;{</div>
<div class="line"><a name="l02478"></a><span class="lineno"> 2478</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l02479"></a><span class="lineno"> 2479</span>&#160;    std::vector&lt; proshade_unsign &gt; ret;</div>
<div class="line"><a name="l02480"></a><span class="lineno"> 2480</span>&#160;    std::vector&lt; std::pair&lt; proshade_unsign, bool &gt; &gt; sieveOfEratosthenesArray;</div>
<div class="line"><a name="l02481"></a><span class="lineno"> 2481</span>&#160;    </div>
<div class="line"><a name="l02482"></a><span class="lineno"> 2482</span>&#160;    <span class="comment">//================================================ Sanity check</span></div>
<div class="line"><a name="l02483"></a><span class="lineno"> 2483</span>&#160;    <span class="keywordflow">if</span> ( upTo &lt; 2 ) { <span class="keywordflow">return</span> ( ret ); }</div>
<div class="line"><a name="l02484"></a><span class="lineno"> 2484</span>&#160;    </div>
<div class="line"><a name="l02485"></a><span class="lineno"> 2485</span>&#160;    <span class="comment">//================================================ Initialise the sieve array up to the required number</span></div>
<div class="line"><a name="l02486"></a><span class="lineno"> 2486</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 2; iter &lt;= upTo; iter++ ) { sieveOfEratosthenesArray.emplace_back ( std::pair&lt; proshade_unsign, bool &gt; ( iter, <span class="keyword">true</span> ) ); }</div>
<div class="line"><a name="l02487"></a><span class="lineno"> 2487</span>&#160;    </div>
<div class="line"><a name="l02488"></a><span class="lineno"> 2488</span>&#160;    <span class="comment">//================================================ For each entry in the array</span></div>
<div class="line"><a name="l02489"></a><span class="lineno"> 2489</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; static_cast&lt;proshade_unsign&gt; ( sieveOfEratosthenesArray.size() ); iter++ )</div>
<div class="line"><a name="l02490"></a><span class="lineno"> 2490</span>&#160;    {</div>
<div class="line"><a name="l02491"></a><span class="lineno"> 2491</span>&#160;        <span class="comment">//============================================ If this entry is still true</span></div>
<div class="line"><a name="l02492"></a><span class="lineno"> 2492</span>&#160;        <span class="keywordflow">if</span> ( sieveOfEratosthenesArray.at(iter).second )</div>
<div class="line"><a name="l02493"></a><span class="lineno"> 2493</span>&#160;        {</div>
<div class="line"><a name="l02494"></a><span class="lineno"> 2494</span>&#160;            <span class="comment">//======================================== Set all entries with the position x * [this entry value] to false</span></div>
<div class="line"><a name="l02495"></a><span class="lineno"> 2495</span>&#160;            <span class="keywordflow">for</span> ( proshade_unsign it = iter + sieveOfEratosthenesArray.at(iter).first; it &lt; static_cast&lt;proshade_unsign&gt; ( sieveOfEratosthenesArray.size() ); it += sieveOfEratosthenesArray.at(iter).first )</div>
<div class="line"><a name="l02496"></a><span class="lineno"> 2496</span>&#160;            {</div>
<div class="line"><a name="l02497"></a><span class="lineno"> 2497</span>&#160;                sieveOfEratosthenesArray.at(it).second = <span class="keyword">false</span>;</div>
<div class="line"><a name="l02498"></a><span class="lineno"> 2498</span>&#160;            }</div>
<div class="line"><a name="l02499"></a><span class="lineno"> 2499</span>&#160;        }</div>
<div class="line"><a name="l02500"></a><span class="lineno"> 2500</span>&#160;    }</div>
<div class="line"><a name="l02501"></a><span class="lineno"> 2501</span>&#160;    </div>
<div class="line"><a name="l02502"></a><span class="lineno"> 2502</span>&#160;    <span class="comment">//================================================ Copy passing results to return vector</span></div>
<div class="line"><a name="l02503"></a><span class="lineno"> 2503</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; static_cast&lt;proshade_unsign&gt; ( sieveOfEratosthenesArray.size() ); iter++ )</div>
<div class="line"><a name="l02504"></a><span class="lineno"> 2504</span>&#160;    {</div>
<div class="line"><a name="l02505"></a><span class="lineno"> 2505</span>&#160;        <span class="keywordflow">if</span> ( sieveOfEratosthenesArray.at(iter).second ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;ret, sieveOfEratosthenesArray.at(iter).first ); }</div>
<div class="line"><a name="l02506"></a><span class="lineno"> 2506</span>&#160;    }</div>
<div class="line"><a name="l02507"></a><span class="lineno"> 2507</span>&#160;    </div>
<div class="line"><a name="l02508"></a><span class="lineno"> 2508</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l02509"></a><span class="lineno"> 2509</span>&#160;    <span class="keywordflow">return</span>                                            ( ret );</div>
<div class="line"><a name="l02510"></a><span class="lineno"> 2510</span>&#160;    </div>
<div class="line"><a name="l02511"></a><span class="lineno"> 2511</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae9f376bb341b192fff008b9b4ef5c603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f376bb341b192fff008b9b4ef5c603">&#9670;&nbsp;</a></span>findVectorFromThreeVAndThreeD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; proshade_double &gt; ProSHADE_internal_maths::findVectorFromThreeVAndThreeD </td>
          <td>(</td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>z1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>z2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>y3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>z3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>dot1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>dot2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>dot3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for finding a vector which would have a given three dot products to three other vectors. </p>
<p>This function takes three vectors and three dot product values. It then basically solves the following set of equations for x, y and z: </p><pre class="fragment">solX*x1 + solY*y1 + solZ*z1 = dot1
solX*x2 + solY*y2 + solZ*z2 = dot2
solX*x3 + solY*y3 + solZ*z3 = dot3
</pre><p>This should result in a vector, which has the required angles to all input vectors and is normalised (this is done later as part of this function). The equations are courtesy of <a href="https://www.wolframalpha.com/input/?i=Solve%5B%7Ba+x+%2B+b+y+%2B+c+z+%3D%3D+f%2C+u+x+%2B+v+y+%2B+w+z+%3D%3D+g%2C+k+x+%2B+l+y+%2B+m+z+%3D%3D+h%7D%2C+%7Bx%2C+y%2C+z%7D%5D">https://www.wolframalpha.com/input/?i=Solve%5B%7Ba+x+%2B+b+y+%2B+c+z+%3D%3D+f%2C+u+x+%2B+v+y+%2B+w+z+%3D%3D+g%2C+k+x+%2B+l+y+%2B+m+z+%3D%3D+h%7D%2C+%7Bx%2C+y%2C+z%7D%5D</a> webpage of Wolfram Alpha. If in doubt, do not fear to derive yourself :-).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x1</td><td>The x-axis element of the first vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y1</td><td>The y-axis element of the first vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z1</td><td>The z-axis element of the first vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x2</td><td>The x-axis element of the second vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y2</td><td>The y-axis element of the second vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z2</td><td>The z-axis element of the second vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dot1</td><td>The dot product specifying the angle between the sought vector and the first input vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dot2</td><td>The dot product specifying the angle between the sought vector and the second input vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vec</td><td>A std::vector containing the three elements of the sought vector. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01885">1885</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01886"></a><span class="lineno"> 1886</span>&#160;{</div>
<div class="line"><a name="l01887"></a><span class="lineno"> 1887</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l01888"></a><span class="lineno"> 1888</span>&#160;    std::vector &lt; proshade_double &gt; ret;</div>
<div class="line"><a name="l01889"></a><span class="lineno"> 1889</span>&#160;    </div>
<div class="line"><a name="l01890"></a><span class="lineno"> 1890</span>&#160;    <span class="comment">//================================================ Solution</span></div>
<div class="line"><a name="l01891"></a><span class="lineno"> 1891</span>&#160;    proshade_double solX                              = - (  y1 * dot2 * z3 - y1 * dot3 * z2 - z1 * dot2 * y3 + z1 * dot3 * y2 + dot1 * y3 * z2 - dot1 * z3 * y2 ) /</div>
<div class="line"><a name="l01892"></a><span class="lineno"> 1892</span>&#160;                                                          ( -x1 * y3 * z2 + x1 * z3 * y2 + y1 * x3 * z2 - y1 * z3 * x2 - z1 * x3 * y2 + z1 * y3 * x2 );</div>
<div class="line"><a name="l01893"></a><span class="lineno"> 1893</span>&#160;    proshade_double solY                              = - (  x1 * dot2 * z3 - x1 * dot3 * z2 - z1 * dot2 * x3 + z1 * dot3 * x2 + dot1 * x3 * z2 - dot1 * z3 * x2 ) /</div>
<div class="line"><a name="l01894"></a><span class="lineno"> 1894</span>&#160;                                                          (  x1 * y3 * z2 - x1 * z3 * y2 - y1 * x3 * z2 + y1 * z3 * x2 + z1 * x3 * y2 - z1 * y3 * x2 );</div>
<div class="line"><a name="l01895"></a><span class="lineno"> 1895</span>&#160;    proshade_double solZ                              = - (  x1 * dot2 * y3 - x1 * dot3 * y2 - y1 * dot2 * x3 + y1 * dot3 * x2 + dot1 * x3 * y2 - dot1 * y3 * x2 ) /</div>
<div class="line"><a name="l01896"></a><span class="lineno"> 1896</span>&#160;                                                          ( -x1 * y3 * z2 + x1 * z3 * y2 + y1 * x3 * z2 - y1 * z3 * x2 - z1 * x3 * y2 + z1 * y3 * x2 );</div>
<div class="line"><a name="l01897"></a><span class="lineno"> 1897</span>&#160; </div>
<div class="line"><a name="l01898"></a><span class="lineno"> 1898</span>&#160;    <span class="comment">//================================================ Normalise the axis to magnitude 1</span></div>
<div class="line"><a name="l01899"></a><span class="lineno"> 1899</span>&#160;    proshade_double normFactor                        = sqrt ( pow ( solX, 2.0 ) + pow ( solY, 2.0 ) + pow ( solZ, 2.0 ) );</div>
<div class="line"><a name="l01900"></a><span class="lineno"> 1900</span>&#160;    solX                                             /= normFactor;</div>
<div class="line"><a name="l01901"></a><span class="lineno"> 1901</span>&#160;    solY                                             /= normFactor;</div>
<div class="line"><a name="l01902"></a><span class="lineno"> 1902</span>&#160;    solZ                                             /= normFactor;</div>
<div class="line"><a name="l01903"></a><span class="lineno"> 1903</span>&#160;    </div>
<div class="line"><a name="l01904"></a><span class="lineno"> 1904</span>&#160;    <span class="comment">//================================================ Set largest axis element to positive (ProSHADE standard)</span></div>
<div class="line"><a name="l01905"></a><span class="lineno"> 1905</span>&#160;    <span class="keywordflow">if</span> ( ( ( std::max ( std::abs ( solX ), std::max( std::abs ( solY ), std::abs ( solZ ) ) ) == std::abs ( solX ) ) &amp;&amp; ( solX &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l01906"></a><span class="lineno"> 1906</span>&#160;         ( ( std::max ( std::abs ( solX ), std::max( std::abs ( solY ), std::abs ( solZ ) ) ) == std::abs ( solY ) ) &amp;&amp; ( solY &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l01907"></a><span class="lineno"> 1907</span>&#160;         ( ( std::max ( std::abs ( solX ), std::max( std::abs ( solY ), std::abs ( solZ ) ) ) == std::abs ( solZ ) ) &amp;&amp; ( solZ &lt; 0.0 ) ) ) { solX *= -1.0; solY *= -1.0; solZ *= -1.0; }</div>
<div class="line"><a name="l01908"></a><span class="lineno"> 1908</span>&#160;    </div>
<div class="line"><a name="l01909"></a><span class="lineno"> 1909</span>&#160;    <span class="comment">//================================================ Save solutions</span></div>
<div class="line"><a name="l01910"></a><span class="lineno"> 1910</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a>         ( &amp;ret, solX  );</div>
<div class="line"><a name="l01911"></a><span class="lineno"> 1911</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a>         ( &amp;ret, solY  );</div>
<div class="line"><a name="l01912"></a><span class="lineno"> 1912</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a>         ( &amp;ret, solZ  );</div>
<div class="line"><a name="l01913"></a><span class="lineno"> 1913</span>&#160;    </div>
<div class="line"><a name="l01914"></a><span class="lineno"> 1914</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01915"></a><span class="lineno"> 1915</span>&#160;    <span class="keywordflow">return</span>                                            ( ret );</div>
<div class="line"><a name="l01916"></a><span class="lineno"> 1916</span>&#160;    </div>
<div class="line"><a name="l01917"></a><span class="lineno"> 1917</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a45fbcfaeaabf9bae2fbd7d46a5fb4bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45fbcfaeaabf9bae2fbd7d46a5fb4bc7">&#9670;&nbsp;</a></span>findVectorFromTwoVAndTwoD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; proshade_double &gt; ProSHADE_internal_maths::findVectorFromTwoVAndTwoD </td>
          <td>(</td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>z1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>z2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>dot1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>dot2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for finding a vector which would have a given two dot products to two other vectors. </p>
<p>This function takes two vectors and two dot product values. It then basically solves the following set of equations for x, y and z: </p><pre class="fragment">solX*x1 + solY*y1 + solZ*z1 = dot1
solX*x2 + solY*y2 + solZ*z2 = dot2
sqrt ( solX^2 + solY^2 + solZ^2 ) = 1.0
</pre><p>This should result in a vector, which has the required angles to both input vectors and is normalised (this is done by the third equation, which is required to obtain system of three equations with three unkonwns). The equations are courtesy of <a href="https://www.wolframalpha.com/input/?i=Solve%5B%7Ba+x+%2B+b+y+%2B+c+z+%3D%3D+f%2C+k+x+%2B+l+y+%2B+m+z+%3D%3D+g%2C+Sqrt%5Bx%5E2+%2B+y%5E2+%2B+z%5E2%5D+%3D%3D+1%7D%2C+%7Bx%2C+y%2C+z%7D%5D">https://www.wolframalpha.com/input/?i=Solve%5B%7Ba+x+%2B+b+y+%2B+c+z+%3D%3D+f%2C+k+x+%2B+l+y+%2B+m+z+%3D%3D+g%2C+Sqrt%5Bx%5E2+%2B+y%5E2+%2B+z%5E2%5D+%3D%3D+1%7D%2C+%7Bx%2C+y%2C+z%7D%5D</a> webpage of Wolfram Alpha. If in doubt, do not fear to derive yourself :-).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x1</td><td>The x-axis element of the first vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y1</td><td>The y-axis element of the first vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z1</td><td>The z-axis element of the first vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x2</td><td>The x-axis element of the second vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y2</td><td>The y-axis element of the second vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z2</td><td>The z-axis element of the second vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dot1</td><td>The dot product specifying the angle between the sought vector and the first input vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dot2</td><td>The dot product specifying the angle between the sought vector and the second input vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vec</td><td>A std::vector containing the three elements of the sought vector. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01743">1743</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01744"></a><span class="lineno"> 1744</span>&#160;{</div>
<div class="line"><a name="l01745"></a><span class="lineno"> 1745</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l01746"></a><span class="lineno"> 1746</span>&#160;    std::vector &lt; proshade_double &gt; ret;</div>
<div class="line"><a name="l01747"></a><span class="lineno"> 1747</span>&#160;    </div>
<div class="line"><a name="l01748"></a><span class="lineno"> 1748</span>&#160;    <span class="comment">//================================================ Solution</span></div>
<div class="line"><a name="l01749"></a><span class="lineno"> 1749</span>&#160;    proshade_double solX                              = ( -sqrt ( pow ( 2.0 * x1 * y1 * dot2 * y2 + 2.0 * x1 * z1 * dot2 * z2 - 2.0 * x1 * dot1 * pow ( y2, 2.0 ) - 2.0 * x1 * dot1 * pow ( z2, 2.0 ) - 2.0 * pow ( y1, 2.0 ) * dot2 * x2 + 2.0 * y1 * dot1 * x2 * y2 - 2.0 * pow ( z1, 2.0 ) * dot2 * x2 + 2.0 * z1 * dot1 * x2 * z2, 2.0 ) -</div>
<div class="line"><a name="l01750"></a><span class="lineno"> 1750</span>&#160;                                                                  4.0 * ( pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * x1 * y1 * x2 * y2 - 2.0 * x1 * z1 * x2 * z2 + pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) ) *</div>
<div class="line"><a name="l01751"></a><span class="lineno"> 1751</span>&#160;                                                                  ( pow ( y1, 2.0 ) * pow ( dot2, 2.0 ) - pow ( y1, 2.0 ) * pow ( z2, 2.0 ) + 2.0 * y1 * z1 * y2 * z2 - 2.0 * y1 * dot1 * dot2 * y2 + pow ( z1, 2.0 ) * pow ( dot2, 2.0 ) - pow ( z1, 2.0 ) * pow ( y2, 2.0 ) - 2.0 * z1 * dot1 * dot2 * z2 + pow ( dot1, 2.0 ) * pow ( y2, 2.0 ) + pow ( dot1, 2.0 ) * pow ( z2, 2.0 ) ) ) -</div>
<div class="line"><a name="l01752"></a><span class="lineno"> 1752</span>&#160;                                                          2.0 * x1 * y1 * dot2 * y2 - 2.0 * x1 * z1 * dot2 * z2 + 2.0 * x1 * dot1 * pow ( y2, 2.0 ) + 2.0 * x1 * dot1 * pow ( z2, 2.0 ) + 2.0 * pow ( y1, 2.0 ) * dot2 * x2 - 2.0 * y1 * dot1 * x2 * y2 + 2.0 * pow ( z1, 2.0 ) * dot2 * x2 - 2.0 * z1 * dot1 * x2 * z2 ) /</div>
<div class="line"><a name="l01753"></a><span class="lineno"> 1753</span>&#160;                                                        ( 2.0 * ( pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * x1 * y1 * x2 * y2 - 2.0 * x1 * z1 * x2 * z2 + pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) ) );</div>
<div class="line"><a name="l01754"></a><span class="lineno"> 1754</span>&#160;    proshade_double solY                              = ( ( dot2 * pow ( x2, 2.0 ) * pow ( z1, 3.0 ) ) /</div>
<div class="line"><a name="l01755"></a><span class="lineno"> 1755</span>&#160;                                                          ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) -</div>
<div class="line"><a name="l01756"></a><span class="lineno"> 1756</span>&#160;                                                          ( dot1 * pow ( x2, 2.0 ) * z2 * pow ( z1, 2.0 ) ) /</div>
<div class="line"><a name="l01757"></a><span class="lineno"> 1757</span>&#160;                                                          ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) -</div>
<div class="line"><a name="l01758"></a><span class="lineno"> 1758</span>&#160;                                                          ( 2.0 * x1 * dot2 * x2 * z2 * pow ( z1, 2.0 ) ) /</div>
<div class="line"><a name="l01759"></a><span class="lineno"> 1759</span>&#160;                                                          ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) - dot2 * z1 -</div>
<div class="line"><a name="l01760"></a><span class="lineno"> 1760</span>&#160;                                                          ( x2 * sqrt ( pow ( - 2.0 * dot2 * x2 * pow ( y1, 2.0 ) + 2.0 * x1 * dot2 * y2 * y1 + 2.0 * dot1 * x2 * y2 * y1 - 2.0 * x1 * dot1 * pow ( y2, 2.0 ) - 2.0 * x1 * dot1 * pow ( z2, 2.0 ) - 2.0 * pow ( z1, 2.0 ) * dot2 * x2 + 2.0 * x1 * z1 * dot2 * z2 + 2.0 * z1 * dot1 * x2 * z2, 2.0 ) -</div>
<div class="line"><a name="l01761"></a><span class="lineno"> 1761</span>&#160;                                                                        4.0 * ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) *</div>
<div class="line"><a name="l01762"></a><span class="lineno"> 1762</span>&#160;                                                                        ( pow ( y1, 2.0 ) * pow ( dot2, 2.0 ) + pow ( z1, 2.0 ) * pow ( dot2, 2.0 ) - 2.0 * y1 * dot1 * y2 * dot2 - 2.0 * z1 * dot1 * z2 * dot2 - pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( dot1, 2.0 ) * pow ( y2, 2.0 ) - pow ( y1, 2.0 ) * pow ( z2, 2.0 ) + pow ( dot1, 2.0 ) * pow ( z2, 2.0 ) + 2.0 * y1 * z1 * y2 * z2 ) ) * z1 ) /</div>
<div class="line"><a name="l01763"></a><span class="lineno"> 1763</span>&#160;                                                          ( 2.0 * ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) ) +</div>
<div class="line"><a name="l01764"></a><span class="lineno"> 1764</span>&#160;                                                          ( pow ( y1, 2.0 ) * dot2 * pow ( x2, 2.0 ) * z1 ) /</div>
<div class="line"><a name="l01765"></a><span class="lineno"> 1765</span>&#160;                                                          ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) +</div>
<div class="line"><a name="l01766"></a><span class="lineno"> 1766</span>&#160;                                                          ( x1 * dot1 * x2 * pow ( y2, 2.0 ) * z1 ) /</div>
<div class="line"><a name="l01767"></a><span class="lineno"> 1767</span>&#160;                                                          ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) +</div>
<div class="line"><a name="l01768"></a><span class="lineno"> 1768</span>&#160;                                                          ( pow ( x1, 2.0 ) * dot2 * pow ( z2, 2.0 ) * z1 ) /</div>
<div class="line"><a name="l01769"></a><span class="lineno"> 1769</span>&#160;                                                          ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) +</div>
<div class="line"><a name="l01770"></a><span class="lineno"> 1770</span>&#160;                                                          ( 2.0 * x1 * dot1 * x2 * pow ( z2, 2.0 ) * z1 ) /</div>
<div class="line"><a name="l01771"></a><span class="lineno"> 1771</span>&#160;                                                          ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) -</div>
<div class="line"><a name="l01772"></a><span class="lineno"> 1772</span>&#160;                                                          ( y1 * dot1 * pow ( x2, 2.0 ) * y2 * z1 ) /</div>
<div class="line"><a name="l01773"></a><span class="lineno"> 1773</span>&#160;                                                          ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) -</div>
<div class="line"><a name="l01774"></a><span class="lineno"> 1774</span>&#160;                                                          ( x1 * y1 * dot2 * x2 * y2 * z1 ) /</div>
<div class="line"><a name="l01775"></a><span class="lineno"> 1775</span>&#160;                                                          ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) + dot1 * z2 +</div>
<div class="line"><a name="l01776"></a><span class="lineno"> 1776</span>&#160;                                                          ( x1 * z2 * sqrt ( pow ( -2.0 * dot2 * x2 * pow ( y1, 2.0 ) + 2.0 * x1 * dot2 * y2 * y1 + 2.0 * dot1 * x2 * y2 * y1 - 2.0 * x1 * dot1 * pow ( y2, 2.0 ) - 2.0 * x1 * dot1 * pow ( z2, 2.0 ) - 2.0 * pow ( z1, 2.0 ) * dot2 * x2 + 2.0 * x1 * z1 * dot2 * z2 + 2.0 * z1 * dot1 * x2 * z2, 2.0 ) -</div>
<div class="line"><a name="l01777"></a><span class="lineno"> 1777</span>&#160;                                                                             4.0 * ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) *</div>
<div class="line"><a name="l01778"></a><span class="lineno"> 1778</span>&#160;                                                                             ( pow ( y1, 2.0 ) * pow ( dot2, 2.0 ) + pow ( z1, 2.0 ) * pow ( dot2, 2.0 ) - 2.0 * y1 * dot1 * y2 * dot2 - 2.0 * z1 * dot1 * z2 * dot2 - pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( dot1, 2.0 ) * pow ( y2, 2.0 ) - pow ( y1, 2.0 ) * pow ( z2, 2.0 ) + pow ( dot1, 2.0 ) * pow ( z2, 2.0 ) + 2.0 * y1 * z1 * y2 * z2 ) ) ) /</div>
<div class="line"><a name="l01779"></a><span class="lineno"> 1779</span>&#160;                                                          ( 2.0 * ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) ) -</div>
<div class="line"><a name="l01780"></a><span class="lineno"> 1780</span>&#160;                                                          ( pow ( x1, 2.0 ) * dot1 * pow ( z2, 3.0 ) ) /</div>
<div class="line"><a name="l01781"></a><span class="lineno"> 1781</span>&#160;                                                          ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) -</div>
<div class="line"><a name="l01782"></a><span class="lineno"> 1782</span>&#160;                                                          ( pow ( x1, 2.0 ) * dot1 * pow ( y2, 2.0 ) * z2 ) /</div>
<div class="line"><a name="l01783"></a><span class="lineno"> 1783</span>&#160;                                                          ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) -</div>
<div class="line"><a name="l01784"></a><span class="lineno"> 1784</span>&#160;                                                          ( x1 * pow ( y1, 2.0 ) * dot2 * x2 * z2 ) /</div>
<div class="line"><a name="l01785"></a><span class="lineno"> 1785</span>&#160;                                                          ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) +</div>
<div class="line"><a name="l01786"></a><span class="lineno"> 1786</span>&#160;                                                          ( pow ( x1, 2.0 ) * y1 * dot2 * y2 * z2 ) /</div>
<div class="line"><a name="l01787"></a><span class="lineno"> 1787</span>&#160;                                                          ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) +</div>
<div class="line"><a name="l01788"></a><span class="lineno"> 1788</span>&#160;                                                          ( x1 * y1 * dot1 * x2 * y2 * z2 ) /</div>
<div class="line"><a name="l01789"></a><span class="lineno"> 1789</span>&#160;                                                          ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) ) / ( y1 * z2 - z1 * y2 );</div>
<div class="line"><a name="l01790"></a><span class="lineno"> 1790</span>&#160;    proshade_double solZ                              = ( - ( dot2 * pow ( x2, 2.0 ) * y2 * pow ( z1, 3.0 ) ) /</div>
<div class="line"><a name="l01791"></a><span class="lineno"> 1791</span>&#160;                                                            ( ( y1 * z2 - z1 * y2 ) * ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) ) -</div>
<div class="line"><a name="l01792"></a><span class="lineno"> 1792</span>&#160;                                                            ( dot2 * pow ( x2, 2.0 ) * pow ( z1, 2.0 ) ) /</div>
<div class="line"><a name="l01793"></a><span class="lineno"> 1793</span>&#160;                                                            ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) +</div>
<div class="line"><a name="l01794"></a><span class="lineno"> 1794</span>&#160;                                                            ( dot1 * pow ( x2, 2.0 ) * y2 * z2 * pow ( z1, 2.0 ) ) /</div>
<div class="line"><a name="l01795"></a><span class="lineno"> 1795</span>&#160;                                                            ( ( y1 * z2 - z1 * y2 ) * ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) ) +</div>
<div class="line"><a name="l01796"></a><span class="lineno"> 1796</span>&#160;                                                            ( 2.0 * x1 * dot2 * x2 * y2 * z2 * pow ( z1, 2.0 ) ) /</div>
<div class="line"><a name="l01797"></a><span class="lineno"> 1797</span>&#160;                                                            ( ( y1 * z2 - z1 * y2 ) * ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) ) +</div>
<div class="line"><a name="l01798"></a><span class="lineno"> 1798</span>&#160;                                                            ( x2 * y2 * sqrt ( pow ( -2.0 * dot2 * x2 * pow ( y1, 2.0 ) + 2.0 * x1 * dot2 * y2 * y1 + 2.0 * dot1 * x2 * y2 * y1 - 2.0 * x1 * dot1 * pow ( y2, 2.0 ) - 2.0 * x1 * dot1 * pow ( z2, 2.0 ) - 2.0 * pow ( z1, 2.0 ) * dot2 * x2 + 2.0 * x1 * z1 * dot2 * z2 + 2.0 * z1 * dot1 * x2 * z2, 2.0 ) -</div>
<div class="line"><a name="l01799"></a><span class="lineno"> 1799</span>&#160;                                                                              4.0 * ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) *</div>
<div class="line"><a name="l01800"></a><span class="lineno"> 1800</span>&#160;                                                                              ( pow ( y1, 2.0 ) * pow ( dot2, 2.0 ) + pow ( z1, 2.0 ) * pow ( dot2, 2.0 ) - 2.0 * y1 * dot1 * y2 * dot2 - 2.0 * z1 * dot1 * z2 * dot2 - pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( dot1, 2.0 ) * pow ( y2, 2.0 ) - pow ( y1, 2.0 ) * pow ( z2, 2.0 ) + pow ( dot1, 2.0 ) * pow ( z2, 2.0 ) + 2.0 * y1 * z1 * y2 * z2 ) ) * z1 ) /</div>
<div class="line"><a name="l01801"></a><span class="lineno"> 1801</span>&#160;                                                            ( 2.0 * ( y1 * z2 - z1 * y2 ) * ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) ) +</div>
<div class="line"><a name="l01802"></a><span class="lineno"> 1802</span>&#160;                                                            ( dot2 * y2 * z1 ) / ( y1 * z2 - z1 * y2 ) +</div>
<div class="line"><a name="l01803"></a><span class="lineno"> 1803</span>&#160;                                                            ( dot1 * pow ( x2, 2.0 ) * z2 * z1 ) /</div>
<div class="line"><a name="l01804"></a><span class="lineno"> 1804</span>&#160;                                                            ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) +</div>
<div class="line"><a name="l01805"></a><span class="lineno"> 1805</span>&#160;                                                            ( x1 * dot2 * x2 * z2 * z1 ) /</div>
<div class="line"><a name="l01806"></a><span class="lineno"> 1806</span>&#160;                                                            ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) -</div>
<div class="line"><a name="l01807"></a><span class="lineno"> 1807</span>&#160;                                                            ( x1 * dot1 * x2 * pow ( y2, 3.0 ) * z1 ) /</div>
<div class="line"><a name="l01808"></a><span class="lineno"> 1808</span>&#160;                                                            ( ( y1 * z2 - z1 * y2 ) * ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) ) +</div>
<div class="line"><a name="l01809"></a><span class="lineno"> 1809</span>&#160;                                                            ( y1 * dot1 * pow ( x2, 2.0 ) * pow ( y2, 2.0 ) * z1 ) /</div>
<div class="line"><a name="l01810"></a><span class="lineno"> 1810</span>&#160;                                                            ( ( y1 * z2 - z1 * y2 ) * ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) ) +</div>
<div class="line"><a name="l01811"></a><span class="lineno"> 1811</span>&#160;                                                            ( x1 * y1 * dot2 * x2 * pow ( y2, 2.0 ) * z1 ) /</div>
<div class="line"><a name="l01812"></a><span class="lineno"> 1812</span>&#160;                                                            ( ( y1 * z2 - z1 * y2 ) * ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) ) -</div>
<div class="line"><a name="l01813"></a><span class="lineno"> 1813</span>&#160;                                                            ( pow ( x1, 2.0 ) * dot2 * y2 * pow ( z2, 2.0 ) * z1 ) /</div>
<div class="line"><a name="l01814"></a><span class="lineno"> 1814</span>&#160;                                                            ( ( y1 * z2 - z1 * y2 ) * ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) ) -</div>
<div class="line"><a name="l01815"></a><span class="lineno"> 1815</span>&#160;                                                            ( 2.0 * x1 * dot1 * x2 * y2 * pow ( z2, 2.0 ) * z1 ) /</div>
<div class="line"><a name="l01816"></a><span class="lineno"> 1816</span>&#160;                                                            ( ( y1 * z2 - z1 * y2 ) * ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) ) -</div>
<div class="line"><a name="l01817"></a><span class="lineno"> 1817</span>&#160;                                                            ( pow ( y1, 2.0 ) * dot2 * pow ( x2, 2.0 ) * y2 * z1 ) /</div>
<div class="line"><a name="l01818"></a><span class="lineno"> 1818</span>&#160;                                                            ( ( y1 * z2 - z1 * y2 ) * ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) ) + dot2 +</div>
<div class="line"><a name="l01819"></a><span class="lineno"> 1819</span>&#160;                                                            ( x2 * sqrt ( pow ( - 2.0 * dot2 * x2 * pow ( y1, 2.0 ) + 2.0 * x1 * dot2 * y2 * y1 + 2.0 * dot1 * x2 * y2 * y1 - 2.0 * x1 * dot1 * pow ( y2, 2.0 ) - 2.0 * x1 * dot1 * pow ( z2, 2.0 ) - 2.0 * pow ( z1, 2.0 ) * dot2 * x2 + 2.0 * x1 * z1 * dot2 * z2 + 2.0 * z1 * dot1 * x2 * z2, 2.0 ) -</div>
<div class="line"><a name="l01820"></a><span class="lineno"> 1820</span>&#160;                                                                          4.0 * ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) *</div>
<div class="line"><a name="l01821"></a><span class="lineno"> 1821</span>&#160;                                                                          ( pow ( y1, 2.0 ) * pow ( dot2, 2.0 ) + pow ( z1, 2.0 ) * pow ( dot2, 2.0 ) - 2.0 * y1 * dot1 * y2 * dot2 - 2.0 * z1 * dot1 * z2 * dot2 - pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( dot1, 2.0 ) * pow ( y2, 2.0 ) - pow ( y1, 2.0 ) * pow ( z2, 2.0 ) + pow ( dot1, 2.0 ) * pow ( z2, 2.0 ) + 2.0 * y1 * z1 * y2 * z2 ) ) ) /</div>
<div class="line"><a name="l01822"></a><span class="lineno"> 1822</span>&#160;                                                            ( 2.0 * ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) ) -</div>
<div class="line"><a name="l01823"></a><span class="lineno"> 1823</span>&#160;                                                            ( x1 * y2 * z2 * sqrt ( pow ( - 2.0 * dot2 * x2 * pow ( y1, 2.0 ) + 2.0 * x1 * dot2 * y2 * y1 + 2.0 * dot1 * x2 * y2 * y1 - 2.0 * x1 * dot1 * pow ( y2, 2.0 ) - 2.0 * x1 * dot1 * pow ( z2, 2.0 ) - 2.0 * pow ( z1, 2.0 ) * dot2 * x2 + 2.0 * x1 * z1 * dot2 * z2 + 2.0 * z1 * dot1 * x2 * z2, 2.0 ) -</div>
<div class="line"><a name="l01824"></a><span class="lineno"> 1824</span>&#160;                                                                                    4.0 * ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) *</div>
<div class="line"><a name="l01825"></a><span class="lineno"> 1825</span>&#160;                                                                                    ( pow ( y1, 2.0 ) * pow ( dot2, 2.0 ) + pow ( z1, 2.0 ) * pow ( dot2, 2.0 ) - 2.0 * y1 * dot1 * y2 * dot2 - 2.0 * z1 * dot1 * z2 * dot2 - pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( dot1, 2.0 ) * pow ( y2, 2.0 ) - pow ( y1, 2.0 ) * pow ( z2, 2.0 ) + pow ( dot1, 2.0 ) * pow ( z2, 2.0 ) + 2.0 * y1 * z1 * y2 * z2 ) ) ) /</div>
<div class="line"><a name="l01826"></a><span class="lineno"> 1826</span>&#160;                                                            ( 2.0 * ( y1 * z2 - z1 * y2 ) * ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) ) -</div>
<div class="line"><a name="l01827"></a><span class="lineno"> 1827</span>&#160;                                                            ( dot1 * y2 * z2 ) / ( y1 * z2 - z1 * y2 ) -</div>
<div class="line"><a name="l01828"></a><span class="lineno"> 1828</span>&#160;                                                            ( pow ( y1, 2.0 ) * dot2 * pow ( x2, 2.0 ) ) /</div>
<div class="line"><a name="l01829"></a><span class="lineno"> 1829</span>&#160;                                                            ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) -</div>
<div class="line"><a name="l01830"></a><span class="lineno"> 1830</span>&#160;                                                            ( x1 * dot1 * x2 * pow ( y2, 2.0 ) ) /</div>
<div class="line"><a name="l01831"></a><span class="lineno"> 1831</span>&#160;                                                            ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) -</div>
<div class="line"><a name="l01832"></a><span class="lineno"> 1832</span>&#160;                                                            ( x1 * dot1 * x2 * pow ( z2, 2.0 ) ) /</div>
<div class="line"><a name="l01833"></a><span class="lineno"> 1833</span>&#160;                                                            ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) +</div>
<div class="line"><a name="l01834"></a><span class="lineno"> 1834</span>&#160;                                                            ( y1 * dot1 * pow ( x2, 2.0 ) * y2 ) /</div>
<div class="line"><a name="l01835"></a><span class="lineno"> 1835</span>&#160;                                                            ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) +</div>
<div class="line"><a name="l01836"></a><span class="lineno"> 1836</span>&#160;                                                            ( x1 * y1 * dot2 * x2 * y2 ) /</div>
<div class="line"><a name="l01837"></a><span class="lineno"> 1837</span>&#160;                                                            ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) +</div>
<div class="line"><a name="l01838"></a><span class="lineno"> 1838</span>&#160;                                                            ( pow ( x1, 2.0 ) * dot1 * y2 * pow ( z2, 3.0 ) ) /</div>
<div class="line"><a name="l01839"></a><span class="lineno"> 1839</span>&#160;                                                            ( ( y1 * z2 - z1 * y2 ) * ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) ) +</div>
<div class="line"><a name="l01840"></a><span class="lineno"> 1840</span>&#160;                                                            ( pow ( x1, 2.0 ) * dot1 * pow ( y2, 3.0 ) * z2 ) /</div>
<div class="line"><a name="l01841"></a><span class="lineno"> 1841</span>&#160;                                                            ( ( y1 * z2 - z1 * y2 ) * ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) ) -</div>
<div class="line"><a name="l01842"></a><span class="lineno"> 1842</span>&#160;                                                            ( pow ( x1, 2.0 ) * y1 * dot2 * pow ( y2, 2.0 ) * z2 ) /</div>
<div class="line"><a name="l01843"></a><span class="lineno"> 1843</span>&#160;                                                            ( ( y1 * z2 - z1 * y2 ) * ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) ) -</div>
<div class="line"><a name="l01844"></a><span class="lineno"> 1844</span>&#160;                                                            ( x1 * y1 * dot1 * x2 * pow ( y2, 2.0 ) * z2 ) /</div>
<div class="line"><a name="l01845"></a><span class="lineno"> 1845</span>&#160;                                                            ( ( y1 * z2 - z1 * y2 ) * ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) ) +</div>
<div class="line"><a name="l01846"></a><span class="lineno"> 1846</span>&#160;                                                            ( x1 * pow ( y1, 2.0 ) * dot2 * x2 * y2 * z2 ) /</div>
<div class="line"><a name="l01847"></a><span class="lineno"> 1847</span>&#160;                                                            ( ( y1 * z2 - z1 * y2 ) * ( pow ( y1, 2.0 ) * pow ( x2, 2.0 ) + pow ( z1, 2.0 ) * pow ( x2, 2.0 ) - 2.0 * x1 * y1 * y2 * x2 - 2.0 * x1 * z1 * z2 * x2 + pow ( x1, 2.0 ) * pow ( y2, 2.0 ) + pow ( z1, 2.0 ) * pow ( y2, 2.0 ) + pow ( x1, 2.0 ) * pow ( z2, 2.0 ) + pow ( y1, 2.0 ) * pow ( z2, 2.0 ) - 2.0 * y1 * z1 * y2 * z2 ) ) ) / z2;</div>
<div class="line"><a name="l01848"></a><span class="lineno"> 1848</span>&#160; </div>
<div class="line"><a name="l01849"></a><span class="lineno"> 1849</span>&#160;    <span class="comment">//================================================ Set largest axis element to positive (ProSHADE standard)</span></div>
<div class="line"><a name="l01850"></a><span class="lineno"> 1850</span>&#160;    <span class="keywordflow">if</span> ( ( ( std::max ( std::abs ( solX ), std::max( std::abs ( solY ), std::abs ( solZ ) ) ) == std::abs ( solX ) ) &amp;&amp; ( solX &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l01851"></a><span class="lineno"> 1851</span>&#160;         ( ( std::max ( std::abs ( solX ), std::max( std::abs ( solY ), std::abs ( solZ ) ) ) == std::abs ( solY ) ) &amp;&amp; ( solY &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l01852"></a><span class="lineno"> 1852</span>&#160;         ( ( std::max ( std::abs ( solX ), std::max( std::abs ( solY ), std::abs ( solZ ) ) ) == std::abs ( solZ ) ) &amp;&amp; ( solZ &lt; 0.0 ) ) ) { solX *= -1.0; solY *= -1.0; solZ *= -1.0; }</div>
<div class="line"><a name="l01853"></a><span class="lineno"> 1853</span>&#160;    </div>
<div class="line"><a name="l01854"></a><span class="lineno"> 1854</span>&#160;    <span class="comment">//================================================ Save solutions</span></div>
<div class="line"><a name="l01855"></a><span class="lineno"> 1855</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a>         ( &amp;ret, solX  );</div>
<div class="line"><a name="l01856"></a><span class="lineno"> 1856</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a>         ( &amp;ret, solY  );</div>
<div class="line"><a name="l01857"></a><span class="lineno"> 1857</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a>         ( &amp;ret, solZ  );</div>
<div class="line"><a name="l01858"></a><span class="lineno"> 1858</span>&#160;    </div>
<div class="line"><a name="l01859"></a><span class="lineno"> 1859</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01860"></a><span class="lineno"> 1860</span>&#160;    <span class="keywordflow">return</span>                                            ( ret );</div>
<div class="line"><a name="l01861"></a><span class="lineno"> 1861</span>&#160;    </div>
<div class="line"><a name="l01862"></a><span class="lineno"> 1862</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3d4604176a61820f5fcb95e372861c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4604176a61820f5fcb95e372861c1d">&#9670;&nbsp;</a></span>gaussLegendreIntegration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::gaussLegendreIntegration </td>
          <td>(</td>
          <td class="paramtype">proshade_complex *&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>valsSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>abscissas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>integralOverRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>maxSphereDists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>retReal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>retImag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute the complete complex Gauss-Legendre integration over spherical harmonic values in different shells. </p>
<p>This function takes the real parts of the spherical harmonics value in different shells and proceeds to compute the Gauss-Legendre integration over them. It uses the shell positions to appropriately place abscissas and their weights, which it assumes were pre-computed by the <a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a6e2f7de1bba288270ce2cc772d28d065" title="Function to prepare abscissas and weights for Gauss-Legendre integration.">getLegendreAbscAndWeights()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vals</td><td>Pointer to a complex array of values over which the integration to be done. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valsSize</td><td>The length of the input array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>The integration order value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">abscissas</td><td>The allocated array for holding the abscissa values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>The allocated array for holding the weight values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">integralOverRange</td><td>The range of the intgral. If progressive shell mapping is used, this will not be max shell radius. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxSphereDists</td><td>Distance between two shells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">retReal</td><td>The real part of the complex result of Gauss-Legendre integration over the shperical harmonics values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">retImag</td><td>The imaginary part of the complex result of Gauss-Legendre integration over the shperical harmonics values. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00709">709</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;{</div>
<div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;    <span class="comment">//================================================ Initialise local variables</span></div>
<div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;    proshade_triplet* intData                         = <span class="keyword">new</span> proshade_triplet [order];</div>
<div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a> ( intData, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;    proshade_triplet posVals;</div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;    proshade_unsign lesserPos                         = 0;</div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;    proshade_unsign upperPos                          = 0;</div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;    proshade_double lesserWeight                      = 0.0;</div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;    proshade_double upperWeight                       = 0.0;</div>
<div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;    </div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;    <span class="comment">//================================================ Rescale to &lt;order&gt; points</span></div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign absIter = 0; absIter &lt; order; absIter++ )</div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;    {</div>
<div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;        <span class="comment">//============================================ Init loop</span></div>
<div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;        posVals[0]                                    = 0.0;</div>
<div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;        posVals[1]                                    = 0.0;</div>
<div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;        posVals[2]                                    = 0.0;</div>
<div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;        </div>
<div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;        <span class="comment">//============================================ Find real position of abscissas</span></div>
<div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;        posVals[0]                                    = ( ( abscissas[absIter] + 1.0 ) / 2.0 ) * integralOverRange;</div>
<div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;        </div>
<div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;        </div>
<div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;        <span class="comment">//============================================ Find lesser and upper bounds</span></div>
<div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign valIt = 0; valIt &lt; valsSize; valIt++ )</div>
<div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;        {</div>
<div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;            <span class="keywordflow">if</span> ( ( ( valIt * maxSphereDists ) &lt;=  posVals[0] ) &amp;&amp; ( ( ( valIt + 1 ) * maxSphereDists ) &gt; posVals[0] ) )</div>
<div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;            {</div>
<div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;                lesserPos                             = <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( valIt );</div>
<div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;                upperPos                              = <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( valIt + 1 );</div>
<div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;                <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;            }</div>
<div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;        }</div>
<div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;        </div>
<div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;        <span class="comment">//============================================ Linear Interpolation</span></div>
<div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;        lesserWeight                                  = 0.0;</div>
<div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;        upperWeight                                   = 0.0;</div>
<div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;        <span class="keywordflow">if</span> ( lesserPos != 0 )</div>
<div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;        {</div>
<div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;            <span class="comment">//======================================== Here we realise that the lesser and upper bounds were determined on scale 1 ... N, while our values are on scale 0 ... N-1 and therefore after determining the linear interpolation weights, we subtract 1 from both lesserPos and upperPos; however ...</span></div>
<div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;            lesserWeight                              = upperPos - ( posVals[0] / maxSphereDists );</div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;            upperWeight                               = 1.0 - lesserWeight;</div>
<div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;                    </div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;            posVals[1]                                = ( lesserWeight * vals[lesserPos-1][0] ) + ( upperWeight * vals[upperPos-1][0] );</div>
<div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;            posVals[2]                                = ( lesserWeight * vals[lesserPos-1][1] ) + ( upperWeight * vals[upperPos-1][1] );</div>
<div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;        }</div>
<div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;        {</div>
<div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;            <span class="comment">//======================================== ... this then means that we would require position -1 for when the integration value is between 0 and the first shell. To resolve this, we assume that the values are 0 below the first shell and proceed as follows:</span></div>
<div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;            upperWeight                               = 1.0 - ( upperPos - ( posVals[0] / maxSphereDists ) );</div>
<div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;                    </div>
<div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;            posVals[1]                                = ( upperWeight * vals[upperPos-1][0] );</div>
<div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;            posVals[2]                                = ( upperWeight * vals[upperPos-1][1] );</div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;        }</div>
<div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;                </div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;        intData[absIter][0]                           = posVals[0];</div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;        intData[absIter][1]                           = posVals[1];</div>
<div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;        intData[absIter][2]                           = posVals[2];</div>
<div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;    }</div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;    </div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;    <span class="comment">//================================================ Integrate</span></div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;   *retReal                                           = 0.0;</div>
<div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;   *retImag                                           = 0.0;</div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign absPoint = 0; absPoint &lt; order; absPoint++ )</div>
<div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;    {</div>
<div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;       *retReal                                      += ( weights[absPoint] * intData[absPoint][1] );</div>
<div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;       *retImag                                      += ( weights[absPoint] * intData[absPoint][2] );</div>
<div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;    }</div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;    </div>
<div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;    <span class="comment">//================================================ Normalise</span></div>
<div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;   *retReal                                          *= ( integralOverRange / 2.0 );</div>
<div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;   *retImag                                          *= ( integralOverRange / 2.0 );</div>
<div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;    </div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;    <span class="comment">//================================================ Release memory</span></div>
<div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;    <span class="keyword">delete</span>[] intData;</div>
<div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;    </div>
<div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;    return ;</div>
<div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;    </div>
<div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a62133f51851217e3cb28dff2f520d192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62133f51851217e3cb28dff2f520d192">&#9670;&nbsp;</a></span>gaussLegendreIntegrationReal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">proshade_double ProSHADE_internal_maths::gaussLegendreIntegrationReal </td>
          <td>(</td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>valsSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>abscissas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>integralOverRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>maxSphereDists</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute real part of the Gauss-Legendre integration over spherical harmonic values in different shells. </p>
<p>This function takes the real parts of the spherical harmonics value in different shells and proceeds to compute the Gauss-Legendre integration over them. It uses the shell positions to appropriately place abscissas and their weights, which it assumes were pre-computed by the <a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a6e2f7de1bba288270ce2cc772d28d065" title="Function to prepare abscissas and weights for Gauss-Legendre integration.">getLegendreAbscAndWeights()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vals</td><td>Pointer to an array of values over which the integration to be done. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valsSize</td><td>The length of the input array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>The integration order value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">abscissas</td><td>The allocated array for holding the abscissa values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>The allocated array for holding the weight values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">integralOverRange</td><td>The range of the intgral. If progressive shell mapping is used, this will not be max shell radius. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxSphereDists</td><td>Distance between two shells. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>The real part of Gauss-Legendre integration over the shperical harmonics values. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00619">619</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;{</div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;    <span class="comment">//================================================ Initialise local variables</span></div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;    proshade_double ret                               = 0.0;</div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;    proshade_complex* intData                         = <span class="keyword">new</span> proshade_complex[order];</div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a> ( intData, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;    proshade_complex posVals;</div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;    proshade_unsign lesserPos                         = 0;</div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;    proshade_unsign upperPos                          = 0;</div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;    proshade_double lesserWeight                      = 0.0;</div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;    proshade_double upperWeight                       = 0.0;</div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;    </div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;    <span class="comment">//================================================ Rescale to &lt;order&gt; points</span></div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign absIter = 0; absIter &lt; order; absIter++ )</div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;    {</div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;        <span class="comment">//============================================ Init loop</span></div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;        posVals[0]                                    = 0.0;</div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;        posVals[1]                                    = 0.0;</div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;        </div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;        <span class="comment">//============================================ Find real position of abscissas</span></div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;        posVals[0]                                    = ( ( abscissas[absIter] + 1.0 ) / 2.0 ) * integralOverRange;</div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;        </div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160; </div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;        <span class="comment">//============================================ Find lesser and upper bounds</span></div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign valIt = 0; valIt &lt; valsSize; valIt++ )</div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;        {</div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;            <span class="keywordflow">if</span> ( ( ( valIt * maxSphereDists ) &lt;=  posVals[0] ) &amp;&amp; ( ( ( valIt + 1 ) * maxSphereDists ) &gt; posVals[0] ) )</div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;            {</div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;                lesserPos                             = <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( valIt );</div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;                upperPos                              = <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( valIt + 1 );</div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;                <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;            }</div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;        }</div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;        </div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;        <span class="comment">//============================================ Linear Interpolation</span></div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;        lesserWeight                                  = 0.0;</div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;        upperWeight                                   = 0.0;</div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;        <span class="keywordflow">if</span> ( lesserPos != 0 )</div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;        {</div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;            <span class="comment">//======================================== Here we realise that the lesser and upper bounds were determined on scale 1 ... N, while our values are on scale 0 ... N-1 and therefore after determining the linear interpolation weights, we subtract 1 from both lesserPos and upperPos; however ...</span></div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;            lesserWeight                              = upperPos - ( posVals[0] / maxSphereDists );</div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;            upperWeight                               = 1.0 - lesserWeight;</div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;                    </div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;            posVals[1]                                = ( lesserWeight * vals[lesserPos-1] ) + ( upperWeight * vals[upperPos-1] );</div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;        }</div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;        {</div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;            <span class="comment">//======================================== ... this then means that we would require position -1 for when the integration value is between 0 and the first shell. To resolve this, we assume that the values are 0 below the first shell and proceed as follows:</span></div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;            upperWeight                               = 1.0 - ( upperPos - ( posVals[0] / maxSphereDists ) );</div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;                    </div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;            posVals[1]                                = ( upperWeight * vals[upperPos-1] );</div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;        }</div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;                </div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;        intData[absIter][0]                           = posVals[0];</div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;        intData[absIter][1]                           = posVals[1];</div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;    }</div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160; </div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;    <span class="comment">//================================================ Integrate</span></div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign absPoint = 0; absPoint &lt; order; absPoint++ )</div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;    {</div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;        ret                                          += ( weights[absPoint] * intData[absPoint][1] );</div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;    }</div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;    </div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;    <span class="comment">//================================================ Normalise</span></div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;    ret                                              *= ( integralOverRange / 2.0 );</div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;    </div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;    <span class="comment">//================================================ Release memory</span></div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;    <span class="keyword">delete</span>[] intData;</div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;    </div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;    <span class="keywordflow">return</span>                                            ( ret );</div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;    </div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aafc6f1626c7463de53c9f4f6fa11db22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc6f1626c7463de53c9f4f6fa11db22">&#9670;&nbsp;</a></span>getAxisAngleFromRotationMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::getAxisAngleFromRotationMatrix </td>
          <td>(</td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>rotMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>ang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts rotation matrix to the axis-angle representation. </p>
<p>This function takes a rotation matrix as an array of 9 numbers and converts it to the Angle-Axis representation, which is the main rotation representation used in ProSHADE. This function deals with both the North and South pole singularity of the rotation matrices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rotMat</td><td>Rotation matrix as an array of 9 values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Pointer to which the x-axis value of the axis vector will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Pointer to which the y-axis value of the axis vector will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>Pointer to which the z-axis value of the axis vector will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ang</td><td>Pointer to which the angle value will be saved. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01039">1039</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;{</div>
<div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;    <span class="comment">//================================================ Initialise</span></div>
<div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;    proshade_double singAtPiCheck                     = 0.01;</div>
<div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;    proshade_double singAtIdentity                    = 0.05;</div>
<div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;    </div>
<div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;    <span class="comment">//================================================ Check input for singularities</span></div>
<div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;    <span class="keywordflow">if</span> ( ( std::abs ( rotMat[1] - rotMat[3] ) &lt; singAtPiCheck ) &amp;&amp;</div>
<div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;         ( std::abs ( rotMat[2] - rotMat[6] ) &lt; singAtPiCheck ) &amp;&amp;</div>
<div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;         ( std::abs ( rotMat[5] - rotMat[7] ) &lt; singAtPiCheck ) )</div>
<div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;    {</div>
<div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;        <span class="comment">//============================================ Singularity in input! Check for identity matrix</span></div>
<div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;        <span class="keywordflow">if</span> ( ( std::abs ( rotMat[1] + rotMat[3] ) &lt; singAtIdentity ) &amp;&amp;</div>
<div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;             ( std::abs ( rotMat[2] + rotMat[6] ) &lt; singAtIdentity ) &amp;&amp;</div>
<div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;             ( std::abs ( rotMat[5] + rotMat[7] ) &lt; singAtIdentity ) &amp;&amp;</div>
<div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;             ( std::abs ( rotMat[0] + rotMat[4] + rotMat[8] - 3.0 ) &lt; singAtIdentity ) )</div>
<div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;        {</div>
<div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;            <span class="comment">//======================================== Identity matrix. Return 0 angle.</span></div>
<div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;           *x                                         = 1.0;</div>
<div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;           *y                                         = 0.0;</div>
<div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;           *z                                         = 0.0;</div>
<div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;           *ang                                       = 0.0;</div>
<div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;            </div>
<div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;            <span class="comment">//======================================== Done</span></div>
<div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;            return ;</div>
<div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;        }</div>
<div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;        </div>
<div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;        <span class="comment">//============================================ If we got here, this is the 180deg (pi rad) singularity. Find which axis should the rotation be done along</span></div>
<div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;       *ang                                           = M_PI;</div>
<div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;                </div>
<div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;        proshade_double xx                            = ( rotMat[0] + 1.0 ) / 2.0;</div>
<div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;        proshade_double yy                            = ( rotMat[4] + 1.0 ) / 2.0;</div>
<div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;        proshade_double zz                            = ( rotMat[8] + 1.0 ) / 2.0;</div>
<div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;        proshade_double xy                            = ( rotMat[1] + rotMat[3] ) / 4.0;</div>
<div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;        proshade_double xz                            = ( rotMat[2] + rotMat[6] ) / 4.0;</div>
<div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;        proshade_double yz                            = ( rotMat[5] + rotMat[7] ) / 4.0;</div>
<div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;        </div>
<div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;        <span class="keywordflow">if</span> ( ( xx &gt; yy ) &amp;&amp; ( xx &gt; zz ) ) <span class="comment">// XX is the largest diagonal</span></div>
<div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;        {</div>
<div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;            <span class="keywordflow">if</span> ( xx &lt; singAtPiCheck ) <span class="comment">// and is still 0</span></div>
<div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;            {</div>
<div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;               *x                                     = 0.0;</div>
<div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;               *y                                     = 1.0 / sqrt(2);</div>
<div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;               *z                                     = 1.0 / sqrt(2);</div>
<div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;            }</div>
<div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;            {</div>
<div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;               *x                                     =  sqrt ( xx );</div>
<div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;               *y                                     =  xy / sqrt ( xx );</div>
<div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;               *z                                     =  xz / sqrt ( xx );</div>
<div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;            }</div>
<div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;        }</div>
<div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;        </div>
<div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( yy &gt; zz ) <span class="comment">// YY is the largest diagonal</span></div>
<div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;        {</div>
<div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;            <span class="keywordflow">if</span> ( yy &lt; singAtPiCheck ) <span class="comment">// and is still 0</span></div>
<div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;            {</div>
<div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;               *x                                     =  1.0 / sqrt(2);</div>
<div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;               *y                                     =  0.0;</div>
<div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;               *z                                     =  1.0 / sqrt(2);</div>
<div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;            }</div>
<div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;            {</div>
<div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;               *y                                     =  sqrt ( yy );</div>
<div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;               *x                                     =  xy / sqrt ( yy );</div>
<div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;               *z                                     =  yz / sqrt ( yy );</div>
<div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;            }</div>
<div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;        }</div>
<div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;        </div>
<div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;        <span class="keywordflow">else</span> <span class="comment">// ZZ is the largest diagonal</span></div>
<div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;        {</div>
<div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;            <span class="keywordflow">if</span> ( zz &lt; singAtPiCheck ) <span class="comment">// and is still 0</span></div>
<div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;            {</div>
<div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;               *x                                     = 1.0 / sqrt(2);</div>
<div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;               *y                                     = 1.0 / sqrt(2);</div>
<div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;               *z                                     = 0.0;</div>
<div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;            }</div>
<div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;            {</div>
<div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;               *z                                     = sqrt ( zz );</div>
<div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;               *x                                     = xz / sqrt ( zz );</div>
<div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;               *y                                     = yz / sqrt ( zz );</div>
<div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;            }</div>
<div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;        }</div>
<div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;        </div>
<div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;        <span class="comment">//============================================ Make sure largest axis is positive and so is the angle</span></div>
<div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;        <span class="keywordflow">if</span> ( ( ( std::max ( std::abs ( *x ), std::max ( std::abs ( *y ), std::abs ( *z ) ) ) == std::abs ( *x ) ) &amp;&amp; ( *x &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;             ( ( std::max ( std::abs ( *x ), std::max ( std::abs ( *y ), std::abs ( *z ) ) ) == std::abs ( *y ) ) &amp;&amp; ( *y &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;             ( ( std::max ( std::abs ( *x ), std::max ( std::abs ( *y ), std::abs ( *z ) ) ) == std::abs ( *z ) ) &amp;&amp; ( *z &lt; 0.0 ) ) )</div>
<div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;        {</div>
<div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;            *x                                       *= -1.0;</div>
<div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;            *y                                       *= -1.0;</div>
<div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;            *z                                       *= -1.0;</div>
<div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;            *ang                                     *= -1.0;</div>
<div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;        }</div>
<div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;        <span class="keywordflow">if</span> ( *ang &lt; 0.0 ) { *ang = ( 2.0 * M_PI ) + *ang; }</div>
<div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;        </div>
<div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;        <span class="comment">//============================================ Done</span></div>
<div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;        return ;</div>
<div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;    }</div>
<div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;    </div>
<div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;    <span class="comment">//================================================ No singularities! Now get angle</span></div>
<div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;   *ang                                               = std::acos ( ( std::max ( -1.0, std::min ( 3.0, rotMat[0] + rotMat[4] + rotMat[8] ) ) - 1.0 ) / 2.0 );</div>
<div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;    </div>
<div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;    <span class="comment">//================================================ Init return values</span></div>
<div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;   *x                                                 = 1.0;</div>
<div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;   *y                                                 = 0.0;</div>
<div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;   *z                                                 = 0.0;</div>
<div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;    </div>
<div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;    <span class="comment">//================================================ Is angle 0? This should not happen, but will</span></div>
<div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;    <span class="keywordflow">if</span> ( std::abs ( *ang ) &lt; singAtPiCheck )</div>
<div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;    {</div>
<div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;       *ang                                           = 0.0;</div>
<div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;        return ;</div>
<div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;    }</div>
<div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;    </div>
<div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;    <span class="comment">//================================================ Axis</span></div>
<div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;   *x                                                 = rotMat[7] - rotMat[5];</div>
<div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;   *y                                                 = rotMat[2] - rotMat[6];</div>
<div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;   *z                                                 = rotMat[3] - rotMat[1];</div>
<div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;    </div>
<div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;    proshade_double normFactor                        = std::sqrt ( pow ( *x, 2.0 ) + pow ( *y, 2.0 ) + pow ( *z, 2.0 ) );</div>
<div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;   *x                                                /= normFactor;</div>
<div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;   *y                                                /= normFactor;</div>
<div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;   *z                                                /= normFactor;</div>
<div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;    </div>
<div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;    <span class="comment">//================================================ Make sure largest axis is positive and so is the angle</span></div>
<div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;    <span class="keywordflow">if</span> ( ( ( std::max ( std::abs ( *x ), std::max ( std::abs ( *y ), std::abs ( *z ) ) ) == std::abs ( *x ) ) &amp;&amp; ( *x &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;         ( ( std::max ( std::abs ( *x ), std::max ( std::abs ( *y ), std::abs ( *z ) ) ) == std::abs ( *y ) ) &amp;&amp; ( *y &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;         ( ( std::max ( std::abs ( *x ), std::max ( std::abs ( *y ), std::abs ( *z ) ) ) == std::abs ( *z ) ) &amp;&amp; ( *z &lt; 0.0 ) ) )</div>
<div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;    {</div>
<div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;        *x                                           *= -1.0;</div>
<div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;        *y                                           *= -1.0;</div>
<div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;        *z                                           *= -1.0;</div>
<div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;        *ang                                         *= -1.0;</div>
<div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;    }</div>
<div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;    <span class="keywordflow">if</span> ( *ang &lt; 0.0 ) { *ang = ( 2.0 * M_PI ) + *ang; }</div>
<div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;    </div>
<div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;    return ;</div>
<div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;    </div>
<div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4a379ad8635541b0c7f7f6349822b2a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a379ad8635541b0c7f7f6349822b2a4">&#9670;&nbsp;</a></span>getAxisAngleFromRotationMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::getAxisAngleFromRotationMatrix </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double &gt; *&#160;</td>
          <td class="paramname"><em>rotMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>ang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts rotation matrix to the axis-angle representation. </p>
<p>This function takes a rotation matrix as a pointer to a vector of doubles and converts it to the Angle-Axis representation, which is the main rotation representation used in ProSHADE. This function deals with both the North and South pole singularity of the rotation matrices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rotMat</td><td>Rotation matrix as a pointer to a vector of doubles. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Pointer to which the x-axis value of the axis vector will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Pointer to which the y-axis value of the axis vector will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>Pointer to which the z-axis value of the axis vector will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ang</td><td>Pointer to which the angle value will be saved. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01194">1194</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;{</div>
<div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;    <span class="comment">//================================================ Initialise</span></div>
<div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;    proshade_double singAtPiCheck                     = 0.01;</div>
<div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;    proshade_double singAtIdentity                    = 0.05;</div>
<div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;    </div>
<div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;    <span class="comment">//================================================ Check input for singularities</span></div>
<div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;    <span class="keywordflow">if</span> ( ( std::abs ( rotMat-&gt;at(1) - rotMat-&gt;at(3) ) &lt; singAtPiCheck ) &amp;&amp;</div>
<div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;         ( std::abs ( rotMat-&gt;at(2) - rotMat-&gt;at(6) ) &lt; singAtPiCheck ) &amp;&amp;</div>
<div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;         ( std::abs ( rotMat-&gt;at(5) - rotMat-&gt;at(7) ) &lt; singAtPiCheck ) )</div>
<div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;    {</div>
<div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;        <span class="comment">//============================================ Singularity in input! Check for identity matrix</span></div>
<div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;        <span class="keywordflow">if</span> ( ( std::abs ( rotMat-&gt;at(1) + rotMat-&gt;at(3) ) &lt; singAtIdentity ) &amp;&amp;</div>
<div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;             ( std::abs ( rotMat-&gt;at(2) + rotMat-&gt;at(6) ) &lt; singAtIdentity ) &amp;&amp;</div>
<div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;             ( std::abs ( rotMat-&gt;at(5) + rotMat-&gt;at(7) ) &lt; singAtIdentity ) &amp;&amp;</div>
<div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;             ( std::abs ( rotMat-&gt;at(0) + rotMat-&gt;at(4) + rotMat-&gt;at(8) - 3.0 ) &lt; singAtIdentity ) )</div>
<div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;        {</div>
<div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;            <span class="comment">//======================================== Identity matrix. Return 0 angle.</span></div>
<div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;           *x                                         = 1.0;</div>
<div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;           *y                                         = 0.0;</div>
<div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;           *z                                         = 0.0;</div>
<div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;           *ang                                       = 0.0;</div>
<div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;            </div>
<div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160;            <span class="comment">//======================================== Done</span></div>
<div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160;            return ;</div>
<div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;        }</div>
<div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;        </div>
<div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;        <span class="comment">//============================================ If we got here, this is the 180deg (pi rad) singularity. Find which axis should the rotation be done along</span></div>
<div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;       *ang                                           = M_PI;</div>
<div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;                </div>
<div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;        proshade_double xx                            = ( rotMat-&gt;at(0) + 1.0 ) / 2.0;</div>
<div class="line"><a name="l01225"></a><span class="lineno"> 1225</span>&#160;        proshade_double yy                            = ( rotMat-&gt;at(4) + 1.0 ) / 2.0;</div>
<div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;        proshade_double zz                            = ( rotMat-&gt;at(8) + 1.0 ) / 2.0;</div>
<div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;        proshade_double xy                            = ( rotMat-&gt;at(1) + rotMat-&gt;at(3) ) / 4.0;</div>
<div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;        proshade_double xz                            = ( rotMat-&gt;at(2) + rotMat-&gt;at(6) ) / 4.0;</div>
<div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;        proshade_double yz                            = ( rotMat-&gt;at(5) + rotMat-&gt;at(7) ) / 4.0;</div>
<div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;        </div>
<div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;        <span class="keywordflow">if</span> ( ( xx &gt; yy ) &amp;&amp; ( xx &gt; zz ) ) <span class="comment">// XX is the largest diagonal</span></div>
<div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;        {</div>
<div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;            <span class="keywordflow">if</span> ( xx &lt; singAtPiCheck ) <span class="comment">// and is still 0</span></div>
<div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160;            {</div>
<div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;               *x                                     = 0.0;</div>
<div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160;               *y                                     = 1.0 / sqrt(2);</div>
<div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160;               *z                                     = 1.0 / sqrt(2);</div>
<div class="line"><a name="l01238"></a><span class="lineno"> 1238</span>&#160;            }</div>
<div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160;            {</div>
<div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160;               *x                                     =  sqrt ( xx );</div>
<div class="line"><a name="l01242"></a><span class="lineno"> 1242</span>&#160;               *y                                     =  xy / sqrt ( xx );</div>
<div class="line"><a name="l01243"></a><span class="lineno"> 1243</span>&#160;               *z                                     =  xz / sqrt ( xx );</div>
<div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;            }</div>
<div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;        }</div>
<div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;        </div>
<div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( yy &gt; zz ) <span class="comment">// YY is the largest diagonal</span></div>
<div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;        {</div>
<div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;            <span class="keywordflow">if</span> ( yy &lt; singAtPiCheck ) <span class="comment">// and is still 0</span></div>
<div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;            {</div>
<div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;               *x                                     =  1.0 / sqrt(2);</div>
<div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;               *y                                     =  0.0;</div>
<div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;               *z                                     =  1.0 / sqrt(2);</div>
<div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;            }</div>
<div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160;            {</div>
<div class="line"><a name="l01257"></a><span class="lineno"> 1257</span>&#160;               *y                                     =  sqrt ( yy );</div>
<div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160;               *x                                     =  xy / sqrt ( yy );</div>
<div class="line"><a name="l01259"></a><span class="lineno"> 1259</span>&#160;               *z                                     =  yz / sqrt ( yy );</div>
<div class="line"><a name="l01260"></a><span class="lineno"> 1260</span>&#160;            }</div>
<div class="line"><a name="l01261"></a><span class="lineno"> 1261</span>&#160;        }</div>
<div class="line"><a name="l01262"></a><span class="lineno"> 1262</span>&#160;        </div>
<div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;        <span class="keywordflow">else</span> <span class="comment">// ZZ is the largest diagonal</span></div>
<div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;        {</div>
<div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;            <span class="keywordflow">if</span> ( zz &lt; singAtPiCheck ) <span class="comment">// and is still 0</span></div>
<div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;            {</div>
<div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;               *x                                     = 1.0 / sqrt(2);</div>
<div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;               *y                                     = 1.0 / sqrt(2);</div>
<div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;               *z                                     = 0.0;</div>
<div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;            }</div>
<div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l01272"></a><span class="lineno"> 1272</span>&#160;            {</div>
<div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160;               *z                                     = sqrt ( zz );</div>
<div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160;               *x                                     = xz / sqrt ( zz );</div>
<div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;               *y                                     = yz / sqrt ( zz );</div>
<div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;            }</div>
<div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160;        }</div>
<div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;        </div>
<div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;        <span class="comment">//============================================ Make sure largest axis is positive and so is the angle</span></div>
<div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;        <span class="keywordflow">if</span> ( ( ( std::max ( std::abs ( *x ), std::max ( std::abs ( *y ), std::abs ( *z ) ) ) == std::abs ( *x ) ) &amp;&amp; ( *x &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160;             ( ( std::max ( std::abs ( *x ), std::max ( std::abs ( *y ), std::abs ( *z ) ) ) == std::abs ( *y ) ) &amp;&amp; ( *y &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l01282"></a><span class="lineno"> 1282</span>&#160;             ( ( std::max ( std::abs ( *x ), std::max ( std::abs ( *y ), std::abs ( *z ) ) ) == std::abs ( *z ) ) &amp;&amp; ( *z &lt; 0.0 ) ) )</div>
<div class="line"><a name="l01283"></a><span class="lineno"> 1283</span>&#160;        {</div>
<div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;            *x                                       *= -1.0;</div>
<div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;            *y                                       *= -1.0;</div>
<div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;            *z                                       *= -1.0;</div>
<div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;            *ang                                     *= -1.0;</div>
<div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;        }</div>
<div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;        </div>
<div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;        <span class="comment">//============================================ Done</span></div>
<div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;        return ;</div>
<div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;    }</div>
<div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160;    </div>
<div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;    <span class="comment">//================================================ No singularities! Now get angle</span></div>
<div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160;   *ang                                               = std::acos ( ( std::max ( -1.0, std::min ( 3.0, rotMat-&gt;at(0) + rotMat-&gt;at(4) + rotMat-&gt;at(8) ) ) - 1.0 ) / 2.0 );</div>
<div class="line"><a name="l01296"></a><span class="lineno"> 1296</span>&#160;    </div>
<div class="line"><a name="l01297"></a><span class="lineno"> 1297</span>&#160;    <span class="comment">//================================================ Init return values</span></div>
<div class="line"><a name="l01298"></a><span class="lineno"> 1298</span>&#160;   *x                                                 = 1.0;</div>
<div class="line"><a name="l01299"></a><span class="lineno"> 1299</span>&#160;   *y                                                 = 0.0;</div>
<div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;   *z                                                 = 0.0;</div>
<div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;    </div>
<div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;    <span class="comment">//================================================ Is angle 0? This should not happen, but will</span></div>
<div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;    <span class="keywordflow">if</span> ( std::abs ( *ang ) &lt; singAtPiCheck )</div>
<div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160;    {</div>
<div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160;       *ang                                           = 0.0;</div>
<div class="line"><a name="l01306"></a><span class="lineno"> 1306</span>&#160;        return ;</div>
<div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;    }</div>
<div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;    </div>
<div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;    <span class="comment">//================================================ Axis</span></div>
<div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;   *x                                                 = rotMat-&gt;at(7) - rotMat-&gt;at(5);</div>
<div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;   *y                                                 = rotMat-&gt;at(2) - rotMat-&gt;at(6);</div>
<div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;   *z                                                 = rotMat-&gt;at(3) - rotMat-&gt;at(1);</div>
<div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;    </div>
<div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160;    proshade_double normFactor                        = std::sqrt ( pow ( *x, 2.0 ) + pow ( *y, 2.0 ) + pow ( *z, 2.0 ) );</div>
<div class="line"><a name="l01315"></a><span class="lineno"> 1315</span>&#160;   *x                                                /= normFactor;</div>
<div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160;   *y                                                /= normFactor;</div>
<div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160;   *z                                                /= normFactor;</div>
<div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;    </div>
<div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160;    <span class="comment">//================================================ Make sure largest axis is positive and so is the angle</span></div>
<div class="line"><a name="l01320"></a><span class="lineno"> 1320</span>&#160;    <span class="keywordflow">if</span> ( ( ( std::max ( std::abs ( *x ), std::max ( std::abs ( *y ), std::abs ( *z ) ) ) == std::abs ( *x ) ) &amp;&amp; ( *x &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160;         ( ( std::max ( std::abs ( *x ), std::max ( std::abs ( *y ), std::abs ( *z ) ) ) == std::abs ( *y ) ) &amp;&amp; ( *y &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l01322"></a><span class="lineno"> 1322</span>&#160;         ( ( std::max ( std::abs ( *x ), std::max ( std::abs ( *y ), std::abs ( *z ) ) ) == std::abs ( *z ) ) &amp;&amp; ( *z &lt; 0.0 ) ) )</div>
<div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160;    {</div>
<div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160;        *x                                           *= -1.0;</div>
<div class="line"><a name="l01325"></a><span class="lineno"> 1325</span>&#160;        *y                                           *= -1.0;</div>
<div class="line"><a name="l01326"></a><span class="lineno"> 1326</span>&#160;        *z                                           *= -1.0;</div>
<div class="line"><a name="l01327"></a><span class="lineno"> 1327</span>&#160;        *ang                                         *= -1.0;</div>
<div class="line"><a name="l01328"></a><span class="lineno"> 1328</span>&#160;    }</div>
<div class="line"><a name="l01329"></a><span class="lineno"> 1329</span>&#160;    </div>
<div class="line"><a name="l01330"></a><span class="lineno"> 1330</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01331"></a><span class="lineno"> 1331</span>&#160;    return ;</div>
<div class="line"><a name="l01332"></a><span class="lineno"> 1332</span>&#160;    </div>
<div class="line"><a name="l01333"></a><span class="lineno"> 1333</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5750d6f0bf8e4a4b1d26552e8719dfd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5750d6f0bf8e4a4b1d26552e8719dfd4">&#9670;&nbsp;</a></span>getEulerZXZFromAngleAxis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::getEulerZXZFromAngleAxis </td>
          <td>(</td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axAng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>eA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>eB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>eG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>angDim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts angle-axis representation to the Euler ZXZ angles representation. </p>
<p>This function does the angle-axis to Euler ZXZ conversion and if a problem around the Z axis arises, it deal with it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">axX</td><td>Angle-axis representation axis x element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axY</td><td>Angle-axis representation axis y element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axZ</td><td>Angle-axis representation axis z element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axAng</td><td>Angle-axis representation angle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eA</td><td>Pointer to which the Euler angle alpha value will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eB</td><td>Pointer to which the Euler angle beta value will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eG</td><td>Pointer to which the Euler angle gamma value will be saved. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01437">1437</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01438"></a><span class="lineno"> 1438</span>&#160;{</div>
<div class="line"><a name="l01439"></a><span class="lineno"> 1439</span>&#160;    <span class="comment">//================================================ If angle is 0 or infinity (anything divided by 0), return no rotation</span></div>
<div class="line"><a name="l01440"></a><span class="lineno"> 1440</span>&#160;    <span class="keywordflow">if</span> ( ( axAng == 0.0 ) || ( std::isinf ( axAng ) ) )</div>
<div class="line"><a name="l01441"></a><span class="lineno"> 1441</span>&#160;    {</div>
<div class="line"><a name="l01442"></a><span class="lineno"> 1442</span>&#160;        <span class="comment">//============================================ Return 0 ; 0 ; 0 for no angle</span></div>
<div class="line"><a name="l01443"></a><span class="lineno"> 1443</span>&#160;       *eA                                            = 0.0;</div>
<div class="line"><a name="l01444"></a><span class="lineno"> 1444</span>&#160;       *eB                                            = 0.0;</div>
<div class="line"><a name="l01445"></a><span class="lineno"> 1445</span>&#160;       *eG                                            = 0.0;</div>
<div class="line"><a name="l01446"></a><span class="lineno"> 1446</span>&#160;        </div>
<div class="line"><a name="l01447"></a><span class="lineno"> 1447</span>&#160;        <span class="comment">//============================================ Done</span></div>
<div class="line"><a name="l01448"></a><span class="lineno"> 1448</span>&#160;        return ;</div>
<div class="line"><a name="l01449"></a><span class="lineno"> 1449</span>&#160;    }</div>
<div class="line"><a name="l01450"></a><span class="lineno"> 1450</span>&#160;    </div>
<div class="line"><a name="l01451"></a><span class="lineno"> 1451</span>&#160;    <span class="comment">//================================================ Compute required rotation matrix elements</span></div>
<div class="line"><a name="l01452"></a><span class="lineno"> 1452</span>&#160;    proshade_double cAng                              = std::cos ( axAng );</div>
<div class="line"><a name="l01453"></a><span class="lineno"> 1453</span>&#160;    proshade_double sAng                              = std::sin ( axAng );</div>
<div class="line"><a name="l01454"></a><span class="lineno"> 1454</span>&#160;    proshade_double tAng                              = 1.0 - cAng;</div>
<div class="line"><a name="l01455"></a><span class="lineno"> 1455</span>&#160;    </div>
<div class="line"><a name="l01456"></a><span class="lineno"> 1456</span>&#160;    proshade_double element22                         = cAng + axZ * axZ * tAng;</div>
<div class="line"><a name="l01457"></a><span class="lineno"> 1457</span>&#160;            </div>
<div class="line"><a name="l01458"></a><span class="lineno"> 1458</span>&#160;    proshade_double tmp1                              = axX * axZ * tAng;</div>
<div class="line"><a name="l01459"></a><span class="lineno"> 1459</span>&#160;    proshade_double tmp2                              = axY * sAng;</div>
<div class="line"><a name="l01460"></a><span class="lineno"> 1460</span>&#160;    proshade_double element20                         = tmp1 - tmp2;</div>
<div class="line"><a name="l01461"></a><span class="lineno"> 1461</span>&#160;    proshade_double element02                         = tmp1 + tmp2;</div>
<div class="line"><a name="l01462"></a><span class="lineno"> 1462</span>&#160;            </div>
<div class="line"><a name="l01463"></a><span class="lineno"> 1463</span>&#160;    tmp1                                              = axY * axZ * tAng;</div>
<div class="line"><a name="l01464"></a><span class="lineno"> 1464</span>&#160;    tmp2                                              = axX * sAng;</div>
<div class="line"><a name="l01465"></a><span class="lineno"> 1465</span>&#160;    proshade_double element21                         = tmp1 + tmp2;</div>
<div class="line"><a name="l01466"></a><span class="lineno"> 1466</span>&#160;    proshade_double element12                         = tmp1 - tmp2;</div>
<div class="line"><a name="l01467"></a><span class="lineno"> 1467</span>&#160;    </div>
<div class="line"><a name="l01468"></a><span class="lineno"> 1468</span>&#160;    <span class="comment">//================================================ Convert to Eulers</span></div>
<div class="line"><a name="l01469"></a><span class="lineno"> 1469</span>&#160;    <span class="keywordflow">if</span> ( std::abs( element22 ) &lt;= 0.99999 )</div>
<div class="line"><a name="l01470"></a><span class="lineno"> 1470</span>&#160;    {</div>
<div class="line"><a name="l01471"></a><span class="lineno"> 1471</span>&#160;        <span class="comment">//============================================ This case occurs when there is no singularity in the rotation matrix (i.e. it does not have 0 or 180 degrees angle)</span></div>
<div class="line"><a name="l01472"></a><span class="lineno"> 1472</span>&#160;       *eA                                            = std::atan2 ( element21,  element20 );</div>
<div class="line"><a name="l01473"></a><span class="lineno"> 1473</span>&#160;       *eB                                            = std::acos  ( element22 );</div>
<div class="line"><a name="l01474"></a><span class="lineno"> 1474</span>&#160;       *eG                                            = std::atan2 ( element12, -element02 );</div>
<div class="line"><a name="l01475"></a><span class="lineno"> 1475</span>&#160;    }</div>
<div class="line"><a name="l01476"></a><span class="lineno"> 1476</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l01477"></a><span class="lineno"> 1477</span>&#160;    {</div>
<div class="line"><a name="l01478"></a><span class="lineno"> 1478</span>&#160;        <span class="comment">//============================================ Compute some extra rotation matrix elements</span></div>
<div class="line"><a name="l01479"></a><span class="lineno"> 1479</span>&#160;        tmp1                                          = axX * axY * tAng;</div>
<div class="line"><a name="l01480"></a><span class="lineno"> 1480</span>&#160;        tmp2                                          = axZ * sAng;</div>
<div class="line"><a name="l01481"></a><span class="lineno"> 1481</span>&#160;        proshade_double element10                     = tmp1 + tmp2;</div>
<div class="line"><a name="l01482"></a><span class="lineno"> 1482</span>&#160;        proshade_double element00                     = cAng + axX * axX * tAng;</div>
<div class="line"><a name="l01483"></a><span class="lineno"> 1483</span>&#160;        </div>
<div class="line"><a name="l01484"></a><span class="lineno"> 1484</span>&#160;        <span class="comment">//============================================ This case occurs when there is either 0 or 180 degrees rotation angle in the rotation matrix and therefore when beta is zero.</span></div>
<div class="line"><a name="l01485"></a><span class="lineno"> 1485</span>&#160;        <span class="keywordflow">if</span> ( element22 &gt;= 0.99999 )</div>
<div class="line"><a name="l01486"></a><span class="lineno"> 1486</span>&#160;        {</div>
<div class="line"><a name="l01487"></a><span class="lineno"> 1487</span>&#160;            <span class="comment">//======================================== In this case, beta = 0 and alpha and gamma are only defined in terms of their sum. So we arbitrarily set gamma to 0 and solve alpha.</span></div>
<div class="line"><a name="l01488"></a><span class="lineno"> 1488</span>&#160;           *eA                                        = std::atan2 ( element10, element00 );</div>
<div class="line"><a name="l01489"></a><span class="lineno"> 1489</span>&#160;           *eB                                        = 0.0;</div>
<div class="line"><a name="l01490"></a><span class="lineno"> 1490</span>&#160;           *eG                                        = 0.0;</div>
<div class="line"><a name="l01491"></a><span class="lineno"> 1491</span>&#160;        }</div>
<div class="line"><a name="l01492"></a><span class="lineno"> 1492</span>&#160;        <span class="keywordflow">if</span> ( element22 &lt;= -0.99999 )</div>
<div class="line"><a name="l01493"></a><span class="lineno"> 1493</span>&#160;        {</div>
<div class="line"><a name="l01494"></a><span class="lineno"> 1494</span>&#160;            <span class="comment">//======================================== In this case, beta = 0 and alpha and gamma are only defined in terms of their difference. So we arbitrarily set gamma to 0 and solve alpha.</span></div>
<div class="line"><a name="l01495"></a><span class="lineno"> 1495</span>&#160;           *eA                                        = std::atan2 ( element10, element00 );</div>
<div class="line"><a name="l01496"></a><span class="lineno"> 1496</span>&#160;           *eB                                        = M_PI / 2.0;</div>
<div class="line"><a name="l01497"></a><span class="lineno"> 1497</span>&#160;           *eG                                        = 0.0;</div>
<div class="line"><a name="l01498"></a><span class="lineno"> 1498</span>&#160;        }</div>
<div class="line"><a name="l01499"></a><span class="lineno"> 1499</span>&#160;    }</div>
<div class="line"><a name="l01500"></a><span class="lineno"> 1500</span>&#160;    </div>
<div class="line"><a name="l01501"></a><span class="lineno"> 1501</span>&#160;    <span class="comment">//================================================ Get the angles to proper range</span></div>
<div class="line"><a name="l01502"></a><span class="lineno"> 1502</span>&#160;    <span class="keywordflow">if</span> ( *eA &lt; 0.0 ) { *eA                            = 2.0 * M_PI + *eA; }</div>
<div class="line"><a name="l01503"></a><span class="lineno"> 1503</span>&#160;    <span class="keywordflow">if</span> ( *eB &lt; 0.0 ) { *eB                            =       M_PI + *eB; }</div>
<div class="line"><a name="l01504"></a><span class="lineno"> 1504</span>&#160;    <span class="keywordflow">if</span> ( *eG &lt; 0.0 ) { *eG                            = 2.0 * M_PI + *eG; }</div>
<div class="line"><a name="l01505"></a><span class="lineno"> 1505</span>&#160;    </div>
<div class="line"><a name="l01506"></a><span class="lineno"> 1506</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01507"></a><span class="lineno"> 1507</span>&#160;    return ;</div>
<div class="line"><a name="l01508"></a><span class="lineno"> 1508</span>&#160;   </div>
<div class="line"><a name="l01509"></a><span class="lineno"> 1509</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0ade24485a9272a2d08dd6efb7a54d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ade24485a9272a2d08dd6efb7a54d83">&#9670;&nbsp;</a></span>getEulerZXZFromAngleAxisFullSearch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::getEulerZXZFromAngleAxisFullSearch </td>
          <td>(</td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axAng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>eA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>eB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>eG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>angDim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts angle-axis representation to the Euler ZXZ angles representation using full search. </p>
<p>This function is meant for solving the issue of angle-axis conversion to Euler ZXZ convention for axis 0,0,1, where all the rotation matrix elements used for Euler alpha and gamma angles are 0.0. The function overcomes this by simply searching all the rotation function indices for having angle-axis value similar to the required one - a rather slow approach. Therefore, the <a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a5750d6f0bf8e4a4b1d26552e8719dfd4" title="This function converts angle-axis representation to the Euler ZXZ angles representation.">getEulerZXZFromAngleAxis()</a> function should be used instead and only if it fails (has all angles 0.0), then this function should be used instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">axX</td><td>Angle-axis representation axis x element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axY</td><td>Angle-axis representation axis y element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axZ</td><td>Angle-axis representation axis z element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axAng</td><td>Angle-axis representation angle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eA</td><td>Pointer to which the Euler angle alpha value will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eB</td><td>Pointer to which the Euler angle beta value will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eG</td><td>Pointer to which the Euler angle gamma value will be saved. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01526">1526</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01527"></a><span class="lineno"> 1527</span>&#160;{</div>
<div class="line"><a name="l01528"></a><span class="lineno"> 1528</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l01529"></a><span class="lineno"> 1529</span>&#160;    proshade_double bestDist                          = 999.9;</div>
<div class="line"><a name="l01530"></a><span class="lineno"> 1530</span>&#160;    proshade_double eAHlp, eBHlp, eGHlp, axXHlp, axYHlp, axZHlp, axAngHlp, axDist;</div>
<div class="line"><a name="l01531"></a><span class="lineno"> 1531</span>&#160;    </div>
<div class="line"><a name="l01532"></a><span class="lineno"> 1532</span>&#160;    <span class="comment">//================================================ Allocate memory</span></div>
<div class="line"><a name="l01533"></a><span class="lineno"> 1533</span>&#160;    proshade_double* rMat                             = <span class="keyword">new</span> proshade_double[9];</div>
<div class="line"><a name="l01534"></a><span class="lineno"> 1534</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( rMat, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l01535"></a><span class="lineno"> 1535</span>&#160; </div>
<div class="line"><a name="l01536"></a><span class="lineno"> 1536</span>&#160;    <span class="comment">//================================================ For each rotation function index (i.e. existing Euler angles ZXZ combination)</span></div>
<div class="line"><a name="l01537"></a><span class="lineno"> 1537</span>&#160;    <span class="keywordflow">for</span> ( proshade_signed xIt = 0; xIt &lt; angDim; xIt++ )</div>
<div class="line"><a name="l01538"></a><span class="lineno"> 1538</span>&#160;    {</div>
<div class="line"><a name="l01539"></a><span class="lineno"> 1539</span>&#160;        <span class="keywordflow">for</span> ( proshade_signed yIt = 0; yIt &lt; angDim; yIt++ )</div>
<div class="line"><a name="l01540"></a><span class="lineno"> 1540</span>&#160;        {</div>
<div class="line"><a name="l01541"></a><span class="lineno"> 1541</span>&#160;            <span class="keywordflow">for</span> ( proshade_signed zIt = 0; zIt &lt; angDim; zIt++ )</div>
<div class="line"><a name="l01542"></a><span class="lineno"> 1542</span>&#160;            {</div>
<div class="line"><a name="l01543"></a><span class="lineno"> 1543</span>&#160;                <span class="comment">//==================================== Speed up</span></div>
<div class="line"><a name="l01544"></a><span class="lineno"> 1544</span>&#160;                <span class="keywordflow">if</span> ( bestDist &lt; 0.001 ) { <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l01545"></a><span class="lineno"> 1545</span>&#160;                </div>
<div class="line"><a name="l01546"></a><span class="lineno"> 1546</span>&#160;                <span class="comment">//==================================== Get Euler ZXZ from the indices</span></div>
<div class="line"><a name="l01547"></a><span class="lineno"> 1547</span>&#160;                <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#acf6c5376edac98e54ef0e418cd05d706">getEulerZXZFromSOFTPosition</a>           ( angDim/2, xIt, yIt, zIt, &amp;eAHlp, &amp;eBHlp, &amp;eGHlp );</div>
<div class="line"><a name="l01548"></a><span class="lineno"> 1548</span>&#160;                <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#abd9fe573a48f499dd7d1df4f779222f1">getRotationMatrixFromEulerZXZAngles</a>   ( eAHlp, eBHlp, eGHlp, rMat );</div>
<div class="line"><a name="l01549"></a><span class="lineno"> 1549</span>&#160;                <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#aafc6f1626c7463de53c9f4f6fa11db22">getAxisAngleFromRotationMatrix</a>        ( rMat, &amp;axXHlp, &amp;axYHlp, &amp;axZHlp, &amp;axAngHlp );</div>
<div class="line"><a name="l01550"></a><span class="lineno"> 1550</span>&#160;                </div>
<div class="line"><a name="l01551"></a><span class="lineno"> 1551</span>&#160;                <span class="comment">//==================================== If angle is larger than 180 degrees</span></div>
<div class="line"><a name="l01552"></a><span class="lineno"> 1552</span>&#160;                <span class="keywordflow">if</span> ( axAng &gt; M_PI )</div>
<div class="line"><a name="l01553"></a><span class="lineno"> 1553</span>&#160;                {</div>
<div class="line"><a name="l01554"></a><span class="lineno"> 1554</span>&#160;                    axAng                             = ( 2.0 * M_PI ) - axAng;</div>
<div class="line"><a name="l01555"></a><span class="lineno"> 1555</span>&#160;                    axAng                            *= -1.0;</div>
<div class="line"><a name="l01556"></a><span class="lineno"> 1556</span>&#160;                }</div>
<div class="line"><a name="l01557"></a><span class="lineno"> 1557</span>&#160;                </div>
<div class="line"><a name="l01558"></a><span class="lineno"> 1558</span>&#160;                <span class="comment">//==================================== Make sure vector direction is the same</span></div>
<div class="line"><a name="l01559"></a><span class="lineno"> 1559</span>&#160;                <span class="keywordflow">if</span> ( ( ( std::max( std::abs( axXHlp ), std::max( std::abs( axYHlp ), std::abs( axZHlp ) ) ) == std::abs( axXHlp ) ) &amp;&amp; ( axXHlp &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l01560"></a><span class="lineno"> 1560</span>&#160;                     ( ( std::max( std::abs( axXHlp ), std::max( std::abs( axYHlp ), std::abs( axZHlp ) ) ) == std::abs( axYHlp ) ) &amp;&amp; ( axYHlp &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l01561"></a><span class="lineno"> 1561</span>&#160;                     ( ( std::max( std::abs( axXHlp ), std::max( std::abs( axYHlp ), std::abs( axZHlp ) ) ) == std::abs( axZHlp ) ) &amp;&amp; ( axZHlp &lt; 0.0 ) ) )</div>
<div class="line"><a name="l01562"></a><span class="lineno"> 1562</span>&#160;                {</div>
<div class="line"><a name="l01563"></a><span class="lineno"> 1563</span>&#160;                    axXHlp                           *= -1.0;</div>
<div class="line"><a name="l01564"></a><span class="lineno"> 1564</span>&#160;                    axYHlp                           *= -1.0;</div>
<div class="line"><a name="l01565"></a><span class="lineno"> 1565</span>&#160;                    axZHlp                           *= -1.0;</div>
<div class="line"><a name="l01566"></a><span class="lineno"> 1566</span>&#160;                    axAngHlp                         *= -1.0;</div>
<div class="line"><a name="l01567"></a><span class="lineno"> 1567</span>&#160;                }</div>
<div class="line"><a name="l01568"></a><span class="lineno"> 1568</span>&#160;                </div>
<div class="line"><a name="l01569"></a><span class="lineno"> 1569</span>&#160;                <span class="keywordflow">if</span> ( ( ( std::max( std::abs( axX ), std::max( std::abs( axY ), std::abs( axZ ) ) ) == std::abs( axX ) ) &amp;&amp; ( axX &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l01570"></a><span class="lineno"> 1570</span>&#160;                     ( ( std::max( std::abs( axX ), std::max( std::abs( axY ), std::abs( axZ ) ) ) == std::abs( axY ) ) &amp;&amp; ( axY &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l01571"></a><span class="lineno"> 1571</span>&#160;                     ( ( std::max( std::abs( axX ), std::max( std::abs( axY ), std::abs( axZ ) ) ) == std::abs( axZ ) ) &amp;&amp; ( axZ &lt; 0.0 ) ) )</div>
<div class="line"><a name="l01572"></a><span class="lineno"> 1572</span>&#160;                {</div>
<div class="line"><a name="l01573"></a><span class="lineno"> 1573</span>&#160;                    axX                              *= -1.0;</div>
<div class="line"><a name="l01574"></a><span class="lineno"> 1574</span>&#160;                    axY                              *= -1.0;</div>
<div class="line"><a name="l01575"></a><span class="lineno"> 1575</span>&#160;                    axZ                              *= -1.0;</div>
<div class="line"><a name="l01576"></a><span class="lineno"> 1576</span>&#160;                    axAng                            *= -1.0;</div>
<div class="line"><a name="l01577"></a><span class="lineno"> 1577</span>&#160;                }</div>
<div class="line"><a name="l01578"></a><span class="lineno"> 1578</span>&#160;                </div>
<div class="line"><a name="l01579"></a><span class="lineno"> 1579</span>&#160;                <span class="comment">//==================================== Compute distance to the requested angle-axis values</span></div>
<div class="line"><a name="l01580"></a><span class="lineno"> 1580</span>&#160;                axDist                                = std::abs( axAng - axAngHlp ) + ( 1.0 - std::abs ( ( ( axX * axXHlp ) + ( axY * axYHlp ) + ( axZ * axZHlp ) ) /</div>
<div class="line"><a name="l01581"></a><span class="lineno"> 1581</span>&#160;                                                        ( sqrt( pow( axX, 2.0 ) + pow( axY, 2.0 ) + pow( axZ, 2.0 ) ) * sqrt( pow( axXHlp, 2.0 ) + pow( axYHlp, 2.0 ) + pow( axZHlp, 2.0 ) ) ) ) );</div>
<div class="line"><a name="l01582"></a><span class="lineno"> 1582</span>&#160;                </div>
<div class="line"><a name="l01583"></a><span class="lineno"> 1583</span>&#160;                <span class="comment">//==================================== Is this point an improvement</span></div>
<div class="line"><a name="l01584"></a><span class="lineno"> 1584</span>&#160;                <span class="keywordflow">if</span> ( std::abs ( axDist ) &lt; bestDist )</div>
<div class="line"><a name="l01585"></a><span class="lineno"> 1585</span>&#160;                {</div>
<div class="line"><a name="l01586"></a><span class="lineno"> 1586</span>&#160;                    <span class="comment">//================================ If so, note it</span></div>
<div class="line"><a name="l01587"></a><span class="lineno"> 1587</span>&#160;                    bestDist                          = std::abs ( axDist );</div>
<div class="line"><a name="l01588"></a><span class="lineno"> 1588</span>&#160;                   *eA                                = eAHlp;</div>
<div class="line"><a name="l01589"></a><span class="lineno"> 1589</span>&#160;                   *eB                                = eBHlp;</div>
<div class="line"><a name="l01590"></a><span class="lineno"> 1590</span>&#160;                   *eG                                = eGHlp;</div>
<div class="line"><a name="l01591"></a><span class="lineno"> 1591</span>&#160;                }</div>
<div class="line"><a name="l01592"></a><span class="lineno"> 1592</span>&#160;            }</div>
<div class="line"><a name="l01593"></a><span class="lineno"> 1593</span>&#160;        }</div>
<div class="line"><a name="l01594"></a><span class="lineno"> 1594</span>&#160;    }</div>
<div class="line"><a name="l01595"></a><span class="lineno"> 1595</span>&#160;    </div>
<div class="line"><a name="l01596"></a><span class="lineno"> 1596</span>&#160;    <span class="comment">//================================================ Release memory</span></div>
<div class="line"><a name="l01597"></a><span class="lineno"> 1597</span>&#160;    <span class="keyword">delete</span>[] rMat;</div>
<div class="line"><a name="l01598"></a><span class="lineno"> 1598</span>&#160;    </div>
<div class="line"><a name="l01599"></a><span class="lineno"> 1599</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01600"></a><span class="lineno"> 1600</span>&#160;    return ;</div>
<div class="line"><a name="l01601"></a><span class="lineno"> 1601</span>&#160;    </div>
<div class="line"><a name="l01602"></a><span class="lineno"> 1602</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae6f6afcef5b90ca77d7d6a9e91824e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f6afcef5b90ca77d7d6a9e91824e28">&#9670;&nbsp;</a></span>getEulerZXZFromRotMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::getEulerZXZFromRotMatrix </td>
          <td>(</td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>rotMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>eA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>eB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>eG</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts rotation matrix to the Euler ZXZ angles representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rotMat</td><td>Rotation matrix as an array of 9 values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eA</td><td>Pointer to which the Euler angle alpha value will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eB</td><td>Pointer to which the Euler angle beta value will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eG</td><td>Pointer to which the Euler angle gamma value will be saved. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01394">1394</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01395"></a><span class="lineno"> 1395</span>&#160;{</div>
<div class="line"><a name="l01396"></a><span class="lineno"> 1396</span>&#160;    <span class="comment">//================================================ Get ZXZ Euler from matrix</span></div>
<div class="line"><a name="l01397"></a><span class="lineno"> 1397</span>&#160;   *eA                                                = atan2 ( rotMat[7],  rotMat[6] );</div>
<div class="line"><a name="l01398"></a><span class="lineno"> 1398</span>&#160;   *eB                                                = acos  ( rotMat[8] );</div>
<div class="line"><a name="l01399"></a><span class="lineno"> 1399</span>&#160;   *eG                                                = atan2 ( rotMat[5], -rotMat[2] );</div>
<div class="line"><a name="l01400"></a><span class="lineno"> 1400</span>&#160;    </div>
<div class="line"><a name="l01401"></a><span class="lineno"> 1401</span>&#160;    <span class="comment">//================================================ Solve undefined 0,0 inputs (i.e. identity matrix)</span></div>
<div class="line"><a name="l01402"></a><span class="lineno"> 1402</span>&#160;    proshade_double errLimit                          = 0.001;</div>
<div class="line"><a name="l01403"></a><span class="lineno"> 1403</span>&#160;    <span class="keywordflow">if</span> ( ( ( rotMat[7] &lt; errLimit ) &amp;&amp; ( rotMat[7] &gt; -errLimit ) ) &amp;&amp; ( ( rotMat[6] &lt; errLimit ) &amp;&amp; ( rotMat[6] &gt; -errLimit ) ) )</div>
<div class="line"><a name="l01404"></a><span class="lineno"> 1404</span>&#160;    {</div>
<div class="line"><a name="l01405"></a><span class="lineno"> 1405</span>&#160;        <span class="comment">//============================================ atan2 (0,0) is undefined, we want 0.0 here</span></div>
<div class="line"><a name="l01406"></a><span class="lineno"> 1406</span>&#160;       *eA                                            = 0.0;</div>
<div class="line"><a name="l01407"></a><span class="lineno"> 1407</span>&#160;    }</div>
<div class="line"><a name="l01408"></a><span class="lineno"> 1408</span>&#160;    </div>
<div class="line"><a name="l01409"></a><span class="lineno"> 1409</span>&#160;    <span class="keywordflow">if</span> ( ( ( rotMat[5] &lt; errLimit ) &amp;&amp; ( rotMat[5] &gt; -errLimit ) ) &amp;&amp; ( ( rotMat[2] &lt; errLimit ) &amp;&amp; ( rotMat[2] &gt; -errLimit ) ) )</div>
<div class="line"><a name="l01410"></a><span class="lineno"> 1410</span>&#160;    {</div>
<div class="line"><a name="l01411"></a><span class="lineno"> 1411</span>&#160;        <span class="comment">//============================================ atan2 (0,0) is undefined, we want 0.0 here</span></div>
<div class="line"><a name="l01412"></a><span class="lineno"> 1412</span>&#160;       *eG                                            = 0.0;</div>
<div class="line"><a name="l01413"></a><span class="lineno"> 1413</span>&#160;    }</div>
<div class="line"><a name="l01414"></a><span class="lineno"> 1414</span>&#160;    </div>
<div class="line"><a name="l01415"></a><span class="lineno"> 1415</span>&#160;    <span class="comment">//================================================ Get the angles to proper range</span></div>
<div class="line"><a name="l01416"></a><span class="lineno"> 1416</span>&#160;    <span class="keywordflow">if</span> ( *eA &lt; 0.0 ) { *eA                            = 2.0 * M_PI + *eA; }</div>
<div class="line"><a name="l01417"></a><span class="lineno"> 1417</span>&#160;    <span class="keywordflow">if</span> ( *eB &lt; 0.0 ) { *eB                            =       M_PI + *eB; }</div>
<div class="line"><a name="l01418"></a><span class="lineno"> 1418</span>&#160;    <span class="keywordflow">if</span> ( *eG &lt; 0.0 ) { *eG                            = 2.0 * M_PI + *eG; }</div>
<div class="line"><a name="l01419"></a><span class="lineno"> 1419</span>&#160;    </div>
<div class="line"><a name="l01420"></a><span class="lineno"> 1420</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01421"></a><span class="lineno"> 1421</span>&#160;    return ;</div>
<div class="line"><a name="l01422"></a><span class="lineno"> 1422</span>&#160;    </div>
<div class="line"><a name="l01423"></a><span class="lineno"> 1423</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="acf6c5376edac98e54ef0e418cd05d706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6c5376edac98e54ef0e418cd05d706">&#9670;&nbsp;</a></span>getEulerZXZFromSOFTPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::getEulerZXZFromSOFTPosition </td>
          <td>(</td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>band</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>eulerAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>eulerBeta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>eulerGamma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to find Euler angles (ZXZ convention) from index position in the inverse SOFT map. </p>
<p>This function proceeds to convert the inverse SOFT map x, y and z position to Euler ZXZ convention angles, saving these into the supplied pointers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">band</td><td>The maximum bandwidth of the computation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The x-axis position in the inverse SOFT map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The y-axis position in the inverse SOFT map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>The z-axis position in the inverse SOFT map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eulerAlpha</td><td>Pointer to where the Euler alpha angle will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eulerBeta</td><td>Pointer to where the Euler beta angle will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eulerGamma</td><td>Pointer to where the Euler gamma angle will be saved. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00961">961</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;{</div>
<div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;    <span class="comment">//================================================ Convert index to Euler angles</span></div>
<div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;   *eulerGamma                                        = ( M_PI * y / <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( 1.0 * band ) );</div>
<div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;   *eulerBeta                                         = ( M_PI * x / <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( 2.0 * band ) );</div>
<div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;   *eulerAlpha                                        = ( M_PI * z / <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( 1.0 * band ) );</div>
<div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;    </div>
<div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;    return ;</div>
<div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;    </div>
<div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1823adaca871244e42347ecb8ed834a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1823adaca871244e42347ecb8ed834a2">&#9670;&nbsp;</a></span>getGLFirstEvenRoot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::getGLFirstEvenRoot </td>
          <td>(</td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>polyAtZero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>abscAtZero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>weighAtZero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>taylorSeriesCap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function finds the first root for Legendre polynomials of odd order. </p>
<p>The Legendre polynomials with odd order have zero as the first root, but the even oder polenomials have different value and this function serves the purpose of finding this value (i.e. the first root of the polynomial if the order is even).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polyAtZero</td><td>The value of the polynomial at zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>The positive integer value of the polynomial order. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">abscAtZero</td><td>Pointer to variable storing the abscissa value at zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weightAtZero</td><td>Pointer to variable storing the weight value at zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">taylorSeriesCap</td><td>The limit on the Taylor series. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00384">384</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;{</div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;    <span class="comment">//================================================ Sanity check</span></div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;    <span class="keywordflow">if</span> ( taylorSeriesCap &lt; 2 )</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;    {</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;        <span class="keywordflow">throw</span> <a class="code" href="class_pro_s_h_a_d_e__exception.html">ProSHADE_exception</a> ( <span class="stringliteral">&quot;The Taylor series cap is too low.&quot;</span>, <span class="stringliteral">&quot;EI00020&quot;</span>, __FILE__, __LINE__, __func__, <span class="stringliteral">&quot;The Taylor series expansion limit is less than 2. This\n                    : seems very low; if you have a very small structure or very\n                    : low resolution, please manually increase the integration\n                    : order. Otherwise, please report this as a bug.&quot;</span> );</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;    }</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    </div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;   *abscAtZero                                        = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a4f2619c7f3b8d628af9cb356778e9807">advanceGLPolyValue</a> ( 0.0, -M_PI / 2.0, 0.0, order, taylorSeriesCap );</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;    proshade_double hlp                               = 0.0;</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    proshade_double hlpVal                            = <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( order );</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;    proshade_double *abscSteps;</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;    proshade_double *weightSteps;</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160; </div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;    <span class="comment">//================================================ Allocate memory</span></div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;    abscSteps                                         = <span class="keyword">new</span> proshade_double [taylorSeriesCap+2];</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;    weightSteps                                       = <span class="keyword">new</span> proshade_double [taylorSeriesCap+1];</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160; </div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    <span class="comment">//================================================ Pre-set values</span></div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;    abscSteps[0]                                      = 0.0;</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;    abscSteps[1]                                      = polyAtZero;</div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;    weightSteps[0]                                    = 0.0;</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160; </div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;    <span class="comment">//================================================ Fill in abscissa and weight steps</span></div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt;= taylorSeriesCap - 2; iter = iter + 2 )</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;    {</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;        hlp                                           = <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( iter );</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;        </div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;        abscSteps[iter+2]                             = 0.0;</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;        abscSteps[iter+3]                             = ( hlp * ( hlp + 1.0 ) - hlpVal * ( hlpVal + 1.0 ) ) * abscSteps[iter+1] / (hlp + 1.0) / (hlp + 2.0 );</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;        </div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;        weightSteps[iter+1]                           = 0.0;</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;        weightSteps[iter+2]                           = ( hlp + 2.0 ) * abscSteps[iter+3];</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;    }</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160; </div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    <span class="comment">//================================================ Find abscissa and weights</span></div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;    <span class="keywordflow">for</span> ( proshade_double iter = 0; iter &lt; 5; iter++ )</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;    {</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;        *abscAtZero                                   = *abscAtZero - <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a7e69b64278319ae1a1268d1a55545675">evaluateGLSeries</a> ( abscSteps, *abscAtZero, taylorSeriesCap ) / <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a7e69b64278319ae1a1268d1a55545675">evaluateGLSeries</a> ( weightSteps, *abscAtZero, taylorSeriesCap-1 );</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;    }</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;    *weighAtZero                                      = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a7e69b64278319ae1a1268d1a55545675">evaluateGLSeries</a> ( weightSteps, *abscAtZero, taylorSeriesCap-1 );</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160; </div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    <span class="comment">//================================================ Free memory</span></div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;    <span class="keyword">delete</span> abscSteps;</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;    <span class="keyword">delete</span> weightSteps;</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160; </div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;    return ;</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;    </div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="affab74b910cda2ee3faa461740a7a432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affab74b910cda2ee3faa461740a7a432">&#9670;&nbsp;</a></span>getGLPolyAtZero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::getGLPolyAtZero </td>
          <td>(</td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>polyValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>deriValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function obtains the Legendre polynomial values and its derivative at zero for any positive integer order polynomial. </p>
<p>This function takes the positive integer order of the Legendre polynomial and uses the recursive properties of the polynomials to work up to the order, computing the value at zero and its derivative for all lesser orders. It then returns the final values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Positive integer order of the Legendre polynomial which value at zero we want. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polyValue</td><td>Pointer to variable which will store the resulting polynomial value at zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deriValue</td><td>Pointer to variable which will store the derivative of the zero value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00347">347</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;{</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;    <span class="comment">//================================================ Initialise</span></div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;    proshade_double hlpVal                            = 0.0;</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    proshade_double prevPoly                          = 1.0;</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;    proshade_double prevPrevPoly                      = 0.0;</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;    proshade_double prevDeri                          = 0.0;</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;    proshade_double prevPrevDeri                      = 0.0;</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;    </div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign ordIt = 0; ordIt &lt; order; ordIt++ )</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;    {</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;        hlpVal                                        = <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( ordIt );</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;        *polyValue                                    = -hlpVal * prevPrevPoly / ( hlpVal + 1.0 );</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;        *deriValue                                    = ( ( 2.0 * hlpVal + 1.0 ) * prevPoly - hlpVal * prevPrevDeri ) / ( hlpVal + 1.0 );</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;        prevPrevPoly                                  = prevPoly;</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;        prevPoly                                      = *polyValue;</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;        prevPrevDeri                                  = prevDeri;</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;        prevDeri                                      = *deriValue;</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;    }</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;    </div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;    return ;</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;    </div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6e2f7de1bba288270ce2cc772d28d065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2f7de1bba288270ce2cc772d28d065">&#9670;&nbsp;</a></span>getLegendreAbscAndWeights()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::getLegendreAbscAndWeights </td>
          <td>(</td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>abscissas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>taylorSeriesCap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to prepare abscissas and weights for Gauss-Legendre integration. </p>
<p>This function fills in the Gauss-Legendre interpolation points positions (abscissas) and their weights vectors, which will then be used for computing the Gauss-Legendre interpolation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>The order to which the abscissas and weights should be prepared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">abscissas</td><td>The array holding the abscissa values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>The array holding the weight values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">taylorSeriesCap</td><td>The limit on the Taylor series. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00287">287</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;{</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;    <span class="comment">//================================================ Sanity check</span></div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;    <span class="keywordflow">if</span> ( order &lt; 2 )</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;    {</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;        <span class="keywordflow">throw</span> <a class="code" href="class_pro_s_h_a_d_e__exception.html">ProSHADE_exception</a> ( <span class="stringliteral">&quot;The integration order is too low.&quot;</span>, <span class="stringliteral">&quot;EI00019&quot;</span>, __FILE__, __LINE__, __func__, <span class="stringliteral">&quot;The Gauss-Legendre integration order is less than 2. This\n                    : seems very low; if you have a very small structure or very\n                    : low resolution, please manually increase the integration\n                    : order. Otherwise, please report this as a bug.&quot;</span> );</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    }</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;    </div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;    <span class="comment">//================================================ Initialise</span></div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;    proshade_double polyValue                         = 0.0;</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    proshade_double deriValue                         = 0.0;</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;    proshade_double weightSum                         = 0.0;</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;    </div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    <span class="comment">//================================================ Find the polynomial and derivative values at 0</span></div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#affab74b910cda2ee3faa461740a7a432">getGLPolyAtZero</a>                                   ( order,</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;                                                       &amp;polyValue,</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;                                                       &amp;deriValue );</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;    </div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;    <span class="comment">//================================================ If the order is odd, then 0 is a root ...</span></div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;    <span class="keywordflow">if</span> ( order % 2 == 1 )</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;    {</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;        abscissas[((order-1)/2)]                      = polyValue;</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;        weights[((order-1)/2)]                        = deriValue;</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    }</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;    {</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;        <span class="comment">// ... and if order is even, find the first root</span></div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a1823adaca871244e42347ecb8ed834a2">getGLFirstEvenRoot</a>                            ( polyValue, order, &amp;abscissas[(order/2)], &amp;weights[(order/2)], taylorSeriesCap );</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;    }</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160; </div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;    <span class="comment">//================================================ Now, having computed the first roots, complete the series</span></div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a31c91064de64aef9f8278d533f8188ad">completeLegendreSeries</a>                            ( order, abscissas, weights, taylorSeriesCap );</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160; </div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;    <span class="comment">//================================================ Correct weights by anscissa values</span></div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; order; iter++ )</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;    {</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;        weights[iter]                                 = 2.0 / ( 1.0 - abscissas[iter] ) / ( 1.0 + abscissas[iter] ) / weights[iter] / weights[iter];</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;        weightSum                                     = weightSum + weights[iter];</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;    }</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160; </div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;    <span class="comment">//================================================ Normalise weights</span></div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; order; iter++ )</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;    {</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;        weights[iter]                                 = 2.0 * weights[iter] / weightSum;</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;    }</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;    </div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    return ;</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a39eafef902a49cc0816a2ed675c14a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39eafef902a49cc0816a2ed675c14a49">&#9670;&nbsp;</a></span>getRotationMatrixFromAngleAxis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::getRotationMatrixFromAngleAxis </td>
          <td>(</td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>rotMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>ang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts the axis-angle representation to the rotation matrix representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rotMat</td><td>Rotation matrix as an array of 9 values will be saved to this pointer, must already be allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The x-axis value of the axis vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The y-axis value of the axis vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>The z-axis value of the axis vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angThe</td><td>angle value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01343">1343</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01344"></a><span class="lineno"> 1344</span>&#160;{</div>
<div class="line"><a name="l01345"></a><span class="lineno"> 1345</span>&#160;    <span class="comment">//================================================ If angle is 0 or infinity (anything divided by 0), return identity matrix</span></div>
<div class="line"><a name="l01346"></a><span class="lineno"> 1346</span>&#160;    <span class="keywordflow">if</span> ( ( ang == 0.0 ) || ( std::isinf ( ang ) ) )</div>
<div class="line"><a name="l01347"></a><span class="lineno"> 1347</span>&#160;    {</div>
<div class="line"><a name="l01348"></a><span class="lineno"> 1348</span>&#160;        <span class="comment">//============================================ Create identity</span></div>
<div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign i = 0; i &lt; 9; i++ ) { rotMat[i] = 0.0; }</div>
<div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160;        rotMat[0]                                     = 1.0;</div>
<div class="line"><a name="l01351"></a><span class="lineno"> 1351</span>&#160;        rotMat[4]                                     = 1.0;</div>
<div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160;        rotMat[8]                                     = 1.0;</div>
<div class="line"><a name="l01353"></a><span class="lineno"> 1353</span>&#160;        </div>
<div class="line"><a name="l01354"></a><span class="lineno"> 1354</span>&#160;        <span class="comment">//============================================ Done</span></div>
<div class="line"><a name="l01355"></a><span class="lineno"> 1355</span>&#160;        return ;</div>
<div class="line"><a name="l01356"></a><span class="lineno"> 1356</span>&#160;    }</div>
<div class="line"><a name="l01357"></a><span class="lineno"> 1357</span>&#160;    </div>
<div class="line"><a name="l01358"></a><span class="lineno"> 1358</span>&#160;    <span class="comment">//================================================ Compute the matrix</span></div>
<div class="line"><a name="l01359"></a><span class="lineno"> 1359</span>&#160;    proshade_double cAng                              = cos ( ang );</div>
<div class="line"><a name="l01360"></a><span class="lineno"> 1360</span>&#160;    proshade_double sAng                              = sin ( ang );</div>
<div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160;    proshade_double tAng                              = 1.0 - cAng;</div>
<div class="line"><a name="l01362"></a><span class="lineno"> 1362</span>&#160;            </div>
<div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;    rotMat[0]                                         = cAng + x * x * tAng;</div>
<div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160;    rotMat[4]                                         = cAng + y * y * tAng;</div>
<div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160;    rotMat[8]                                         = cAng + z * z * tAng;</div>
<div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160;            </div>
<div class="line"><a name="l01367"></a><span class="lineno"> 1367</span>&#160;    proshade_double tmp1                              = x * y * tAng;</div>
<div class="line"><a name="l01368"></a><span class="lineno"> 1368</span>&#160;    proshade_double tmp2                              = z * sAng;</div>
<div class="line"><a name="l01369"></a><span class="lineno"> 1369</span>&#160;    rotMat[3]                                         = tmp1 + tmp2;</div>
<div class="line"><a name="l01370"></a><span class="lineno"> 1370</span>&#160;    rotMat[1]                                         = tmp1 - tmp2;</div>
<div class="line"><a name="l01371"></a><span class="lineno"> 1371</span>&#160;            </div>
<div class="line"><a name="l01372"></a><span class="lineno"> 1372</span>&#160;    tmp1                                              = x * z * tAng;</div>
<div class="line"><a name="l01373"></a><span class="lineno"> 1373</span>&#160;    tmp2                                              = y * sAng;</div>
<div class="line"><a name="l01374"></a><span class="lineno"> 1374</span>&#160;    rotMat[6]                                         = tmp1 - tmp2;</div>
<div class="line"><a name="l01375"></a><span class="lineno"> 1375</span>&#160;    rotMat[2]                                         = tmp1 + tmp2;</div>
<div class="line"><a name="l01376"></a><span class="lineno"> 1376</span>&#160;            </div>
<div class="line"><a name="l01377"></a><span class="lineno"> 1377</span>&#160;    tmp1                                              = y * z * tAng;</div>
<div class="line"><a name="l01378"></a><span class="lineno"> 1378</span>&#160;    tmp2                                              = x * sAng;</div>
<div class="line"><a name="l01379"></a><span class="lineno"> 1379</span>&#160;    rotMat[7]                                         = tmp1 + tmp2;</div>
<div class="line"><a name="l01380"></a><span class="lineno"> 1380</span>&#160;    rotMat[5]                                         = tmp1 - tmp2;</div>
<div class="line"><a name="l01381"></a><span class="lineno"> 1381</span>&#160;    </div>
<div class="line"><a name="l01382"></a><span class="lineno"> 1382</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01383"></a><span class="lineno"> 1383</span>&#160;    return ;</div>
<div class="line"><a name="l01384"></a><span class="lineno"> 1384</span>&#160;    </div>
<div class="line"><a name="l01385"></a><span class="lineno"> 1385</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="abd9fe573a48f499dd7d1df4f779222f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd9fe573a48f499dd7d1df4f779222f1">&#9670;&nbsp;</a></span>getRotationMatrixFromEulerZXZAngles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::getRotationMatrixFromEulerZXZAngles </td>
          <td>(</td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>eulerAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>eulerBeta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>eulerGamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to find the rotation matrix from Euler angles (ZXZ convention). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eulerAlpha</td><td>The Euler alpha angle value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eulerBeta</td><td>The Euler beta angle value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eulerGamma</td><td>The Euler gamma angle value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>A pointer to array of 9 values to which the results of the function will be saved. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01005">1005</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;{</div>
<div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;    <span class="comment">//================================================ First row</span></div>
<div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;    matrix[0]                                         =  cos ( eulerAlpha ) * cos ( eulerBeta  ) * cos ( eulerGamma ) - sin ( eulerAlpha ) * sin ( eulerGamma );</div>
<div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;    matrix[1]                                         =  sin ( eulerAlpha ) * cos ( eulerBeta  ) * cos ( eulerGamma ) + cos ( eulerAlpha ) * sin ( eulerGamma );</div>
<div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;    matrix[2]                                         = -sin ( eulerBeta  ) * cos ( eulerGamma );</div>
<div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;  </div>
<div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;    <span class="comment">//================================================ Second row</span></div>
<div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;    matrix[3]                                         = -cos ( eulerAlpha ) * cos ( eulerBeta  ) * sin ( eulerGamma ) - sin ( eulerAlpha ) * cos ( eulerGamma );</div>
<div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;    matrix[4]                                         = -sin ( eulerAlpha ) * cos ( eulerBeta  ) * sin ( eulerGamma ) + cos ( eulerAlpha ) * cos ( eulerGamma );</div>
<div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;    matrix[5]                                         =  sin ( eulerBeta  ) * sin ( eulerGamma );</div>
<div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;  </div>
<div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;    <span class="comment">//================================================ Third row</span></div>
<div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;    matrix[6]                                         =  cos ( eulerAlpha ) * sin ( eulerBeta  );</div>
<div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;    matrix[7]                                         =  sin ( eulerAlpha ) * sin ( eulerBeta  );</div>
<div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;    matrix[8]                                         =  cos ( eulerBeta  );</div>
<div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;    </div>
<div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;    return ;</div>
<div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;    </div>
<div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="adea245a9b2b305f970be1ed62b141cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea245a9b2b305f970be1ed62b141cce">&#9670;&nbsp;</a></span>getSOFTPositionFromEulerZXZ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::getSOFTPositionFromEulerZXZ </td>
          <td>(</td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>band</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>eulerAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>eulerBeta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>eulerGamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to find the index position in the inverse SOFT map from given Euler angles (ZXZ convention). </p>
<p>This function does the conversion from Euler angles ZXZ convention to the SOFT map x, y and z position. It is not limitted to the SOFT map indices and instead if given Euler agnles between two indices will return a decimal point for the indices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">band</td><td>The maximum bandwidth of the computation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eulerAlpha</td><td>The Euler alpha angle value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eulerBeta</td><td>The Euler beta angle value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eulerGamma</td><td>The Euler gamma angle value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Pointer to where the closest x-axis position in the inverse SOFT map will be saved to (position may be decimal!). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Pointer to where the closest y-axis position in the inverse SOFT map will be saved to (position may be decimal!). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>Pointer to where the closest z-axis position in the inverse SOFT map will be saved to (position may be decimal!). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00986">986</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;{</div>
<div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;    <span class="comment">//================================================ Convert Euler angles to indices</span></div>
<div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;    *x                                                = <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( ( eulerBeta  * <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( 2.0 * band ) ) / M_PI );</div>
<div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;    *y                                                = <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( ( eulerGamma * <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( band       ) ) / M_PI );</div>
<div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;    *z                                                = <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( ( eulerAlpha * <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( band       ) ) / M_PI );</div>
<div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;    </div>
<div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;    return ;</div>
<div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;    </div>
<div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2380a3710f7dbe672519c3adda30f7cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2380a3710f7dbe672519c3adda30f7cd">&#9670;&nbsp;</a></span>isAxisUnique() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_maths::isAxisUnique </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>improve</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if new axis is unique, or already detected. </p>
<p>This function compares the supplied axis against all members of the axes vector. If the axis has the same fold and very similar axis vector (i.e. all three elements are within tolerance), then the function returns false. If no such match is found, true is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axis</td><td>The axis to be checked against CSymList to see if it not already present. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>The allowed error on each dimension of the axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">improve</td><td>If a similar axis is found and if this already existing axis has lower peak height, should the CSymList be updated with the higher peak height axis? </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>Boolean specifying whether a similar axis was found or not. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l02397">2397</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02398"></a><span class="lineno"> 2398</span>&#160;{</div>
<div class="line"><a name="l02399"></a><span class="lineno"> 2399</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l02400"></a><span class="lineno"> 2400</span>&#160;    <span class="keywordtype">bool</span> ret                                          = <span class="keyword">true</span>;</div>
<div class="line"><a name="l02401"></a><span class="lineno"> 2401</span>&#160;    proshade_unsign whichImprove;</div>
<div class="line"><a name="l02402"></a><span class="lineno"> 2402</span>&#160;    </div>
<div class="line"><a name="l02403"></a><span class="lineno"> 2403</span>&#160;    <span class="comment">//================================================ For each already detected member</span></div>
<div class="line"><a name="l02404"></a><span class="lineno"> 2404</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign grIt = 0; grIt &lt; static_cast&lt;proshade_unsign&gt; ( CSymList-&gt;size() ); grIt++ )</div>
<div class="line"><a name="l02405"></a><span class="lineno"> 2405</span>&#160;    {</div>
<div class="line"><a name="l02406"></a><span class="lineno"> 2406</span>&#160;        <span class="comment">//============================================ Is fold the same?</span></div>
<div class="line"><a name="l02407"></a><span class="lineno"> 2407</span>&#160;        <span class="keywordflow">if</span> ( CSymList-&gt;at(grIt)[0] == axis[0] )</div>
<div class="line"><a name="l02408"></a><span class="lineno"> 2408</span>&#160;        {</div>
<div class="line"><a name="l02409"></a><span class="lineno"> 2409</span>&#160;            <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2b2f67cba1eea57f19fdaf062db74fde">ProSHADE_internal_maths::vectorOrientationSimilarity</a> ( CSymList-&gt;at(grIt)[1], CSymList-&gt;at(grIt)[2], CSymList-&gt;at(grIt)[3], axis[1], axis[2], axis[3], tolerance ) )</div>
<div class="line"><a name="l02410"></a><span class="lineno"> 2410</span>&#160;            {</div>
<div class="line"><a name="l02411"></a><span class="lineno"> 2411</span>&#160;                ret                                   = <span class="keyword">false</span>;</div>
<div class="line"><a name="l02412"></a><span class="lineno"> 2412</span>&#160;                whichImprove                          = grIt;</div>
<div class="line"><a name="l02413"></a><span class="lineno"> 2413</span>&#160;                <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l02414"></a><span class="lineno"> 2414</span>&#160;            }</div>
<div class="line"><a name="l02415"></a><span class="lineno"> 2415</span>&#160;        }</div>
<div class="line"><a name="l02416"></a><span class="lineno"> 2416</span>&#160;    }</div>
<div class="line"><a name="l02417"></a><span class="lineno"> 2417</span>&#160;    </div>
<div class="line"><a name="l02418"></a><span class="lineno"> 2418</span>&#160;    <span class="comment">//================================================ Improve, if required</span></div>
<div class="line"><a name="l02419"></a><span class="lineno"> 2419</span>&#160;    <span class="keywordflow">if</span> ( improve &amp;&amp; !ret )</div>
<div class="line"><a name="l02420"></a><span class="lineno"> 2420</span>&#160;    {</div>
<div class="line"><a name="l02421"></a><span class="lineno"> 2421</span>&#160;        CSymList-&gt;at(whichImprove)[1]                 = axis[1];</div>
<div class="line"><a name="l02422"></a><span class="lineno"> 2422</span>&#160;        CSymList-&gt;at(whichImprove)[2]                 = axis[2];</div>
<div class="line"><a name="l02423"></a><span class="lineno"> 2423</span>&#160;        CSymList-&gt;at(whichImprove)[3]                 = axis[3];</div>
<div class="line"><a name="l02424"></a><span class="lineno"> 2424</span>&#160;        CSymList-&gt;at(whichImprove)[4]                 = axis[4];</div>
<div class="line"><a name="l02425"></a><span class="lineno"> 2425</span>&#160;        CSymList-&gt;at(whichImprove)[5]                 = axis[5];</div>
<div class="line"><a name="l02426"></a><span class="lineno"> 2426</span>&#160;    }</div>
<div class="line"><a name="l02427"></a><span class="lineno"> 2427</span>&#160;    </div>
<div class="line"><a name="l02428"></a><span class="lineno"> 2428</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l02429"></a><span class="lineno"> 2429</span>&#160;    <span class="keywordflow">return</span>                                            ( ret );</div>
<div class="line"><a name="l02430"></a><span class="lineno"> 2430</span>&#160;    </div>
<div class="line"><a name="l02431"></a><span class="lineno"> 2431</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a49f093fbdd34498d27a4d8998b620c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f093fbdd34498d27a4d8998b620c91">&#9670;&nbsp;</a></span>isAxisUnique() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_maths::isAxisUnique </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if new axis is unique, or already detected. </p>
<p>This function compares the supplied axis against all members of the axes vector. If the axis has the same fold and very similar axis vector (i.e. all three elements are within tolerance), then the function returns false. If no such match is found, true is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>The axis x-element to be checked against CSymList to see if it not already present. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Y</td><td>The axis x-element to be checked against CSymList to see if it not already present. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Z</td><td>The axis x-element to be checked against CSymList to see if it not already present. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>The allowed error on each dimension of the axis. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>Boolean specifying whether a similar axis was found or not. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l02445">2445</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02446"></a><span class="lineno"> 2446</span>&#160;{</div>
<div class="line"><a name="l02447"></a><span class="lineno"> 2447</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l02448"></a><span class="lineno"> 2448</span>&#160;    <span class="keywordtype">bool</span> ret                                          = <span class="keyword">true</span>;</div>
<div class="line"><a name="l02449"></a><span class="lineno"> 2449</span>&#160;    </div>
<div class="line"><a name="l02450"></a><span class="lineno"> 2450</span>&#160;    <span class="comment">//================================================ For each already detected member</span></div>
<div class="line"><a name="l02451"></a><span class="lineno"> 2451</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign grIt = 0; grIt &lt; static_cast&lt;proshade_unsign&gt; ( CSymList-&gt;size() ); grIt++ )</div>
<div class="line"><a name="l02452"></a><span class="lineno"> 2452</span>&#160;    {</div>
<div class="line"><a name="l02453"></a><span class="lineno"> 2453</span>&#160;        <span class="keywordflow">if</span> ( fold == CSymList-&gt;at(grIt)[0] )</div>
<div class="line"><a name="l02454"></a><span class="lineno"> 2454</span>&#160;        {</div>
<div class="line"><a name="l02455"></a><span class="lineno"> 2455</span>&#160;            <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2b2f67cba1eea57f19fdaf062db74fde">ProSHADE_internal_maths::vectorOrientationSimilarity</a> ( CSymList-&gt;at(grIt)[1], CSymList-&gt;at(grIt)[2], CSymList-&gt;at(grIt)[3], X, Y, Z, tolerance ) )</div>
<div class="line"><a name="l02456"></a><span class="lineno"> 2456</span>&#160;            {</div>
<div class="line"><a name="l02457"></a><span class="lineno"> 2457</span>&#160;                ret                                       = <span class="keyword">false</span>;</div>
<div class="line"><a name="l02458"></a><span class="lineno"> 2458</span>&#160;                <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l02459"></a><span class="lineno"> 2459</span>&#160;            }</div>
<div class="line"><a name="l02460"></a><span class="lineno"> 2460</span>&#160;        }</div>
<div class="line"><a name="l02461"></a><span class="lineno"> 2461</span>&#160;    }</div>
<div class="line"><a name="l02462"></a><span class="lineno"> 2462</span>&#160;    </div>
<div class="line"><a name="l02463"></a><span class="lineno"> 2463</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l02464"></a><span class="lineno"> 2464</span>&#160;    <span class="keywordflow">return</span>                                            ( ret );</div>
<div class="line"><a name="l02465"></a><span class="lineno"> 2465</span>&#160;    </div>
<div class="line"><a name="l02466"></a><span class="lineno"> 2466</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a18222a942e5fff8eecd15f1235c609e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18222a942e5fff8eecd15f1235c609e1">&#9670;&nbsp;</a></span>multiplyGroupElementMatrices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; proshade_double &gt; ProSHADE_internal_maths::multiplyGroupElementMatrices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double &gt; *&#160;</td>
          <td class="paramname"><em>el1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double &gt; *&#160;</td>
          <td class="paramname"><em>el2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes matrix multiplication using the ProSHADE group element matrix format as input and output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">el1</td><td>Group element as rotation matrix in the group element matrix format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">el2</td><td>Group element as rotation matrix in the group element matrix format. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>Matrix in the group element format resulting from the input matrices multiplication. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01925">1925</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01926"></a><span class="lineno"> 1926</span>&#160;{</div>
<div class="line"><a name="l01927"></a><span class="lineno"> 1927</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l01928"></a><span class="lineno"> 1928</span>&#160;    std::vector&lt; proshade_double &gt; ret;</div>
<div class="line"><a name="l01929"></a><span class="lineno"> 1929</span>&#160;    </div>
<div class="line"><a name="l01930"></a><span class="lineno"> 1930</span>&#160;    <span class="comment">//================================================ Compute</span></div>
<div class="line"><a name="l01931"></a><span class="lineno"> 1931</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a>         ( &amp;ret, ( el1-&gt;at(0) * el2-&gt;at(0) ) +</div>
<div class="line"><a name="l01932"></a><span class="lineno"> 1932</span>&#160;                                                              ( el1-&gt;at(1) * el2-&gt;at(3) ) +</div>
<div class="line"><a name="l01933"></a><span class="lineno"> 1933</span>&#160;                                                              ( el1-&gt;at(2) * el2-&gt;at(6) ) );</div>
<div class="line"><a name="l01934"></a><span class="lineno"> 1934</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a>         ( &amp;ret, ( el1-&gt;at(0) * el2-&gt;at(1) ) +</div>
<div class="line"><a name="l01935"></a><span class="lineno"> 1935</span>&#160;                                                              ( el1-&gt;at(1) * el2-&gt;at(4) ) +</div>
<div class="line"><a name="l01936"></a><span class="lineno"> 1936</span>&#160;                                                              ( el1-&gt;at(2) * el2-&gt;at(7) ) );</div>
<div class="line"><a name="l01937"></a><span class="lineno"> 1937</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a>         ( &amp;ret, ( el1-&gt;at(0) * el2-&gt;at(2) ) +</div>
<div class="line"><a name="l01938"></a><span class="lineno"> 1938</span>&#160;                                                              ( el1-&gt;at(1) * el2-&gt;at(5) ) +</div>
<div class="line"><a name="l01939"></a><span class="lineno"> 1939</span>&#160;                                                              ( el1-&gt;at(2) * el2-&gt;at(8) ) );</div>
<div class="line"><a name="l01940"></a><span class="lineno"> 1940</span>&#160;    </div>
<div class="line"><a name="l01941"></a><span class="lineno"> 1941</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a>         ( &amp;ret, ( el1-&gt;at(3) * el2-&gt;at(0) ) +</div>
<div class="line"><a name="l01942"></a><span class="lineno"> 1942</span>&#160;                                                              ( el1-&gt;at(4) * el2-&gt;at(3) ) +</div>
<div class="line"><a name="l01943"></a><span class="lineno"> 1943</span>&#160;                                                              ( el1-&gt;at(5) * el2-&gt;at(6) ) );</div>
<div class="line"><a name="l01944"></a><span class="lineno"> 1944</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a>         ( &amp;ret, ( el1-&gt;at(3) * el2-&gt;at(1) ) +</div>
<div class="line"><a name="l01945"></a><span class="lineno"> 1945</span>&#160;                                                              ( el1-&gt;at(4) * el2-&gt;at(4) ) +</div>
<div class="line"><a name="l01946"></a><span class="lineno"> 1946</span>&#160;                                                              ( el1-&gt;at(5) * el2-&gt;at(7) ) );</div>
<div class="line"><a name="l01947"></a><span class="lineno"> 1947</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a>         ( &amp;ret, ( el1-&gt;at(3) * el2-&gt;at(2) ) +</div>
<div class="line"><a name="l01948"></a><span class="lineno"> 1948</span>&#160;                                                              ( el1-&gt;at(4) * el2-&gt;at(5) ) +</div>
<div class="line"><a name="l01949"></a><span class="lineno"> 1949</span>&#160;                                                              ( el1-&gt;at(5) * el2-&gt;at(8) ) );</div>
<div class="line"><a name="l01950"></a><span class="lineno"> 1950</span>&#160;    </div>
<div class="line"><a name="l01951"></a><span class="lineno"> 1951</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a>         ( &amp;ret, ( el1-&gt;at(6) * el2-&gt;at(0) ) +</div>
<div class="line"><a name="l01952"></a><span class="lineno"> 1952</span>&#160;                                                              ( el1-&gt;at(7) * el2-&gt;at(3) ) +</div>
<div class="line"><a name="l01953"></a><span class="lineno"> 1953</span>&#160;                                                              ( el1-&gt;at(8) * el2-&gt;at(6) ) );</div>
<div class="line"><a name="l01954"></a><span class="lineno"> 1954</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a>         ( &amp;ret, ( el1-&gt;at(6) * el2-&gt;at(1) ) +</div>
<div class="line"><a name="l01955"></a><span class="lineno"> 1955</span>&#160;                                                              ( el1-&gt;at(7) * el2-&gt;at(4) ) +</div>
<div class="line"><a name="l01956"></a><span class="lineno"> 1956</span>&#160;                                                              ( el1-&gt;at(8) * el2-&gt;at(7) ) );</div>
<div class="line"><a name="l01957"></a><span class="lineno"> 1957</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a>         ( &amp;ret, ( el1-&gt;at(6) * el2-&gt;at(2) ) +</div>
<div class="line"><a name="l01958"></a><span class="lineno"> 1958</span>&#160;                                                              ( el1-&gt;at(7) * el2-&gt;at(5) ) +</div>
<div class="line"><a name="l01959"></a><span class="lineno"> 1959</span>&#160;                                                              ( el1-&gt;at(8) * el2-&gt;at(8) ) );</div>
<div class="line"><a name="l01960"></a><span class="lineno"> 1960</span>&#160;    </div>
<div class="line"><a name="l01961"></a><span class="lineno"> 1961</span>&#160;    </div>
<div class="line"><a name="l01962"></a><span class="lineno"> 1962</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01963"></a><span class="lineno"> 1963</span>&#160;    <span class="keywordflow">return</span>                                            ( ret );</div>
<div class="line"><a name="l01964"></a><span class="lineno"> 1964</span>&#160;    </div>
<div class="line"><a name="l01965"></a><span class="lineno"> 1965</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac211e762a46e4c7e25235a651acfdc77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac211e762a46e4c7e25235a651acfdc77">&#9670;&nbsp;</a></span>multiplyTwoSquareMatrices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::multiplyTwoSquareMatrices </td>
          <td>(</td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute matrix multiplication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>The left matrix of the matrix multiplication to be solved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>The right matrix of the matrix multiplication to be solved. (Assuming it already has been transposed). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Matrix containing the results. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>The dimension of all the matrices (i.e. assuming square dim*dim matrices).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function assumes the second matrix has been transposed already! </dd></dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01613">1613</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01614"></a><span class="lineno"> 1614</span>&#160;{</div>
<div class="line"><a name="l01615"></a><span class="lineno"> 1615</span>&#160;    <span class="comment">//================================================ Compute the matrix multiplication</span></div>
<div class="line"><a name="l01616"></a><span class="lineno"> 1616</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign row = 0; row &lt; dim; row++ )</div>
<div class="line"><a name="l01617"></a><span class="lineno"> 1617</span>&#160;    {</div>
<div class="line"><a name="l01618"></a><span class="lineno"> 1618</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign col  = 0; col &lt; dim; col++ )</div>
<div class="line"><a name="l01619"></a><span class="lineno"> 1619</span>&#160;        {</div>
<div class="line"><a name="l01620"></a><span class="lineno"> 1620</span>&#160;            <span class="keywordflow">for</span> ( proshade_unsign inner = 0; inner &lt; dim; inner++ )</div>
<div class="line"><a name="l01621"></a><span class="lineno"> 1621</span>&#160;            {</div>
<div class="line"><a name="l01622"></a><span class="lineno"> 1622</span>&#160;                res[(row*dim)+col]                   += A[(inner*dim)+row] * B[(col*dim)+inner];</div>
<div class="line"><a name="l01623"></a><span class="lineno"> 1623</span>&#160;            }</div>
<div class="line"><a name="l01624"></a><span class="lineno"> 1624</span>&#160;        }</div>
<div class="line"><a name="l01625"></a><span class="lineno"> 1625</span>&#160;    }</div>
<div class="line"><a name="l01626"></a><span class="lineno"> 1626</span>&#160;    </div>
<div class="line"><a name="l01627"></a><span class="lineno"> 1627</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01628"></a><span class="lineno"> 1628</span>&#160;    return ;</div>
<div class="line"><a name="l01629"></a><span class="lineno"> 1629</span>&#160;    </div>
<div class="line"><a name="l01630"></a><span class="lineno"> 1630</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a01087ea3e0db56758d1771618e2e4a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01087ea3e0db56758d1771618e2e4a45">&#9670;&nbsp;</a></span>normalDistributionValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">proshade_double ProSHADE_internal_maths::normalDistributionValue </td>
          <td>(</td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>standardDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to the heiht of normal distribution given by mean and standard deviation for a given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mean</td><td>The mean of the normal distribution. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">standardDev</td><td>The standard deviation of the normal distribution. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value on the axis for which the height of the normal distribution is to be obtained. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>The height of the normal distribution at point given by the value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01685">1685</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01686"></a><span class="lineno"> 1686</span>&#160;{</div>
<div class="line"><a name="l01687"></a><span class="lineno"> 1687</span>&#160;    <span class="comment">//================================================ Compute and return</span></div>
<div class="line"><a name="l01688"></a><span class="lineno"> 1688</span>&#160;    <span class="keywordflow">return</span>                                            ( ( 1.0 / sqrt ( 2.0 * M_PI * pow(standardDev,2.0) ) ) * std::exp ( - pow( value - mean, 2.0 ) / 2.0 * pow(standardDev,2.0) ) );</div>
<div class="line"><a name="l01689"></a><span class="lineno"> 1689</span>&#160;    </div>
<div class="line"><a name="l01690"></a><span class="lineno"> 1690</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a51486f6276c28c1b503f19c36007b9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51486f6276c28c1b503f19c36007b9e2">&#9670;&nbsp;</a></span>optimiseAxisBiCubicInterpolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::optimiseAxisBiCubicInterpolation </td>
          <td>(</td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>bestLattitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>bestLongitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>bestSum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>sphereList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere.html">ProSHADE_internal_spheres::ProSHADE_rotFun_sphere</a> * &gt; *&#160;</td>
          <td class="paramname"><em>sphereMappedRotFun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>step</em> = <code>0.05</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides axis optimisation given starting lattitude and longitude indices. </p>
<p>This function takes the initial lattitude and longitude indices as well as the current best sum over all appropriate spheres and the list of the spheres and proceeds to use bi-cubic interpolation and a sort of gradient ascend algorithm to search the space around the given indices for interpolated values, which would have higher sum of the rotation function values than the initial position. If any improvement is found, it will over-write the input variables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bestLattitude</td><td>Proshade double pointer to variable containing the best lattitude index value and to which the optimised result will be saved into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bestLongitude</td><td>Proshade double pointer to variable containing the best longitude index value and to which the optimised result will be saved into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bestSum</td><td>Proshade double pointer to variable containing the best position rotation function values sum and to which the optimised result will be saved into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sphereList</td><td>A vector containing the list of spheres which form the set for this symmetry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">step</td><td>The size of the step. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l02080">2080</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02081"></a><span class="lineno"> 2081</span>&#160;{</div>
<div class="line"><a name="l02082"></a><span class="lineno"> 2082</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l02083"></a><span class="lineno"> 2083</span>&#160;    proshade_double lonM, lonP, latM, latP, movSum;</div>
<div class="line"><a name="l02084"></a><span class="lineno"> 2084</span>&#160;    std::vector&lt;proshade_double&gt; latVals              ( 3 );</div>
<div class="line"><a name="l02085"></a><span class="lineno"> 2085</span>&#160;    std::vector&lt;proshade_double&gt; lonVals              ( 3 );</div>
<div class="line"><a name="l02086"></a><span class="lineno"> 2086</span>&#160;    proshade_double learningRate                      = 0.1;</div>
<div class="line"><a name="l02087"></a><span class="lineno"> 2087</span>&#160;    proshade_double prevVal                           = *bestSum;</div>
<div class="line"><a name="l02088"></a><span class="lineno"> 2088</span>&#160;    proshade_double valChange                         = 999.9;</div>
<div class="line"><a name="l02089"></a><span class="lineno"> 2089</span>&#160;    proshade_double origBestLat                       = std::round ( *bestLattitude );</div>
<div class="line"><a name="l02090"></a><span class="lineno"> 2090</span>&#160;    proshade_double origBestLon                       = std::round ( *bestLongitude );</div>
<div class="line"><a name="l02091"></a><span class="lineno"> 2091</span>&#160;    proshade_double tmpVal;</div>
<div class="line"><a name="l02092"></a><span class="lineno"> 2092</span>&#160;    </div>
<div class="line"><a name="l02093"></a><span class="lineno"> 2093</span>&#160;    <span class="comment">//================================================ Initialise interpolators in all directions around the point of interest</span></div>
<div class="line"><a name="l02094"></a><span class="lineno"> 2094</span>&#160;    std::vector&lt;ProSHADE_internal_maths::BicubicInterpolator*&gt; interpolsMinusMinus;</div>
<div class="line"><a name="l02095"></a><span class="lineno"> 2095</span>&#160;    std::vector&lt;ProSHADE_internal_maths::BicubicInterpolator*&gt; interpolsMinusPlus;</div>
<div class="line"><a name="l02096"></a><span class="lineno"> 2096</span>&#160;    std::vector&lt;ProSHADE_internal_maths::BicubicInterpolator*&gt; interpolsPlusMinus;</div>
<div class="line"><a name="l02097"></a><span class="lineno"> 2097</span>&#160;    std::vector&lt;ProSHADE_internal_maths::BicubicInterpolator*&gt; interpolsPlusPlus;</div>
<div class="line"><a name="l02098"></a><span class="lineno"> 2098</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#ac027bbd2cde68eb9d677e8b11b90cc2e">prepareBiCubicInterpolatorsMinusMinus</a>             ( std::round ( *bestLattitude ), std::round ( *bestLongitude ), sphereList, &amp;interpolsMinusMinus, sphereMappedRotFun );</div>
<div class="line"><a name="l02099"></a><span class="lineno"> 2099</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a73c2321ffcef5079634493d9bf65749b">prepareBiCubicInterpolatorsMinusPlus</a>              ( std::round ( *bestLattitude ), std::round ( *bestLongitude ), sphereList, &amp;interpolsMinusPlus,  sphereMappedRotFun );</div>
<div class="line"><a name="l02100"></a><span class="lineno"> 2100</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a3f12eb80331377a36ee6b3a4f8e65147">prepareBiCubicInterpolatorsPlusMinus</a>              ( std::round ( *bestLattitude ), std::round ( *bestLongitude ), sphereList, &amp;interpolsPlusMinus,  sphereMappedRotFun );</div>
<div class="line"><a name="l02101"></a><span class="lineno"> 2101</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#ac3b355465dd2244b51e579dcb8669b3a">prepareBiCubicInterpolatorsPlusPlus</a>               ( std::round ( *bestLattitude ), std::round ( *bestLongitude ), sphereList, &amp;interpolsPlusPlus,   sphereMappedRotFun );</div>
<div class="line"><a name="l02102"></a><span class="lineno"> 2102</span>&#160;    </div>
<div class="line"><a name="l02103"></a><span class="lineno"> 2103</span>&#160;    <span class="comment">//================================================ Start the pseudo gradient ascent (while there is some change)</span></div>
<div class="line"><a name="l02104"></a><span class="lineno"> 2104</span>&#160;    <span class="keywordflow">while</span> ( valChange &gt; 0.0001 )</div>
<div class="line"><a name="l02105"></a><span class="lineno"> 2105</span>&#160;    {</div>
<div class="line"><a name="l02106"></a><span class="lineno"> 2106</span>&#160;        <span class="comment">//============================================ Find the surrounding points to the currently best position</span></div>
<div class="line"><a name="l02107"></a><span class="lineno"> 2107</span>&#160;        lonM                                          = *bestLongitude - step;</div>
<div class="line"><a name="l02108"></a><span class="lineno"> 2108</span>&#160;        lonP                                          = *bestLongitude + step;</div>
<div class="line"><a name="l02109"></a><span class="lineno"> 2109</span>&#160;        latM                                          = *bestLattitude - step;</div>
<div class="line"><a name="l02110"></a><span class="lineno"> 2110</span>&#160;        latP                                          = *bestLattitude + step;</div>
<div class="line"><a name="l02111"></a><span class="lineno"> 2111</span>&#160;        </div>
<div class="line"><a name="l02112"></a><span class="lineno"> 2112</span>&#160;        <span class="comment">//============================================ Deal with optimising outside of prepared range - recursion</span></div>
<div class="line"><a name="l02113"></a><span class="lineno"> 2113</span>&#160;        <span class="keywordflow">if</span> ( latM &lt; ( origBestLat - 1.0 ) ) { tmpVal = *bestLattitude; *bestLattitude = origBestLat - 1.0; <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a51486f6276c28c1b503f19c36007b9e2">optimiseAxisBiCubicInterpolation</a> ( bestLattitude, bestLongitude, bestSum, sphereList, sphereMappedRotFun, step ); <span class="keywordflow">if</span> ( *bestLattitude == origBestLat - 1.0 ) { *bestLattitude = tmpVal; } <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l02114"></a><span class="lineno"> 2114</span>&#160;        <span class="keywordflow">if</span> ( latP &gt; ( origBestLat + 1.0 ) ) { tmpVal = *bestLattitude; *bestLattitude = origBestLat + 1.0; <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a51486f6276c28c1b503f19c36007b9e2">optimiseAxisBiCubicInterpolation</a> ( bestLattitude, bestLongitude, bestSum, sphereList, sphereMappedRotFun, step ); <span class="keywordflow">if</span> ( *bestLattitude == origBestLat + 1.0 ) { *bestLattitude = tmpVal; } <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l02115"></a><span class="lineno"> 2115</span>&#160;        <span class="keywordflow">if</span> ( lonM &lt; ( origBestLon - 1.0 ) ) { tmpVal = *bestLongitude; *bestLongitude = origBestLon - 1.0; <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a51486f6276c28c1b503f19c36007b9e2">optimiseAxisBiCubicInterpolation</a> ( bestLattitude, bestLongitude, bestSum, sphereList, sphereMappedRotFun, step ); <span class="keywordflow">if</span> ( *bestLongitude == origBestLon - 1.0 ) { *bestLongitude = tmpVal; } <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l02116"></a><span class="lineno"> 2116</span>&#160;        <span class="keywordflow">if</span> ( lonP &gt; ( origBestLon + 1.0 ) ) { tmpVal = *bestLongitude; *bestLongitude = origBestLon + 1.0; <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a51486f6276c28c1b503f19c36007b9e2">optimiseAxisBiCubicInterpolation</a> ( bestLattitude, bestLongitude, bestSum, sphereList, sphereMappedRotFun, step ); <span class="keywordflow">if</span> ( *bestLongitude == origBestLon + 1.0 ) { *bestLongitude = tmpVal; } <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l02117"></a><span class="lineno"> 2117</span>&#160; </div>
<div class="line"><a name="l02118"></a><span class="lineno"> 2118</span>&#160;        <span class="comment">//============================================ Prepare vectors of tested positions</span></div>
<div class="line"><a name="l02119"></a><span class="lineno"> 2119</span>&#160;        latVals.at(0) = latM; latVals.at(1) = *bestLattitude; latVals.at(2) = latP;</div>
<div class="line"><a name="l02120"></a><span class="lineno"> 2120</span>&#160;        lonVals.at(0) = lonM; lonVals.at(1) = *bestLongitude; lonVals.at(2) = lonP;</div>
<div class="line"><a name="l02121"></a><span class="lineno"> 2121</span>&#160;        </div>
<div class="line"><a name="l02122"></a><span class="lineno"> 2122</span>&#160;        <span class="comment">//============================================ Find the best change</span></div>
<div class="line"><a name="l02123"></a><span class="lineno"> 2123</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign laIt = 0; laIt &lt; static_cast&lt;proshade_unsign&gt; ( latVals.size() ); laIt++ )</div>
<div class="line"><a name="l02124"></a><span class="lineno"> 2124</span>&#160;        {</div>
<div class="line"><a name="l02125"></a><span class="lineno"> 2125</span>&#160;            <span class="keywordflow">for</span> ( proshade_unsign loIt = 0; loIt &lt; static_cast&lt;proshade_unsign&gt; ( lonVals.size() ); loIt++ )</div>
<div class="line"><a name="l02126"></a><span class="lineno"> 2126</span>&#160;            {</div>
<div class="line"><a name="l02127"></a><span class="lineno"> 2127</span>&#160;                <span class="comment">//==================================== For this combination of lat and lon, find sum over spheres</span></div>
<div class="line"><a name="l02128"></a><span class="lineno"> 2128</span>&#160;                movSum                                = 1.0;</div>
<div class="line"><a name="l02129"></a><span class="lineno"> 2129</span>&#160;                <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; static_cast&lt;proshade_unsign&gt; ( sphereList-&gt;size() ); iter++ )</div>
<div class="line"><a name="l02130"></a><span class="lineno"> 2130</span>&#160;                {</div>
<div class="line"><a name="l02131"></a><span class="lineno"> 2131</span>&#160;                    <span class="comment">//================================ Interpolate using correct interpolators</span></div>
<div class="line"><a name="l02132"></a><span class="lineno"> 2132</span>&#160;                    <span class="keywordflow">if</span> ( ( latVals.at(laIt) &lt;= origBestLat ) &amp;&amp; ( lonVals.at(loIt) &lt;= origBestLon ) ) { movSum += interpolsMinusMinus.at(iter)-&gt;getValue ( latVals.at(laIt), lonVals.at(loIt) ); }</div>
<div class="line"><a name="l02133"></a><span class="lineno"> 2133</span>&#160;                    <span class="keywordflow">if</span> ( ( latVals.at(laIt) &lt;= origBestLat ) &amp;&amp; ( lonVals.at(loIt) &gt;  origBestLon ) ) { movSum += interpolsMinusPlus.at(iter)-&gt;getValue  ( latVals.at(laIt), lonVals.at(loIt) ); }</div>
<div class="line"><a name="l02134"></a><span class="lineno"> 2134</span>&#160;                    <span class="keywordflow">if</span> ( ( latVals.at(laIt) &gt;  origBestLat ) &amp;&amp; ( lonVals.at(loIt) &lt;= origBestLon ) ) { movSum += interpolsPlusMinus.at(iter)-&gt;getValue  ( latVals.at(laIt), lonVals.at(loIt) ); }</div>
<div class="line"><a name="l02135"></a><span class="lineno"> 2135</span>&#160;                    <span class="keywordflow">if</span> ( ( latVals.at(laIt) &gt;  origBestLat ) &amp;&amp; ( lonVals.at(loIt) &gt;  origBestLon ) ) { movSum += interpolsPlusPlus.at(iter)-&gt;getValue   ( latVals.at(laIt), lonVals.at(loIt) ); }</div>
<div class="line"><a name="l02136"></a><span class="lineno"> 2136</span>&#160;                }</div>
<div class="line"><a name="l02137"></a><span class="lineno"> 2137</span>&#160;                </div>
<div class="line"><a name="l02138"></a><span class="lineno"> 2138</span>&#160;                <span class="comment">//==================================== If position has improved, save it</span></div>
<div class="line"><a name="l02139"></a><span class="lineno"> 2139</span>&#160;                <span class="keywordflow">if</span> ( *bestSum &lt; movSum )</div>
<div class="line"><a name="l02140"></a><span class="lineno"> 2140</span>&#160;                {</div>
<div class="line"><a name="l02141"></a><span class="lineno"> 2141</span>&#160;                   *bestSum                           = movSum;</div>
<div class="line"><a name="l02142"></a><span class="lineno"> 2142</span>&#160;                   *bestLongitude                     = lonVals.at(loIt);</div>
<div class="line"><a name="l02143"></a><span class="lineno"> 2143</span>&#160;                   *bestLattitude                     = latVals.at(laIt);</div>
<div class="line"><a name="l02144"></a><span class="lineno"> 2144</span>&#160;                }</div>
<div class="line"><a name="l02145"></a><span class="lineno"> 2145</span>&#160;            }</div>
<div class="line"><a name="l02146"></a><span class="lineno"> 2146</span>&#160;        }</div>
<div class="line"><a name="l02147"></a><span class="lineno"> 2147</span>&#160;        </div>
<div class="line"><a name="l02148"></a><span class="lineno"> 2148</span>&#160;        <span class="comment">//============================================ Prepare for next iteration</span></div>
<div class="line"><a name="l02149"></a><span class="lineno"> 2149</span>&#160;        valChange                                     = std::floor ( 100000.0 * ( *bestSum - prevVal ) ) / 100000.0;</div>
<div class="line"><a name="l02150"></a><span class="lineno"> 2150</span>&#160;        prevVal                                       = std::floor ( 100000.0 * ( *bestSum           ) ) / 100000.0;</div>
<div class="line"><a name="l02151"></a><span class="lineno"> 2151</span>&#160;        step                                          = std::max ( ( valChange / step ) * learningRate, 0.01 );</div>
<div class="line"><a name="l02152"></a><span class="lineno"> 2152</span>&#160;        <span class="keywordflow">if</span> ( learningRate &gt;= 0.02 ) { learningRate -= 0.01; }</div>
<div class="line"><a name="l02153"></a><span class="lineno"> 2153</span>&#160;        </div>
<div class="line"><a name="l02154"></a><span class="lineno"> 2154</span>&#160;    }</div>
<div class="line"><a name="l02155"></a><span class="lineno"> 2155</span>&#160;    </div>
<div class="line"><a name="l02156"></a><span class="lineno"> 2156</span>&#160;    <span class="comment">//================================================ Release interpolators memory</span></div>
<div class="line"><a name="l02157"></a><span class="lineno"> 2157</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign intIt = 0; intIt &lt; static_cast&lt;proshade_unsign&gt; ( interpolsMinusMinus.size() ); intIt++ ) { <span class="keyword">delete</span> interpolsMinusMinus.at(intIt); }</div>
<div class="line"><a name="l02158"></a><span class="lineno"> 2158</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign intIt = 0; intIt &lt; static_cast&lt;proshade_unsign&gt; ( interpolsMinusPlus.size()  ); intIt++ ) { <span class="keyword">delete</span> interpolsMinusPlus.at(intIt);  }</div>
<div class="line"><a name="l02159"></a><span class="lineno"> 2159</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign intIt = 0; intIt &lt; static_cast&lt;proshade_unsign&gt; ( interpolsPlusMinus.size()  ); intIt++ ) { <span class="keyword">delete</span> interpolsPlusMinus.at(intIt);  }</div>
<div class="line"><a name="l02160"></a><span class="lineno"> 2160</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign intIt = 0; intIt &lt; static_cast&lt;proshade_unsign&gt; ( interpolsPlusPlus.size()   ); intIt++ ) { <span class="keyword">delete</span> interpolsPlusPlus.at(intIt);   }</div>
<div class="line"><a name="l02161"></a><span class="lineno"> 2161</span>&#160;    </div>
<div class="line"><a name="l02162"></a><span class="lineno"> 2162</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l02163"></a><span class="lineno"> 2163</span>&#160;    return ;</div>
<div class="line"><a name="l02164"></a><span class="lineno"> 2164</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a894d87e94446db04492b663e54a74bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a894d87e94446db04492b663e54a74bff">&#9670;&nbsp;</a></span>pearsonCorrCoeff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">proshade_double ProSHADE_internal_maths::pearsonCorrCoeff </td>
          <td>(</td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>valSet1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>valSet2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for computing the Pearson's correlation coefficient. </p>
<p>This function takes two numerical arrays of same length and proceeds to compute the Pearson's correlation coefficient, which it then returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">valSet1</td><td>This is the set of x-values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valSet2</td><td>This is the set of y-values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length of both arrays (both arrays have to have the same length). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>The Pearson's correlation coefficient value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00244">244</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;{</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;    <span class="comment">//================================================ Find vector means</span></div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;    proshade_double xMean                             = 0.0;</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    proshade_double yMean                             = 0.0;</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;    proshade_double zeroCount                         = 0.0;</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; length; iter++ )</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;    {</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;        xMean                                        += valSet1[iter];</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;        yMean                                        += valSet2[iter];</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;    }</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;    xMean                                            /= <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( length - zeroCount );</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;    yMean                                            /= <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( length - zeroCount );</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;    </div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;    <span class="comment">//================================================ Get Pearson&#39;s correlation coefficient</span></div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;    proshade_double xmmymm                            = 0.0;</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;    proshade_double xmmsq                             = 0.0;</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;    proshade_double ymmsq                             = 0.0;</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; length; iter++ )</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;    {</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;        xmmymm                                       += ( valSet1[iter] - xMean ) * ( valSet2[iter] - yMean );</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;        xmmsq                                        += pow( valSet1[iter] - xMean, 2.0 );</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;        ymmsq                                        += pow( valSet2[iter] - yMean, 2.0 );</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;    }</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;    </div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;    proshade_double ret                               = xmmymm / ( sqrt(xmmsq) * sqrt(ymmsq) );</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    </div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    <span class="keywordflow">if</span> ( std::isnan ( ret ) ) { <span class="keywordflow">return</span> ( 0.0 ); }</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;    <span class="keywordflow">return</span>                                            ( ret );</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    </div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac027bbd2cde68eb9d677e8b11b90cc2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac027bbd2cde68eb9d677e8b11b90cc2e">&#9670;&nbsp;</a></span>prepareBiCubicInterpolatorsMinusMinus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::prepareBiCubicInterpolatorsMinusMinus </td>
          <td>(</td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>bestLattitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>bestLongitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>sphereList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__maths_1_1_bicubic_interpolator.html">ProSHADE_internal_maths::BicubicInterpolator</a> * &gt; *&#160;</td>
          <td class="paramname"><em>interpols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere.html">ProSHADE_internal_spheres::ProSHADE_rotFun_sphere</a> * &gt; *&#160;</td>
          <td class="paramname"><em>sphereMappedRotFun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function prepares the interpolation objects for the bi-cubic interpolation. </p>
<p>This function takes the position around which the interpolation is to be done and proceeds to create the interpolator objects for bi-cubic interpolation in the &ndash; direction (i.e. when both interpolated values will be lower than the best lattitude and longitude) using the correct spheres in the correct ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bestLattitude</td><td>The lattitude index value around which interpolation is to be prepared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bestLongitude</td><td>The longitude index value around which interpolation is to be prepared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sphereList</td><td>A vector containing the list of spheres which form the set for this symmetry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interpols</td><td>A pointer to a vector of ProSHADE interpolator objects to which the interpolators will be saved into. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l02177">2177</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02178"></a><span class="lineno"> 2178</span>&#160;{</div>
<div class="line"><a name="l02179"></a><span class="lineno"> 2179</span>&#160;    <span class="comment">//================================================ Initialise local variables</span></div>
<div class="line"><a name="l02180"></a><span class="lineno"> 2180</span>&#160;    proshade_signed latHlp, lonHlp;</div>
<div class="line"><a name="l02181"></a><span class="lineno"> 2181</span>&#160;    proshade_signed angDim                            = sphereMappedRotFun-&gt;at(0)-&gt;getAngularDim();</div>
<div class="line"><a name="l02182"></a><span class="lineno"> 2182</span>&#160;    </div>
<div class="line"><a name="l02183"></a><span class="lineno"> 2183</span>&#160;    <span class="comment">//================================================ Prepare the interpolator objects for interpolation around the position</span></div>
<div class="line"><a name="l02184"></a><span class="lineno"> 2184</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign sphereIt = 0; sphereIt &lt; static_cast&lt;proshade_unsign&gt; ( sphereList-&gt;size() ); sphereIt++ )</div>
<div class="line"><a name="l02185"></a><span class="lineno"> 2185</span>&#160;    {</div>
<div class="line"><a name="l02186"></a><span class="lineno"> 2186</span>&#160;        <span class="comment">//============================================ Allocate memory for the value grid on which the interpolation is to be done (along first dimension)</span></div>
<div class="line"><a name="l02187"></a><span class="lineno"> 2187</span>&#160;        proshade_double** interpGrid                  = <span class="keyword">new</span> proshade_double*[4];</div>
<div class="line"><a name="l02188"></a><span class="lineno"> 2188</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a> ( interpGrid, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l02189"></a><span class="lineno"> 2189</span>&#160; </div>
<div class="line"><a name="l02190"></a><span class="lineno"> 2190</span>&#160;        <span class="comment">//============================================ Allocate memory for the value grid on which the interpolation is to be done (along second dimension)</span></div>
<div class="line"><a name="l02191"></a><span class="lineno"> 2191</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; 4; iter++ )</div>
<div class="line"><a name="l02192"></a><span class="lineno"> 2192</span>&#160;        {</div>
<div class="line"><a name="l02193"></a><span class="lineno"> 2193</span>&#160;            interpGrid[iter]                          = <span class="keyword">new</span> proshade_double[4];</div>
<div class="line"><a name="l02194"></a><span class="lineno"> 2194</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a> ( interpGrid[iter], __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l02195"></a><span class="lineno"> 2195</span>&#160;        }</div>
<div class="line"><a name="l02196"></a><span class="lineno"> 2196</span>&#160; </div>
<div class="line"><a name="l02197"></a><span class="lineno"> 2197</span>&#160;        <span class="comment">//============================================ Fill in the value grid on which the interpolation is to be done</span></div>
<div class="line"><a name="l02198"></a><span class="lineno"> 2198</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign latIt = 0; latIt &lt; 4; latIt++ )</div>
<div class="line"><a name="l02199"></a><span class="lineno"> 2199</span>&#160;        {</div>
<div class="line"><a name="l02200"></a><span class="lineno"> 2200</span>&#160;            <span class="keywordflow">for</span> ( proshade_unsign lonIt = 0; lonIt &lt; 4; lonIt++ )</div>
<div class="line"><a name="l02201"></a><span class="lineno"> 2201</span>&#160;            {</div>
<div class="line"><a name="l02202"></a><span class="lineno"> 2202</span>&#160;                latHlp = bestLattitude - 2 + latIt; <span class="keywordflow">if</span> ( latHlp &lt; 0.0 ) { latHlp += angDim; } <span class="keywordflow">if</span> ( latHlp &gt;= angDim ) { latHlp -= angDim; }</div>
<div class="line"><a name="l02203"></a><span class="lineno"> 2203</span>&#160;                lonHlp = bestLongitude - 2 + lonIt; <span class="keywordflow">if</span> ( lonHlp &lt; 0.0 ) { lonHlp += angDim; } <span class="keywordflow">if</span> ( lonHlp &gt;= angDim ) { lonHlp -= angDim; }</div>
<div class="line"><a name="l02204"></a><span class="lineno"> 2204</span>&#160;                interpGrid[latIt][lonIt]              = sphereMappedRotFun-&gt;at(sphereList-&gt;at(sphereIt))-&gt;getSphereLatLonPosition ( latHlp, lonHlp );</div>
<div class="line"><a name="l02205"></a><span class="lineno"> 2205</span>&#160;            }</div>
<div class="line"><a name="l02206"></a><span class="lineno"> 2206</span>&#160;        }</div>
<div class="line"><a name="l02207"></a><span class="lineno"> 2207</span>&#160; </div>
<div class="line"><a name="l02208"></a><span class="lineno"> 2208</span>&#160;        <span class="comment">//============================================ Create the interpolators</span></div>
<div class="line"><a name="l02209"></a><span class="lineno"> 2209</span>&#160;        <a class="code" href="class_pro_s_h_a_d_e__internal__maths_1_1_bicubic_interpolator.html">ProSHADE_internal_maths::BicubicInterpolator</a>* biCubInterp = <span class="keyword">new</span> <a class="code" href="class_pro_s_h_a_d_e__internal__maths_1_1_bicubic_interpolator.html">ProSHADE_internal_maths::BicubicInterpolator</a> ( interpGrid, bestLattitude - 1.0, bestLongitude - 1.0 );</div>
<div class="line"><a name="l02210"></a><span class="lineno"> 2210</span>&#160;        interpols-&gt;emplace_back                       ( biCubInterp );</div>
<div class="line"><a name="l02211"></a><span class="lineno"> 2211</span>&#160;        </div>
<div class="line"><a name="l02212"></a><span class="lineno"> 2212</span>&#160;        <span class="comment">//============================================ Release memory</span></div>
<div class="line"><a name="l02213"></a><span class="lineno"> 2213</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; 4; iter++ ) { <span class="keyword">delete</span>[] interpGrid[iter]; }</div>
<div class="line"><a name="l02214"></a><span class="lineno"> 2214</span>&#160;        <span class="keyword">delete</span>[] interpGrid;</div>
<div class="line"><a name="l02215"></a><span class="lineno"> 2215</span>&#160;    }</div>
<div class="line"><a name="l02216"></a><span class="lineno"> 2216</span>&#160;    </div>
<div class="line"><a name="l02217"></a><span class="lineno"> 2217</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l02218"></a><span class="lineno"> 2218</span>&#160;    return ;</div>
<div class="line"><a name="l02219"></a><span class="lineno"> 2219</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a73c2321ffcef5079634493d9bf65749b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73c2321ffcef5079634493d9bf65749b">&#9670;&nbsp;</a></span>prepareBiCubicInterpolatorsMinusPlus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::prepareBiCubicInterpolatorsMinusPlus </td>
          <td>(</td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>bestLattitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>bestLongitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>sphereList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__maths_1_1_bicubic_interpolator.html">ProSHADE_internal_maths::BicubicInterpolator</a> * &gt; *&#160;</td>
          <td class="paramname"><em>interpols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere.html">ProSHADE_internal_spheres::ProSHADE_rotFun_sphere</a> * &gt; *&#160;</td>
          <td class="paramname"><em>sphereMappedRotFun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function prepares the interpolation objects for the bi-cubic interpolation. </p>
<p>This function takes the position around which the interpolation is to be done and proceeds to create the interpolator objects for bi-cubic interpolation in the -+ direction (i.e. when interpolated lattitude is lower than best lattitude, but interpolated longitude is higher than best longitude) using the correct spheres in the correct ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bestLattitude</td><td>The lattitude index value around which interpolation is to be prepared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bestLongitude</td><td>The longitude index value around which interpolation is to be prepared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sphereList</td><td>A vector containing the list of spheres which form the set for this symmetry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interpols</td><td>A pointer to a vector of ProSHADE interpolator objects to which the interpolators will be saved into. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l02232">2232</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02233"></a><span class="lineno"> 2233</span>&#160;{</div>
<div class="line"><a name="l02234"></a><span class="lineno"> 2234</span>&#160;    <span class="comment">//================================================ Initialise local variables</span></div>
<div class="line"><a name="l02235"></a><span class="lineno"> 2235</span>&#160;    proshade_signed latHlp, lonHlp;</div>
<div class="line"><a name="l02236"></a><span class="lineno"> 2236</span>&#160;    proshade_signed angDim                            = sphereMappedRotFun-&gt;at(0)-&gt;getAngularDim();</div>
<div class="line"><a name="l02237"></a><span class="lineno"> 2237</span>&#160;    </div>
<div class="line"><a name="l02238"></a><span class="lineno"> 2238</span>&#160;    <span class="comment">//================================================ Prepare the interpolator objects for interpolation around the position</span></div>
<div class="line"><a name="l02239"></a><span class="lineno"> 2239</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign sphereIt = 0; sphereIt &lt; static_cast&lt;proshade_unsign&gt; ( sphereList-&gt;size() ); sphereIt++ )</div>
<div class="line"><a name="l02240"></a><span class="lineno"> 2240</span>&#160;    {</div>
<div class="line"><a name="l02241"></a><span class="lineno"> 2241</span>&#160;        <span class="comment">//============================================ Allocate memory for the value grid on which the interpolation is to be done (along first dimension)</span></div>
<div class="line"><a name="l02242"></a><span class="lineno"> 2242</span>&#160;        proshade_double** interpGrid                  = <span class="keyword">new</span> proshade_double*[4];</div>
<div class="line"><a name="l02243"></a><span class="lineno"> 2243</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a> ( interpGrid, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l02244"></a><span class="lineno"> 2244</span>&#160; </div>
<div class="line"><a name="l02245"></a><span class="lineno"> 2245</span>&#160;        <span class="comment">//============================================ Allocate memory for the value grid on which the interpolation is to be done (along second dimension)</span></div>
<div class="line"><a name="l02246"></a><span class="lineno"> 2246</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; 4; iter++ )</div>
<div class="line"><a name="l02247"></a><span class="lineno"> 2247</span>&#160;        {</div>
<div class="line"><a name="l02248"></a><span class="lineno"> 2248</span>&#160;            interpGrid[iter]                          = <span class="keyword">new</span> proshade_double[4];</div>
<div class="line"><a name="l02249"></a><span class="lineno"> 2249</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a> ( interpGrid[iter], __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l02250"></a><span class="lineno"> 2250</span>&#160;        }</div>
<div class="line"><a name="l02251"></a><span class="lineno"> 2251</span>&#160; </div>
<div class="line"><a name="l02252"></a><span class="lineno"> 2252</span>&#160;        <span class="comment">//============================================ Fill in the value grid on which the interpolation is to be done</span></div>
<div class="line"><a name="l02253"></a><span class="lineno"> 2253</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign latIt = 0; latIt &lt; 4; latIt++ )</div>
<div class="line"><a name="l02254"></a><span class="lineno"> 2254</span>&#160;        {</div>
<div class="line"><a name="l02255"></a><span class="lineno"> 2255</span>&#160;            <span class="keywordflow">for</span> ( proshade_unsign lonIt = 0; lonIt &lt; 4; lonIt++ )</div>
<div class="line"><a name="l02256"></a><span class="lineno"> 2256</span>&#160;            {</div>
<div class="line"><a name="l02257"></a><span class="lineno"> 2257</span>&#160;                latHlp = bestLattitude - 2 + latIt; <span class="keywordflow">if</span> ( latHlp &lt; 0.0 ) { latHlp += angDim; } <span class="keywordflow">if</span> ( latHlp &gt;= angDim ) { latHlp -= angDim; }</div>
<div class="line"><a name="l02258"></a><span class="lineno"> 2258</span>&#160;                lonHlp = bestLongitude - 1 + lonIt; <span class="keywordflow">if</span> ( lonHlp &lt; 0.0 ) { lonHlp += angDim; } <span class="keywordflow">if</span> ( lonHlp &gt;= angDim ) { lonHlp -= angDim; }</div>
<div class="line"><a name="l02259"></a><span class="lineno"> 2259</span>&#160;                interpGrid[latIt][lonIt]              = sphereMappedRotFun-&gt;at(sphereList-&gt;at(sphereIt))-&gt;getSphereLatLonPosition ( latHlp, lonHlp );</div>
<div class="line"><a name="l02260"></a><span class="lineno"> 2260</span>&#160;            }</div>
<div class="line"><a name="l02261"></a><span class="lineno"> 2261</span>&#160;        }</div>
<div class="line"><a name="l02262"></a><span class="lineno"> 2262</span>&#160; </div>
<div class="line"><a name="l02263"></a><span class="lineno"> 2263</span>&#160;        <span class="comment">//============================================ Create the interpolators</span></div>
<div class="line"><a name="l02264"></a><span class="lineno"> 2264</span>&#160;        <a class="code" href="class_pro_s_h_a_d_e__internal__maths_1_1_bicubic_interpolator.html">ProSHADE_internal_maths::BicubicInterpolator</a>* biCubInterp = <span class="keyword">new</span> <a class="code" href="class_pro_s_h_a_d_e__internal__maths_1_1_bicubic_interpolator.html">ProSHADE_internal_maths::BicubicInterpolator</a> ( interpGrid, bestLattitude - 1.0, bestLongitude );</div>
<div class="line"><a name="l02265"></a><span class="lineno"> 2265</span>&#160;        interpols-&gt;emplace_back                       ( biCubInterp );</div>
<div class="line"><a name="l02266"></a><span class="lineno"> 2266</span>&#160;        </div>
<div class="line"><a name="l02267"></a><span class="lineno"> 2267</span>&#160;        <span class="comment">//============================================ Release memory</span></div>
<div class="line"><a name="l02268"></a><span class="lineno"> 2268</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; 4; iter++ ) { <span class="keyword">delete</span>[] interpGrid[iter]; }</div>
<div class="line"><a name="l02269"></a><span class="lineno"> 2269</span>&#160;        <span class="keyword">delete</span>[] interpGrid;</div>
<div class="line"><a name="l02270"></a><span class="lineno"> 2270</span>&#160;    }</div>
<div class="line"><a name="l02271"></a><span class="lineno"> 2271</span>&#160;    </div>
<div class="line"><a name="l02272"></a><span class="lineno"> 2272</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l02273"></a><span class="lineno"> 2273</span>&#160;    return ;</div>
<div class="line"><a name="l02274"></a><span class="lineno"> 2274</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3f12eb80331377a36ee6b3a4f8e65147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f12eb80331377a36ee6b3a4f8e65147">&#9670;&nbsp;</a></span>prepareBiCubicInterpolatorsPlusMinus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::prepareBiCubicInterpolatorsPlusMinus </td>
          <td>(</td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>bestLattitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>bestLongitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>sphereList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__maths_1_1_bicubic_interpolator.html">ProSHADE_internal_maths::BicubicInterpolator</a> * &gt; *&#160;</td>
          <td class="paramname"><em>interpols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere.html">ProSHADE_internal_spheres::ProSHADE_rotFun_sphere</a> * &gt; *&#160;</td>
          <td class="paramname"><em>sphereMappedRotFun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function prepares the interpolation objects for the bi-cubic interpolation. </p>
<p>This function takes the position around which the interpolation is to be done and proceeds to create the interpolator objects for bi-cubic interpolation in the +- direction (i.e. when interpolated lattitude is higher than best lattitude, but interpolated longitude is lower than best longitude) using the correct spheres in the correct ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bestLattitude</td><td>The lattitude index value around which interpolation is to be prepared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bestLongitude</td><td>The longitude index value around which interpolation is to be prepared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sphereList</td><td>A vector containing the list of spheres which form the set for this symmetry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interpols</td><td>A pointer to a vector of ProSHADE interpolator objects to which the interpolators will be saved into. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l02287">2287</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02288"></a><span class="lineno"> 2288</span>&#160;{</div>
<div class="line"><a name="l02289"></a><span class="lineno"> 2289</span>&#160;    <span class="comment">//================================================ Initialise local variables</span></div>
<div class="line"><a name="l02290"></a><span class="lineno"> 2290</span>&#160;    proshade_signed latHlp, lonHlp;</div>
<div class="line"><a name="l02291"></a><span class="lineno"> 2291</span>&#160;    proshade_signed angDim                            = sphereMappedRotFun-&gt;at(0)-&gt;getAngularDim();</div>
<div class="line"><a name="l02292"></a><span class="lineno"> 2292</span>&#160;    </div>
<div class="line"><a name="l02293"></a><span class="lineno"> 2293</span>&#160;    <span class="comment">//================================================ Prepare the interpolator objects for interpolation around the position</span></div>
<div class="line"><a name="l02294"></a><span class="lineno"> 2294</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign sphereIt = 0; sphereIt &lt; static_cast&lt;proshade_unsign&gt; ( sphereList-&gt;size() ); sphereIt++ )</div>
<div class="line"><a name="l02295"></a><span class="lineno"> 2295</span>&#160;    {</div>
<div class="line"><a name="l02296"></a><span class="lineno"> 2296</span>&#160;        <span class="comment">//============================================ Allocate memory for the value grid on which the interpolation is to be done (along first dimension)</span></div>
<div class="line"><a name="l02297"></a><span class="lineno"> 2297</span>&#160;        proshade_double** interpGrid                  = <span class="keyword">new</span> proshade_double*[4];</div>
<div class="line"><a name="l02298"></a><span class="lineno"> 2298</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a> ( interpGrid, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l02299"></a><span class="lineno"> 2299</span>&#160; </div>
<div class="line"><a name="l02300"></a><span class="lineno"> 2300</span>&#160;        <span class="comment">//============================================ Allocate memory for the value grid on which the interpolation is to be done (along second dimension)</span></div>
<div class="line"><a name="l02301"></a><span class="lineno"> 2301</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; 4; iter++ )</div>
<div class="line"><a name="l02302"></a><span class="lineno"> 2302</span>&#160;        {</div>
<div class="line"><a name="l02303"></a><span class="lineno"> 2303</span>&#160;            interpGrid[iter]                          = <span class="keyword">new</span> proshade_double[4];</div>
<div class="line"><a name="l02304"></a><span class="lineno"> 2304</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a> ( interpGrid[iter], __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l02305"></a><span class="lineno"> 2305</span>&#160;        }</div>
<div class="line"><a name="l02306"></a><span class="lineno"> 2306</span>&#160; </div>
<div class="line"><a name="l02307"></a><span class="lineno"> 2307</span>&#160;        <span class="comment">//============================================ Fill in the value grid on which the interpolation is to be done</span></div>
<div class="line"><a name="l02308"></a><span class="lineno"> 2308</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign latIt = 0; latIt &lt; 4; latIt++ )</div>
<div class="line"><a name="l02309"></a><span class="lineno"> 2309</span>&#160;        {</div>
<div class="line"><a name="l02310"></a><span class="lineno"> 2310</span>&#160;            <span class="keywordflow">for</span> ( proshade_unsign lonIt = 0; lonIt &lt; 4; lonIt++ )</div>
<div class="line"><a name="l02311"></a><span class="lineno"> 2311</span>&#160;            {</div>
<div class="line"><a name="l02312"></a><span class="lineno"> 2312</span>&#160;                latHlp = bestLattitude - 1 + latIt; <span class="keywordflow">if</span> ( latHlp &lt; 0.0 ) { latHlp += angDim; } <span class="keywordflow">if</span> ( latHlp &gt;= angDim ) { latHlp -= angDim; }</div>
<div class="line"><a name="l02313"></a><span class="lineno"> 2313</span>&#160;                lonHlp = bestLongitude - 2 + lonIt; <span class="keywordflow">if</span> ( lonHlp &lt; 0.0 ) { lonHlp += angDim; } <span class="keywordflow">if</span> ( lonHlp &gt;= angDim ) { lonHlp -= angDim; }</div>
<div class="line"><a name="l02314"></a><span class="lineno"> 2314</span>&#160;                interpGrid[latIt][lonIt]              = sphereMappedRotFun-&gt;at(sphereList-&gt;at(sphereIt))-&gt;getSphereLatLonPosition ( latHlp, lonHlp );</div>
<div class="line"><a name="l02315"></a><span class="lineno"> 2315</span>&#160;            }</div>
<div class="line"><a name="l02316"></a><span class="lineno"> 2316</span>&#160;        }</div>
<div class="line"><a name="l02317"></a><span class="lineno"> 2317</span>&#160; </div>
<div class="line"><a name="l02318"></a><span class="lineno"> 2318</span>&#160;        <span class="comment">//============================================ Create the interpolators</span></div>
<div class="line"><a name="l02319"></a><span class="lineno"> 2319</span>&#160;        <a class="code" href="class_pro_s_h_a_d_e__internal__maths_1_1_bicubic_interpolator.html">ProSHADE_internal_maths::BicubicInterpolator</a>* biCubInterp = <span class="keyword">new</span> <a class="code" href="class_pro_s_h_a_d_e__internal__maths_1_1_bicubic_interpolator.html">ProSHADE_internal_maths::BicubicInterpolator</a> ( interpGrid, bestLattitude, bestLongitude - 1.0 );</div>
<div class="line"><a name="l02320"></a><span class="lineno"> 2320</span>&#160;        interpols-&gt;emplace_back                       ( biCubInterp );</div>
<div class="line"><a name="l02321"></a><span class="lineno"> 2321</span>&#160;        </div>
<div class="line"><a name="l02322"></a><span class="lineno"> 2322</span>&#160;        <span class="comment">//============================================ Release memory</span></div>
<div class="line"><a name="l02323"></a><span class="lineno"> 2323</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; 4; iter++ ) { <span class="keyword">delete</span>[] interpGrid[iter]; }</div>
<div class="line"><a name="l02324"></a><span class="lineno"> 2324</span>&#160;        <span class="keyword">delete</span>[] interpGrid;</div>
<div class="line"><a name="l02325"></a><span class="lineno"> 2325</span>&#160;    }</div>
<div class="line"><a name="l02326"></a><span class="lineno"> 2326</span>&#160;    </div>
<div class="line"><a name="l02327"></a><span class="lineno"> 2327</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l02328"></a><span class="lineno"> 2328</span>&#160;    return ;</div>
<div class="line"><a name="l02329"></a><span class="lineno"> 2329</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac3b355465dd2244b51e579dcb8669b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b355465dd2244b51e579dcb8669b3a">&#9670;&nbsp;</a></span>prepareBiCubicInterpolatorsPlusPlus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::prepareBiCubicInterpolatorsPlusPlus </td>
          <td>(</td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>bestLattitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>bestLongitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>sphereList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__maths_1_1_bicubic_interpolator.html">ProSHADE_internal_maths::BicubicInterpolator</a> * &gt; *&#160;</td>
          <td class="paramname"><em>interpols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere.html">ProSHADE_internal_spheres::ProSHADE_rotFun_sphere</a> * &gt; *&#160;</td>
          <td class="paramname"><em>sphereMappedRotFun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function prepares the interpolation objects for the bi-cubic interpolation. </p>
<p>This function takes the position around which the interpolation is to be done and proceeds to create the interpolator objects for bi-cubic interpolation in the ++ direction (i.e. when both interpolated values will be larger than the best lattitude and longitude) using the correct spheres in the correct ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bestLattitude</td><td>The lattitude index value around which interpolation is to be prepared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bestLongitude</td><td>The longitude index value around which interpolation is to be prepared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sphereList</td><td>A vector containing the list of spheres which form the set for this symmetry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interpols</td><td>A pointer to a vector of ProSHADE interpolator objects to which the interpolators will be saved into. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l02342">2342</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02343"></a><span class="lineno"> 2343</span>&#160;{</div>
<div class="line"><a name="l02344"></a><span class="lineno"> 2344</span>&#160;    <span class="comment">//================================================ Initialise local variables</span></div>
<div class="line"><a name="l02345"></a><span class="lineno"> 2345</span>&#160;    proshade_signed latHlp, lonHlp;</div>
<div class="line"><a name="l02346"></a><span class="lineno"> 2346</span>&#160;    proshade_signed angDim                            = sphereMappedRotFun-&gt;at(0)-&gt;getAngularDim();</div>
<div class="line"><a name="l02347"></a><span class="lineno"> 2347</span>&#160;    </div>
<div class="line"><a name="l02348"></a><span class="lineno"> 2348</span>&#160;    <span class="comment">//================================================ Prepare the interpolator objects for interpolation around the position</span></div>
<div class="line"><a name="l02349"></a><span class="lineno"> 2349</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign sphereIt = 0; sphereIt &lt; static_cast&lt;proshade_unsign&gt; ( sphereList-&gt;size() ); sphereIt++ )</div>
<div class="line"><a name="l02350"></a><span class="lineno"> 2350</span>&#160;    {</div>
<div class="line"><a name="l02351"></a><span class="lineno"> 2351</span>&#160;        <span class="comment">//============================================ Allocate memory for the value grid on which the interpolation is to be done (along first dimension)</span></div>
<div class="line"><a name="l02352"></a><span class="lineno"> 2352</span>&#160;        proshade_double** interpGrid                  = <span class="keyword">new</span> proshade_double*[4];</div>
<div class="line"><a name="l02353"></a><span class="lineno"> 2353</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a> ( interpGrid, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l02354"></a><span class="lineno"> 2354</span>&#160; </div>
<div class="line"><a name="l02355"></a><span class="lineno"> 2355</span>&#160;        <span class="comment">//============================================ Allocate memory for the value grid on which the interpolation is to be done (along second dimension)</span></div>
<div class="line"><a name="l02356"></a><span class="lineno"> 2356</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; 4; iter++ )</div>
<div class="line"><a name="l02357"></a><span class="lineno"> 2357</span>&#160;        {</div>
<div class="line"><a name="l02358"></a><span class="lineno"> 2358</span>&#160;            interpGrid[iter]                          = <span class="keyword">new</span> proshade_double[4];</div>
<div class="line"><a name="l02359"></a><span class="lineno"> 2359</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a> ( interpGrid[iter], __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l02360"></a><span class="lineno"> 2360</span>&#160;        }</div>
<div class="line"><a name="l02361"></a><span class="lineno"> 2361</span>&#160; </div>
<div class="line"><a name="l02362"></a><span class="lineno"> 2362</span>&#160;        <span class="comment">//============================================ Fill in the value grid on which the interpolation is to be done</span></div>
<div class="line"><a name="l02363"></a><span class="lineno"> 2363</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign latIt = 0; latIt &lt; 4; latIt++ )</div>
<div class="line"><a name="l02364"></a><span class="lineno"> 2364</span>&#160;        {</div>
<div class="line"><a name="l02365"></a><span class="lineno"> 2365</span>&#160;            <span class="keywordflow">for</span> ( proshade_unsign lonIt = 0; lonIt &lt; 4; lonIt++ )</div>
<div class="line"><a name="l02366"></a><span class="lineno"> 2366</span>&#160;            {</div>
<div class="line"><a name="l02367"></a><span class="lineno"> 2367</span>&#160;                latHlp = bestLattitude - 1 + latIt; <span class="keywordflow">if</span> ( latHlp &lt; 0.0 ) { latHlp += angDim; } <span class="keywordflow">if</span> ( latHlp &gt;= angDim ) { latHlp -= angDim; }</div>
<div class="line"><a name="l02368"></a><span class="lineno"> 2368</span>&#160;                lonHlp = bestLongitude - 1 + lonIt; <span class="keywordflow">if</span> ( lonHlp &lt; 0.0 ) { lonHlp += angDim; } <span class="keywordflow">if</span> ( lonHlp &gt;= angDim ) { lonHlp -= angDim; }</div>
<div class="line"><a name="l02369"></a><span class="lineno"> 2369</span>&#160;                interpGrid[latIt][lonIt]              = sphereMappedRotFun-&gt;at(sphereList-&gt;at(sphereIt))-&gt;getSphereLatLonPosition ( latHlp, lonHlp );</div>
<div class="line"><a name="l02370"></a><span class="lineno"> 2370</span>&#160;            }</div>
<div class="line"><a name="l02371"></a><span class="lineno"> 2371</span>&#160;        }</div>
<div class="line"><a name="l02372"></a><span class="lineno"> 2372</span>&#160; </div>
<div class="line"><a name="l02373"></a><span class="lineno"> 2373</span>&#160;        <span class="comment">//============================================ Create the interpolators</span></div>
<div class="line"><a name="l02374"></a><span class="lineno"> 2374</span>&#160;        <a class="code" href="class_pro_s_h_a_d_e__internal__maths_1_1_bicubic_interpolator.html">ProSHADE_internal_maths::BicubicInterpolator</a>* biCubInterp = <span class="keyword">new</span> <a class="code" href="class_pro_s_h_a_d_e__internal__maths_1_1_bicubic_interpolator.html">ProSHADE_internal_maths::BicubicInterpolator</a> ( interpGrid, bestLattitude, bestLongitude );</div>
<div class="line"><a name="l02375"></a><span class="lineno"> 2375</span>&#160;        interpols-&gt;emplace_back                       ( biCubInterp );</div>
<div class="line"><a name="l02376"></a><span class="lineno"> 2376</span>&#160;        </div>
<div class="line"><a name="l02377"></a><span class="lineno"> 2377</span>&#160;        <span class="comment">//============================================ Release memory</span></div>
<div class="line"><a name="l02378"></a><span class="lineno"> 2378</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; 4; iter++ ) { <span class="keyword">delete</span>[] interpGrid[iter]; }</div>
<div class="line"><a name="l02379"></a><span class="lineno"> 2379</span>&#160;        <span class="keyword">delete</span>[] interpGrid;</div>
<div class="line"><a name="l02380"></a><span class="lineno"> 2380</span>&#160;    }</div>
<div class="line"><a name="l02381"></a><span class="lineno"> 2381</span>&#160;    </div>
<div class="line"><a name="l02382"></a><span class="lineno"> 2382</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l02383"></a><span class="lineno"> 2383</span>&#160;    return ;</div>
<div class="line"><a name="l02384"></a><span class="lineno"> 2384</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6359dd366cdd986f5ad155bff8235a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6359dd366cdd986f5ad155bff8235a8e">&#9670;&nbsp;</a></span>primeFactorsDecomp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; proshade_signed &gt; ProSHADE_internal_maths::primeFactorsDecomp </td>
          <td>(</td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to find prime factors of an integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">number</td><td>A single integer number to be decomposed into its prime factors. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01636">1636</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01637"></a><span class="lineno"> 1637</span>&#160;{</div>
<div class="line"><a name="l01638"></a><span class="lineno"> 1638</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l01639"></a><span class="lineno"> 1639</span>&#160;    std::vector &lt; proshade_signed &gt; ret;</div>
<div class="line"><a name="l01640"></a><span class="lineno"> 1640</span>&#160;    </div>
<div class="line"><a name="l01641"></a><span class="lineno"> 1641</span>&#160;    <span class="comment">//================================================ Deal with negative numbers</span></div>
<div class="line"><a name="l01642"></a><span class="lineno"> 1642</span>&#160;    <span class="keywordtype">bool</span> changeSign                                   = <span class="keyword">false</span>;</div>
<div class="line"><a name="l01643"></a><span class="lineno"> 1643</span>&#160;    <span class="keywordflow">if</span> ( number &lt; 0 ) { changeSign = <span class="keyword">true</span>; number = -number; }</div>
<div class="line"><a name="l01644"></a><span class="lineno"> 1644</span>&#160;    </div>
<div class="line"><a name="l01645"></a><span class="lineno"> 1645</span>&#160;    <span class="comment">//================================================ Deal with zero and one</span></div>
<div class="line"><a name="l01646"></a><span class="lineno"> 1646</span>&#160;    <span class="keywordflow">if</span> ( number == 0 ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a8a52d854a63ecad80c1805d601ffcf96">ProSHADE_internal_misc::addToSignedVector</a> ( &amp;ret, 0 ); <span class="keywordflow">return</span> ( ret ); }</div>
<div class="line"><a name="l01647"></a><span class="lineno"> 1647</span>&#160;    <span class="keywordflow">if</span> ( number == 1 ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a8a52d854a63ecad80c1805d601ffcf96">ProSHADE_internal_misc::addToSignedVector</a> ( &amp;ret, 1 ); <span class="keywordflow">return</span> ( ret ); }</div>
<div class="line"><a name="l01648"></a><span class="lineno"> 1648</span>&#160;    </div>
<div class="line"><a name="l01649"></a><span class="lineno"> 1649</span>&#160;    <span class="comment">//================================================ Divide by 2 as long as you can</span></div>
<div class="line"><a name="l01650"></a><span class="lineno"> 1650</span>&#160;    <span class="keywordflow">while</span> ( number % 2 == 0 )</div>
<div class="line"><a name="l01651"></a><span class="lineno"> 1651</span>&#160;    {</div>
<div class="line"><a name="l01652"></a><span class="lineno"> 1652</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a8a52d854a63ecad80c1805d601ffcf96">ProSHADE_internal_misc::addToSignedVector</a>     ( &amp;ret, 2 );</div>
<div class="line"><a name="l01653"></a><span class="lineno"> 1653</span>&#160;        number                                        = number / 2;</div>
<div class="line"><a name="l01654"></a><span class="lineno"> 1654</span>&#160;    }</div>
<div class="line"><a name="l01655"></a><span class="lineno"> 1655</span>&#160;    </div>
<div class="line"><a name="l01656"></a><span class="lineno"> 1656</span>&#160;    <span class="comment">//================================================ Check all odd numbers up to the square root</span></div>
<div class="line"><a name="l01657"></a><span class="lineno"> 1657</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign posDiv = 3; posDiv &lt;= sqrt ( number ); posDiv += 2)</div>
<div class="line"><a name="l01658"></a><span class="lineno"> 1658</span>&#160;    {</div>
<div class="line"><a name="l01659"></a><span class="lineno"> 1659</span>&#160;        <span class="comment">// If posDiv is a divisor of the number, save the result</span></div>
<div class="line"><a name="l01660"></a><span class="lineno"> 1660</span>&#160;        <span class="keywordflow">while</span> ( number % posDiv == 0 )</div>
<div class="line"><a name="l01661"></a><span class="lineno"> 1661</span>&#160;        {</div>
<div class="line"><a name="l01662"></a><span class="lineno"> 1662</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a8a52d854a63ecad80c1805d601ffcf96">ProSHADE_internal_misc::addToSignedVector</a> ( &amp;ret, posDiv );</div>
<div class="line"><a name="l01663"></a><span class="lineno"> 1663</span>&#160;            number                                    = number / posDiv;</div>
<div class="line"><a name="l01664"></a><span class="lineno"> 1664</span>&#160;        }</div>
<div class="line"><a name="l01665"></a><span class="lineno"> 1665</span>&#160;    }</div>
<div class="line"><a name="l01666"></a><span class="lineno"> 1666</span>&#160;    </div>
<div class="line"><a name="l01667"></a><span class="lineno"> 1667</span>&#160;    <span class="comment">//================================================ If the number was a large prime number, save it as it is</span></div>
<div class="line"><a name="l01668"></a><span class="lineno"> 1668</span>&#160;    <span class="keywordflow">if</span> ( number &gt; 2 ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a8a52d854a63ecad80c1805d601ffcf96">ProSHADE_internal_misc::addToSignedVector</a> ( &amp;ret, number ); }</div>
<div class="line"><a name="l01669"></a><span class="lineno"> 1669</span>&#160; </div>
<div class="line"><a name="l01670"></a><span class="lineno"> 1670</span>&#160;    <span class="comment">//================================================ Finish dealing with negative numbers</span></div>
<div class="line"><a name="l01671"></a><span class="lineno"> 1671</span>&#160;    <span class="keywordflow">if</span> ( changeSign ) { ret.at(0) = -ret.at(0); }</div>
<div class="line"><a name="l01672"></a><span class="lineno"> 1672</span>&#160;    </div>
<div class="line"><a name="l01673"></a><span class="lineno"> 1673</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01674"></a><span class="lineno"> 1674</span>&#160;    <span class="keywordflow">return</span>                                            ( ret );</div>
<div class="line"><a name="l01675"></a><span class="lineno"> 1675</span>&#160;    </div>
<div class="line"><a name="l01676"></a><span class="lineno"> 1676</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4348a7a36275c9cea20b5c27093c9b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4348a7a36275c9cea20b5c27093c9b7e">&#9670;&nbsp;</a></span>rotationMatrixSimilarity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_maths::rotationMatrixSimilarity </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double &gt; *&#160;</td>
          <td class="paramname"><em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double &gt; *&#160;</td>
          <td class="paramname"><em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>0.1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function compares the distance between two rotation matrices and decides if they are similar using tolerance. </p>
<p>This function computes the distance between two rotation matrices, specifically by computing the trace of (R1 * R2^T). This measure will be 3.0 if the two matrices are identical and will decrease the more the rotation matrices difference diverges from identity. Therefore, from this trace 3.0 is subtracted and the absolute value of the result is compared to the tolerance. If the difference is less than the tolerance, true is returned, while false is returned otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat1</td><td>Vector of 9 numbers representing first rotation matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mat1</td><td>Vector of 9 numbers representing second rotation matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>Double number representing the maximum allowed error on the distance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">res</td><td>Boolean decision if the two matrices are similar or not. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01979">1979</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01980"></a><span class="lineno"> 1980</span>&#160;{</div>
<div class="line"><a name="l01981"></a><span class="lineno"> 1981</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l01982"></a><span class="lineno"> 1982</span>&#160;    <span class="keywordtype">bool</span> ret                                          = <span class="keyword">false</span>;</div>
<div class="line"><a name="l01983"></a><span class="lineno"> 1983</span>&#160;    </div>
<div class="line"><a name="l01984"></a><span class="lineno"> 1984</span>&#160;    <span class="comment">//================================================ Compute trace of mat1 * mat2^T</span></div>
<div class="line"><a name="l01985"></a><span class="lineno"> 1985</span>&#160;    proshade_double trace                             = ( mat1-&gt;at(0) * mat2-&gt;at(0) ) + ( mat1-&gt;at(1) * mat2-&gt;at(1) ) + ( mat1-&gt;at(2) * mat2-&gt;at(2) );</div>
<div class="line"><a name="l01986"></a><span class="lineno"> 1986</span>&#160;    trace                                            += ( mat1-&gt;at(3) * mat2-&gt;at(3) ) + ( mat1-&gt;at(4) * mat2-&gt;at(4) ) + ( mat1-&gt;at(5) * mat2-&gt;at(5) );</div>
<div class="line"><a name="l01987"></a><span class="lineno"> 1987</span>&#160;    trace                                            += ( mat1-&gt;at(6) * mat2-&gt;at(6) ) + ( mat1-&gt;at(7) * mat2-&gt;at(7) ) + ( mat1-&gt;at(8) * mat2-&gt;at(8) );</div>
<div class="line"><a name="l01988"></a><span class="lineno"> 1988</span>&#160;    </div>
<div class="line"><a name="l01989"></a><span class="lineno"> 1989</span>&#160;    <span class="comment">//================================================ Subtract 3 (so that we would have 0 in case of idenity matrix)</span></div>
<div class="line"><a name="l01990"></a><span class="lineno"> 1990</span>&#160;    trace                                            -= 3.0;</div>
<div class="line"><a name="l01991"></a><span class="lineno"> 1991</span>&#160;    </div>
<div class="line"><a name="l01992"></a><span class="lineno"> 1992</span>&#160;    <span class="comment">//================================================ Compare to tolerance</span></div>
<div class="line"><a name="l01993"></a><span class="lineno"> 1993</span>&#160;    <span class="keywordflow">if</span> ( tolerance &gt; std::abs ( trace ) ) { ret = <span class="keyword">true</span>; }</div>
<div class="line"><a name="l01994"></a><span class="lineno"> 1994</span>&#160;    </div>
<div class="line"><a name="l01995"></a><span class="lineno"> 1995</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01996"></a><span class="lineno"> 1996</span>&#160;    <span class="keywordflow">return</span>                                            ( ret );</div>
<div class="line"><a name="l01997"></a><span class="lineno"> 1997</span>&#160;    </div>
<div class="line"><a name="l01998"></a><span class="lineno"> 1998</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8a7c6330e101fb6d729aaf6f545db9c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7c6330e101fb6d729aaf6f545db9c8">&#9670;&nbsp;</a></span>vectorMeanAndSD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::vectorMeanAndSD </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double &gt; *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get vector mean and standard deviation. </p>
<p>This function takes a pointer to a vector of proshade_double's and returns the mean and standard deviation of such vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>Pointer to a vector of proshade_double's for which mean and sd should be obtained. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>Pointer to array of 2 proshade_double's, which will be the return values - first mean and second sd. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00121">121</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;{</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    <span class="comment">//================================================ Get mean</span></div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    ret[0]                                            = std::accumulate ( vec-&gt;begin(), vec-&gt;end(), 0.0 ) / <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( vec-&gt;size() );</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    </div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    <span class="comment">//================================================ Get standard deviation</span></div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    proshade_double squaredSum                        = std::inner_product ( vec-&gt;begin(), vec-&gt;end(), vec-&gt;begin(), 0.0 );</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    ret[1]                                            = std::sqrt ( ( squaredSum / <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( vec-&gt;size() ) ) - std::pow ( ret[0], 2.0 ) );</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    </div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    <span class="comment">//================================================ Check for NaN&#39;s</span></div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    <span class="keywordflow">if</span> ( ret[0] != ret[0] ) { ret[0] = 0.0; }</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    <span class="keywordflow">if</span> ( ret[1] != ret[1] ) { ret[1] = 0.0; }</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    </div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    <span class="comment">//================================================ Return</span></div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    return ;</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    </div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af185ca14eb5d82fb126092767746e00a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af185ca14eb5d82fb126092767746e00a">&#9670;&nbsp;</a></span>vectorMedianAndIQR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::vectorMedianAndIQR </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double &gt; *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get vector median and inter-quartile range. </p>
<p>This function takes a pointer to a vector of proshade_double's and returns the median and the inter-quartile range of such vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>Pointer to a vector of proshade_double's for which median and IQR should be obtained. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>Pointer to array of 2 proshade_double's, which will be the return values - first median and second IQR. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00147">147</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;{</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    <span class="comment">//================================================ Sanity check</span></div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    <span class="keywordflow">if</span> ( vec-&gt;size() &lt; 3 ) { ret[0] = 0.0; ret[1] = 0.0; <span class="keywordflow">return</span>; }</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;    </div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    <span class="comment">//================================================ Sort the vector</span></div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;    std::sort                                         ( vec-&gt;begin(), vec-&gt;end() );</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    </div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    <span class="comment">//================================================ Get median</span></div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    <span class="keywordflow">if</span> ( <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( vec-&gt;size() ) % 2 == 0)</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    {</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;        ret[0]                                        = ( vec-&gt;at( ( <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( vec-&gt;size() ) / 2 ) - 1 ) +</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;                                                        vec-&gt;at(   <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( vec-&gt;size() ) / 2 ) ) / 2.0;</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    }</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    {</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;        ret[0]                                        = vec-&gt;at( <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( vec-&gt;size() ) / 2 );</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;    }</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    </div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    <span class="comment">//================================================ Get first and third quartile</span></div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    proshade_double Q1, Q3;</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    <span class="keywordflow">if</span> ( <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( vec-&gt;size() ) % 2 == 0)</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;    {</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;        Q1                                            = ( vec-&gt;at( ( <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( vec-&gt;size() ) / 4 ) - 1 ) +</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;                                                          vec-&gt;at(   <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( vec-&gt;size() ) / 4 ) ) / 2.0;</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;        Q3                                            = ( vec-&gt;at( ( ( <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( vec-&gt;size() ) / 4 ) * 3 ) - 1 ) +</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;                                                          vec-&gt;at(   ( <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( vec-&gt;size() ) / 4 ) * 3 ) ) / 2.0;</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;    }</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;    {</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;        Q1                                            = vec-&gt;at( <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( vec-&gt;size() ) / 4 );</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;        Q3                                            = vec-&gt;at( ( <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( vec-&gt;size() ) / 4 ) * 3 );</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    }</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    </div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    <span class="comment">//================================================ And now save the IQR</span></div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    ret[1]                                            = Q3 -  Q1;</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    </div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;    <span class="comment">//================================================ Return</span></div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    return ;</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    </div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2b2f67cba1eea57f19fdaf062db74fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2f67cba1eea57f19fdaf062db74fde">&#9670;&nbsp;</a></span>vectorOrientationSimilarity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_maths::vectorOrientationSimilarity </td>
          <td>(</td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>b3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>0.1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function compares two vectors using cosine distance and decides if they are similar using tolerance. </p>
<p>This function computes the distance between two vectors, specifically by computing the cosine distance ( ( dot( A, B ) ) / ( mag(A) x mag(B) ) ). This measure will be 1.0 if the two vectors are identically oriented, 0.0 if they are perpendicular and -1.0 if they have opposite direction. Given that opposite direction must be regarded as same direction with opposite angles for symmetry axes detection purposes, this function uses the absolute value of this measure and checks if the two supplied vectors (supplied element by element) have cosine distance within 1.0 - tolerance, returning true if they do and false otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a1</td><td>The first element of the first vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a2</td><td>The second element of the first vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a3</td><td>The third element of the first vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b1</td><td>The first element of the second vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b2</td><td>The second element of the second vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b3</td><td>The third element of the second vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>The allowed difference of the distance measure from the 1.0 for the vectors to still be considered similar. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">res</td><td>Boolean decision if the two vectors are similar or not. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l02016">2016</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02017"></a><span class="lineno"> 2017</span>&#160;{</div>
<div class="line"><a name="l02018"></a><span class="lineno"> 2018</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l02019"></a><span class="lineno"> 2019</span>&#160;    <span class="keywordtype">bool</span> ret                                          = <span class="keyword">false</span>;</div>
<div class="line"><a name="l02020"></a><span class="lineno"> 2020</span>&#160;    </div>
<div class="line"><a name="l02021"></a><span class="lineno"> 2021</span>&#160;    <span class="comment">//================================================ Cosine distance</span></div>
<div class="line"><a name="l02022"></a><span class="lineno"> 2022</span>&#160;    proshade_double cosDist                           = ( ( a1 * b1 ) + ( a2 * b2 ) + ( a3 * b3 ) ) /</div>
<div class="line"><a name="l02023"></a><span class="lineno"> 2023</span>&#160;                                                        ( sqrt( pow( a1, 2.0 ) + pow( a2, 2.0 ) + pow( a3, 2.0 ) ) *</div>
<div class="line"><a name="l02024"></a><span class="lineno"> 2024</span>&#160;                                                          sqrt( pow( b1, 2.0 ) + pow( b2, 2.0 ) + pow( b3, 2.0 ) ) );</div>
<div class="line"><a name="l02025"></a><span class="lineno"> 2025</span>&#160;    </div>
<div class="line"><a name="l02026"></a><span class="lineno"> 2026</span>&#160;    <span class="comment">//================================================ Compare the absolute value of distance to 1.0 - tolerance</span></div>
<div class="line"><a name="l02027"></a><span class="lineno"> 2027</span>&#160;    <span class="keywordflow">if</span> ( std::abs( cosDist ) &gt; ( 1.0 - tolerance ) ) { ret = <span class="keyword">true</span>; }</div>
<div class="line"><a name="l02028"></a><span class="lineno"> 2028</span>&#160;    </div>
<div class="line"><a name="l02029"></a><span class="lineno"> 2029</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l02030"></a><span class="lineno"> 2030</span>&#160;    <span class="keywordflow">return</span>                                            ( ret );</div>
<div class="line"><a name="l02031"></a><span class="lineno"> 2031</span>&#160;    </div>
<div class="line"><a name="l02032"></a><span class="lineno"> 2032</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a79e789452e327bb07a53c5358f4d3eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e789452e327bb07a53c5358f4d3eb0">&#9670;&nbsp;</a></span>vectorOrientationSimilaritySameDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_maths::vectorOrientationSimilaritySameDirection </td>
          <td>(</td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>b3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>0.1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function compares two vectors using cosine distance and decides if they are similar using tolerance. </p>
<p>This function computes the distance between two vectors, specifically by computing the cosine distance ( ( dot( A, B ) ) / ( mag(A) x mag(B) ) ). This measure will be 1.0 if the two vectors are identically oriented, 0.0 if they are perpendicular and -1.0 if they have opposite direction. Given that opposite direction must be regarded as different vector for peak detection purposes (spheres with different angles are covered separately), this function does not use the absolute value of this measure and checks if the two supplied vectors (supplied element by element) have cosine distance within 1.0 - tolerance, returning true if they do and false otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a1</td><td>The first element of the first vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a2</td><td>The second element of the first vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a3</td><td>The third element of the first vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b1</td><td>The first element of the second vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b2</td><td>The second element of the second vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b3</td><td>The third element of the second vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>The allowed difference of the distance measure from the 1.0 for the vectors to still be considered similar. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">res</td><td>Boolean decision if the two vectors are similar or not. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l02050">2050</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02051"></a><span class="lineno"> 2051</span>&#160;{</div>
<div class="line"><a name="l02052"></a><span class="lineno"> 2052</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l02053"></a><span class="lineno"> 2053</span>&#160;    <span class="keywordtype">bool</span> ret                                          = <span class="keyword">false</span>;</div>
<div class="line"><a name="l02054"></a><span class="lineno"> 2054</span>&#160;    </div>
<div class="line"><a name="l02055"></a><span class="lineno"> 2055</span>&#160;    <span class="comment">//================================================ Cosine distance</span></div>
<div class="line"><a name="l02056"></a><span class="lineno"> 2056</span>&#160;    proshade_double cosDist                           = ( ( a1 * b1 ) + ( a2 * b2 ) + ( a3 * b3 ) ) /</div>
<div class="line"><a name="l02057"></a><span class="lineno"> 2057</span>&#160;                                                        ( sqrt( pow( a1, 2.0 ) + pow( a2, 2.0 ) + pow( a3, 2.0 ) ) *</div>
<div class="line"><a name="l02058"></a><span class="lineno"> 2058</span>&#160;                                                          sqrt( pow( b1, 2.0 ) + pow( b2, 2.0 ) + pow( b3, 2.0 ) ) );</div>
<div class="line"><a name="l02059"></a><span class="lineno"> 2059</span>&#160;    </div>
<div class="line"><a name="l02060"></a><span class="lineno"> 2060</span>&#160;    <span class="comment">//================================================ Compare the absolute value of distance to 1.0 - tolerance</span></div>
<div class="line"><a name="l02061"></a><span class="lineno"> 2061</span>&#160;    <span class="keywordflow">if</span> ( cosDist &gt; ( 1.0 - tolerance ) ) { ret = <span class="keyword">true</span>; }</div>
<div class="line"><a name="l02062"></a><span class="lineno"> 2062</span>&#160;    </div>
<div class="line"><a name="l02063"></a><span class="lineno"> 2063</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l02064"></a><span class="lineno"> 2064</span>&#160;    <span class="keywordflow">return</span>                                            ( ret );</div>
<div class="line"><a name="l02065"></a><span class="lineno"> 2065</span>&#160;    </div>
<div class="line"><a name="l02066"></a><span class="lineno"> 2066</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a73c2321ffcef5079634493d9bf65749b"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a73c2321ffcef5079634493d9bf65749b">ProSHADE_internal_maths::prepareBiCubicInterpolatorsMinusPlus</a></div><div class="ttdeci">void prepareBiCubicInterpolatorsMinusPlus(proshade_double bestLattitude, proshade_double bestLongitude, std::vector&lt; proshade_unsign &gt; *sphereList, std::vector&lt; ProSHADE_internal_maths::BicubicInterpolator * &gt; *interpols, std::vector&lt; ProSHADE_internal_spheres::ProSHADE_rotFun_sphere * &gt; *sphereMappedRotFun)</div><div class="ttdoc">This function prepares the interpolation objects for the bi-cubic interpolation.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l02232">ProSHADE_maths.cpp:2232</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__exception_html"><div class="ttname"><a href="class_pro_s_h_a_d_e__exception.html">ProSHADE_exception</a></div><div class="ttdoc">This class is the representation of ProSHADE exception.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__exceptions_8hpp_source.html#l00036">ProSHADE_exceptions.hpp:37</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a3f12eb80331377a36ee6b3a4f8e65147"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a3f12eb80331377a36ee6b3a4f8e65147">ProSHADE_internal_maths::prepareBiCubicInterpolatorsPlusMinus</a></div><div class="ttdeci">void prepareBiCubicInterpolatorsPlusMinus(proshade_double bestLattitude, proshade_double bestLongitude, std::vector&lt; proshade_unsign &gt; *sphereList, std::vector&lt; ProSHADE_internal_maths::BicubicInterpolator * &gt; *interpols, std::vector&lt; ProSHADE_internal_spheres::ProSHADE_rotFun_sphere * &gt; *sphereMappedRotFun)</div><div class="ttdoc">This function prepares the interpolation objects for the bi-cubic interpolation.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l02287">ProSHADE_maths.cpp:2287</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a7e69b64278319ae1a1268d1a55545675"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a7e69b64278319ae1a1268d1a55545675">ProSHADE_internal_maths::evaluateGLSeries</a></div><div class="ttdeci">proshade_double evaluateGLSeries(proshade_double *series, proshade_double target, proshade_unsign terms)</div><div class="ttdoc">This function evaluates the Taylor expansion.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00447">ProSHADE_maths.cpp:447</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_abd9fe573a48f499dd7d1df4f779222f1"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#abd9fe573a48f499dd7d1df4f779222f1">ProSHADE_internal_maths::getRotationMatrixFromEulerZXZAngles</a></div><div class="ttdeci">void getRotationMatrixFromEulerZXZAngles(proshade_double eulerAlpha, proshade_double eulerBeta, proshade_double eulerGamma, proshade_double *matrix)</div><div class="ttdoc">Function to find the rotation matrix from Euler angles (ZXZ convention).</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01005">ProSHADE_maths.cpp:1005</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a1823adaca871244e42347ecb8ed834a2"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a1823adaca871244e42347ecb8ed834a2">ProSHADE_internal_maths::getGLFirstEvenRoot</a></div><div class="ttdeci">void getGLFirstEvenRoot(proshade_double polyAtZero, proshade_unsign order, proshade_double *abscAtZero, proshade_double *weighAtZero, proshade_unsign taylorSeriesCap)</div><div class="ttdoc">This function finds the first root for Legendre polynomials of odd order.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00384">ProSHADE_maths.cpp:384</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a51486f6276c28c1b503f19c36007b9e2"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a51486f6276c28c1b503f19c36007b9e2">ProSHADE_internal_maths::optimiseAxisBiCubicInterpolation</a></div><div class="ttdeci">void optimiseAxisBiCubicInterpolation(proshade_double *bestLattitude, proshade_double *bestLongitude, proshade_double *bestSum, std::vector&lt; proshade_unsign &gt; *sphereList, std::vector&lt; ProSHADE_internal_spheres::ProSHADE_rotFun_sphere * &gt; *sphereMappedRotFun, proshade_double step=0.05)</div><div class="ttdoc">This function provides axis optimisation given starting lattitude and longitude indices.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l02080">ProSHADE_maths.cpp:2080</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a2b2f67cba1eea57f19fdaf062db74fde"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2b2f67cba1eea57f19fdaf062db74fde">ProSHADE_internal_maths::vectorOrientationSimilarity</a></div><div class="ttdeci">bool vectorOrientationSimilarity(proshade_double a1, proshade_double a2, proshade_double a3, proshade_double b1, proshade_double b2, proshade_double b3, proshade_double tolerance=0.1)</div><div class="ttdoc">This function compares two vectors using cosine distance and decides if they are similar using tolera...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l02016">ProSHADE_maths.cpp:2016</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_ac027bbd2cde68eb9d677e8b11b90cc2e"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#ac027bbd2cde68eb9d677e8b11b90cc2e">ProSHADE_internal_maths::prepareBiCubicInterpolatorsMinusMinus</a></div><div class="ttdeci">void prepareBiCubicInterpolatorsMinusMinus(proshade_double bestLattitude, proshade_double bestLongitude, std::vector&lt; proshade_unsign &gt; *sphereList, std::vector&lt; ProSHADE_internal_maths::BicubicInterpolator * &gt; *interpols, std::vector&lt; ProSHADE_internal_spheres::ProSHADE_rotFun_sphere * &gt; *sphereMappedRotFun)</div><div class="ttdoc">This function prepares the interpolation objects for the bi-cubic interpolation.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l02177">ProSHADE_maths.cpp:2177</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__misc_html_a68c3eafaeea1c1873c33525f337f9d0b"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a></div><div class="ttdeci">void addToDoubleVector(std::vector&lt; proshade_double &gt; *vecToAddTo, proshade_double elementToAdd)</div><div class="ttdoc">Adds the element to the vector.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__misc_8cpp_source.html#l00077">ProSHADE_misc.cpp:77</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__misc_html_a8a52d854a63ecad80c1805d601ffcf96"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__misc.html#a8a52d854a63ecad80c1805d601ffcf96">ProSHADE_internal_misc::addToSignedVector</a></div><div class="ttdeci">void addToSignedVector(std::vector&lt; proshade_signed &gt; *vecToAddTo, proshade_signed elementToAdd)</div><div class="ttdoc">Adds the element to the vector.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__misc_8cpp_source.html#l00121">ProSHADE_misc.cpp:121</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__maths_1_1_bicubic_interpolator_html"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__maths_1_1_bicubic_interpolator.html">ProSHADE_internal_maths::BicubicInterpolator</a></div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8hpp_source.html#l00101">ProSHADE_maths.hpp:102</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_affab74b910cda2ee3faa461740a7a432"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#affab74b910cda2ee3faa461740a7a432">ProSHADE_internal_maths::getGLPolyAtZero</a></div><div class="ttdeci">void getGLPolyAtZero(proshade_unsign order, proshade_double *polyValue, proshade_double *deriValue)</div><div class="ttdoc">This function obtains the Legendre polynomial values and its derivative at zero for any positive inte...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00347">ProSHADE_maths.cpp:347</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_aafc6f1626c7463de53c9f4f6fa11db22"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#aafc6f1626c7463de53c9f4f6fa11db22">ProSHADE_internal_maths::getAxisAngleFromRotationMatrix</a></div><div class="ttdeci">void getAxisAngleFromRotationMatrix(proshade_double *rotMat, proshade_double *x, proshade_double *y, proshade_double *z, proshade_double *ang)</div><div class="ttdoc">This function converts rotation matrix to the axis-angle representation.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01039">ProSHADE_maths.cpp:1039</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a4f2619c7f3b8d628af9cb356778e9807"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a4f2619c7f3b8d628af9cb356778e9807">ProSHADE_internal_maths::advanceGLPolyValue</a></div><div class="ttdeci">proshade_double advanceGLPolyValue(proshade_double from, proshade_double to, proshade_double valAtFrom, proshade_unsign noSteps, proshade_unsign taylorSeriesCap)</div><div class="ttdoc">This function finds the next value of the polynomial.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00477">ProSHADE_maths.cpp:477</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__misc_html_af556836aa9286c1571196de442a6b493"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a></div><div class="ttdeci">void checkMemoryAllocation(chVar checkVar, std::string fileP, unsigned int lineP, std::string funcP, std::string infoP=&quot;This error may occurs when ProSHADE requests memory to be\n                    : allocated to it and this operation fails. This could\n                    : happen when not enough memory is available, either due to\n                    : other processes using a lot of memory, or when the machine\n                    : does not have sufficient memory available. Re-run to see\n                    : if this problem persists.&quot;)</div><div class="ttdoc">Checks if memory was allocated properly.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__misc_8hpp_source.html#l00065">ProSHADE_misc.hpp:65</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_acf6c5376edac98e54ef0e418cd05d706"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#acf6c5376edac98e54ef0e418cd05d706">ProSHADE_internal_maths::getEulerZXZFromSOFTPosition</a></div><div class="ttdeci">void getEulerZXZFromSOFTPosition(proshade_signed band, proshade_signed x, proshade_signed y, proshade_signed z, proshade_double *eulerAlpha, proshade_double *eulerBeta, proshade_double *eulerGamma)</div><div class="ttdoc">Function to find Euler angles (ZXZ convention) from index position in the inverse SOFT map.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00961">ProSHADE_maths.cpp:961</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__misc_html_a16336bdf0b391c953a549d3df115d691"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a></div><div class="ttdeci">void addToUnsignVector(std::vector&lt; proshade_unsign &gt; *vecToAddTo, proshade_unsign elementToAdd)</div><div class="ttdoc">Adds the element to the vector.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__misc_8cpp_source.html#l00099">ProSHADE_misc.cpp:99</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a31c91064de64aef9f8278d533f8188ad"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a31c91064de64aef9f8278d533f8188ad">ProSHADE_internal_maths::completeLegendreSeries</a></div><div class="ttdeci">void completeLegendreSeries(proshade_unsign order, proshade_double *abscissa, proshade_double *weights, proshade_unsign taylorSeriesCap)</div><div class="ttdoc">This function completes the Legendre polynomial series assuming you have obtained the first values.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00521">ProSHADE_maths.cpp:521</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_ac3b355465dd2244b51e579dcb8669b3a"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#ac3b355465dd2244b51e579dcb8669b3a">ProSHADE_internal_maths::prepareBiCubicInterpolatorsPlusPlus</a></div><div class="ttdeci">void prepareBiCubicInterpolatorsPlusPlus(proshade_double bestLattitude, proshade_double bestLongitude, std::vector&lt; proshade_unsign &gt; *sphereList, std::vector&lt; ProSHADE_internal_maths::BicubicInterpolator * &gt; *interpols, std::vector&lt; ProSHADE_internal_spheres::ProSHADE_rotFun_sphere * &gt; *sphereMappedRotFun)</div><div class="ttdoc">This function prepares the interpolation objects for the bi-cubic interpolation.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l02342">ProSHADE_maths.cpp:2342</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html">ProSHADE_internal_maths</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
