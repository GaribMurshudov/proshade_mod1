<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ProSHADE: ProSHADE_internal_symmetry Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Logo_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ProSHADE
   &#160;<span id="projectnumber">0.7.5.1 (JAN 2021) - EXPERIMENTAL</span>
   </div>
   <div id="projectbrief">Protein Shape Detection</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespace_pro_s_h_a_d_e__internal__symmetry.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ProSHADE_internal_symmetry Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This namespace contains the symmetry detection related code.  
<a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a66b286b7617c645b6543b28c1cd789af"><td class="memItemLeft" align="right" valign="top">std::vector&lt; proshade_double * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a66b286b7617c645b6543b28c1cd789af">getPeaksAngleAxisPositions</a> (std::vector&lt; proshade_double * &gt; allPeaks, proshade_unsign verbose)</td></tr>
<tr class="memdesc:a66b286b7617c645b6543b28c1cd789af"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts peaks ZXZ Euler anles to angle-axis representation for further processing.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a66b286b7617c645b6543b28c1cd789af">More...</a><br /></td></tr>
<tr class="separator:a66b286b7617c645b6543b28c1cd789af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2137fa16a69fc7a8365439e322b67dc8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; proshade_double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a2137fa16a69fc7a8365439e322b67dc8">findPeaksByHeightBoundaries</a> (std::vector&lt; proshade_double * &gt; allPeaks, proshade_double smoothing)</td></tr>
<tr class="memdesc:a2137fa16a69fc7a8365439e322b67dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function groups the peaks by height and returns the boundaries between such groups.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a2137fa16a69fc7a8365439e322b67dc8">More...</a><br /></td></tr>
<tr class="separator:a2137fa16a69fc7a8365439e322b67dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648ddad98891a4d8a6af5187d994c5ec"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a648ddad98891a4d8a6af5187d994c5ec">findPeaksCSymmetry</a> (std::vector&lt; proshade_double * &gt; *peaks, proshade_signed verbose, proshade_unsign band, proshade_double missPeakThres, proshade_double axisErrTolerance, bool axisErrToleranceDef, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj)</td></tr>
<tr class="memdesc:a648ddad98891a4d8a6af5187d994c5ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function searches the list of peaks for presence of cyclic symmetry.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a648ddad98891a4d8a6af5187d994c5ec">More...</a><br /></td></tr>
<tr class="separator:a648ddad98891a4d8a6af5187d994c5ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98538547e5bcc6192bbbea1d7b51c537"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a98538547e5bcc6192bbbea1d7b51c537">groupSameAxes</a> (std::vector&lt; proshade_double * &gt; &amp;peaks, proshade_double errTolerance)</td></tr>
<tr class="memdesc:a98538547e5bcc6192bbbea1d7b51c537"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function groups the peaks by their axes of rotation.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a98538547e5bcc6192bbbea1d7b51c537">More...</a><br /></td></tr>
<tr class="separator:a98538547e5bcc6192bbbea1d7b51c537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41150b2f8995b2ac1f144143fc83b6ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a41150b2f8995b2ac1f144143fc83b6ee">giveOppositeAxesSameDirection</a> (std::vector&lt; proshade_double * &gt; peaks)</td></tr>
<tr class="memdesc:a41150b2f8995b2ac1f144143fc83b6ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function modifiest the axes so that the highest vector element is always positive.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a41150b2f8995b2ac1f144143fc83b6ee">More...</a><br /></td></tr>
<tr class="separator:a41150b2f8995b2ac1f144143fc83b6ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9835b91e354e4615beb79b5c2a674e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af9835b91e354e4615beb79b5c2a674e9">printSymmetryPeaks</a> (std::vector&lt; proshade_unsign &gt; grp, std::vector&lt; proshade_double * &gt; peaks, proshade_signed verbose, proshade_unsign groupNo)</td></tr>
<tr class="memdesc:af9835b91e354e4615beb79b5c2a674e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function simply prints the symmetry axis group supplied in the first parameter from the second parameter values.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af9835b91e354e4615beb79b5c2a674e9">More...</a><br /></td></tr>
<tr class="separator:af9835b91e354e4615beb79b5c2a674e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3fcf4dd97e677da27192cf63dbb678"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a2b3fcf4dd97e677da27192cf63dbb678">smallestDistanceBetweenAngles</a> (std::vector&lt; proshade_unsign &gt; grp, std::vector&lt; proshade_double * &gt; peaks, std::vector&lt; proshade_double &gt; *tried, proshade_double *dist)</td></tr>
<tr class="memdesc:a2b3fcf4dd97e677da27192cf63dbb678"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds the smallest distance between the rotation angles within a group.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a2b3fcf4dd97e677da27192cf63dbb678">More...</a><br /></td></tr>
<tr class="separator:a2b3fcf4dd97e677da27192cf63dbb678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9b717260e86c8f24bcbe6d17fe4e06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ade9b717260e86c8f24bcbe6d17fe4e06">addZeroPeakToGroups</a> (std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; &amp;grpsVec, std::vector&lt; proshade_double * &gt; &amp;peaks)</td></tr>
<tr class="memdesc:ade9b717260e86c8f24bcbe6d17fe4e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the peak groups and adds zero peak to each of them.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ade9b717260e86c8f24bcbe6d17fe4e06">More...</a><br /></td></tr>
<tr class="separator:ade9b717260e86c8f24bcbe6d17fe4e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a8dc71c37de02256521ebc9178c8d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ac0a8dc71c37de02256521ebc9178c8d4">determineFoldToTry</a> (proshade_double dist, proshade_double *divBasis, proshade_double *divRem, proshade_double peakErr, proshade_double *symmErr, std::vector&lt; proshade_unsign &gt; *angsToTry)</td></tr>
<tr class="memdesc:ac0a8dc71c37de02256521ebc9178c8d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function determines the symmetry fold to be searched for.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ac0a8dc71c37de02256521ebc9178c8d4">More...</a><br /></td></tr>
<tr class="separator:ac0a8dc71c37de02256521ebc9178c8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f982fc282e8fca11b6a85f2d2069a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af4f982fc282e8fca11b6a85f2d2069a5">findExpectedPeakRotations</a> (proshade_unsign fold, std::vector&lt; proshade_double &gt; *expAngs)</td></tr>
<tr class="memdesc:af4f982fc282e8fca11b6a85f2d2069a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the expected peak rotations for given fold.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af4f982fc282e8fca11b6a85f2d2069a5">More...</a><br /></td></tr>
<tr class="separator:af4f982fc282e8fca11b6a85f2d2069a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074d9c1d40d7491ea9f9f9639744e18d"><td class="memItemLeft" align="right" valign="top">proshade_unsign&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a074d9c1d40d7491ea9f9f9639744e18d">checkExpectedAgainstFound</a> (std::vector&lt; proshade_unsign &gt; grp, std::vector&lt; proshade_double * &gt; peaks, std::vector&lt; proshade_double &gt; *expAngs, std::vector&lt; proshade_unsign &gt; *matchedAngs, std::vector&lt; proshade_unsign &gt; *missingAngs, proshade_double axisTol)</td></tr>
<tr class="memdesc:a074d9c1d40d7491ea9f9f9639744e18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the expected peak rotations for given fold.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a074d9c1d40d7491ea9f9f9639744e18d">More...</a><br /></td></tr>
<tr class="separator:a074d9c1d40d7491ea9f9f9639744e18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacced7feb8ce5251dce199505912d997"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#aacced7feb8ce5251dce199505912d997">checkForMissingPeak</a> (<a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_double x, proshade_double y, proshade_double z, proshade_double angle, proshade_double heightThres, proshade_double axTol)</td></tr>
<tr class="memdesc:aacced7feb8ce5251dce199505912d997"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks for the high of the correlation for particular rotation angle and axis.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#aacced7feb8ce5251dce199505912d997">More...</a><br /></td></tr>
<tr class="separator:aacced7feb8ce5251dce199505912d997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dda335a87d6c26edfd3cf2a29ff7f1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5dda335a87d6c26edfd3cf2a29ff7f1f">saveDetectedCSymmetry</a> (proshade_unsign fold, std::vector&lt; proshade_unsign &gt; *matchedPeaks, std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; *ret, proshade_signed verbose)</td></tr>
<tr class="memdesc:a5dda335a87d6c26edfd3cf2a29ff7f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function saves a detected symmetry for reporting to the user.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5dda335a87d6c26edfd3cf2a29ff7f1f">More...</a><br /></td></tr>
<tr class="separator:a5dda335a87d6c26edfd3cf2a29ff7f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3008592c3ce58393395e03dac26c3626"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a3008592c3ce58393395e03dac26c3626">completeMissingCSymmetry</a> (<a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_unsign fold, std::vector&lt; proshade_unsign &gt; *grp, std::vector&lt; proshade_double * &gt; *peaks, std::vector&lt; proshade_unsign &gt; *missingPeaks, std::vector&lt; proshade_double &gt; *expectedAngles, std::vector&lt; proshade_unsign &gt; *matchedPeaks, proshade_double axErrTolerance, proshade_unsign verbose)</td></tr>
<tr class="memdesc:a3008592c3ce58393395e03dac26c3626"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function does the complete missing peak searching and filling in the missing peaks.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a3008592c3ce58393395e03dac26c3626">More...</a><br /></td></tr>
<tr class="separator:a3008592c3ce58393395e03dac26c3626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03088b2929641cd6fc3e2e4e20d874b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ac03088b2929641cd6fc3e2e4e20d874b">findSymmetryUsingFold</a> (<a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, std::vector&lt; proshade_unsign &gt; *angsToTry, std::vector&lt; proshade_unsign &gt; *grp, std::vector&lt; proshade_double * &gt; *peaks, std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; *ret, std::vector&lt; proshade_unsign &gt; *testedAlready, proshade_double axErrTolerance, bool axErrToleranceDefault, proshade_double missPeakThres, proshade_unsign verbose)</td></tr>
<tr class="memdesc:ac03088b2929641cd6fc3e2e4e20d874b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tests all supplied folds for being supported by the peaks (i.e. and being complete present symmetry).  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ac03088b2929641cd6fc3e2e4e20d874b">More...</a><br /></td></tr>
<tr class="separator:ac03088b2929641cd6fc3e2e4e20d874b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b044752fe0a780a3f09743e9d8d58e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af4b044752fe0a780a3f09743e9d8d58e">printSymmetryGroup</a> (std::vector&lt; proshade_unsign &gt; grp, std::vector&lt; proshade_double * &gt; peaks, proshade_signed verbose)</td></tr>
<tr class="memdesc:af4b044752fe0a780a3f09743e9d8d58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function simply prints the detected symmetry and all its supporting peaks.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af4b044752fe0a780a3f09743e9d8d58e">More...</a><br /></td></tr>
<tr class="separator:af4b044752fe0a780a3f09743e9d8d58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9293eec4e7edf274155ed6a07dad8b16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a9293eec4e7edf274155ed6a07dad8b16">printSymmetryCompletion</a> (proshade_unsign noSyms, proshade_unsign verbose)</td></tr>
<tr class="memdesc:a9293eec4e7edf274155ed6a07dad8b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function simply prints the summary and warnings for cyclic symmetries detection completion.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a9293eec4e7edf274155ed6a07dad8b16">More...</a><br /></td></tr>
<tr class="separator:a9293eec4e7edf274155ed6a07dad8b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870711ceabba16c8fc79bd93d26b11a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a870711ceabba16c8fc79bd93d26b11a8">saveAllCSymmetries</a> (std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; detected, std::vector&lt; proshade_double * &gt; peaks, std::vector&lt; proshade_double * &gt; *ret, proshade_double axErr)</td></tr>
<tr class="memdesc:a870711ceabba16c8fc79bd93d26b11a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the detected symmetries indices and peaks and saves these in the main cyclic symmetries detection output format.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a870711ceabba16c8fc79bd93d26b11a8">More...</a><br /></td></tr>
<tr class="separator:a870711ceabba16c8fc79bd93d26b11a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4d85e82d1c55d0aa18795fea449adf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#abb4d85e82d1c55d0aa18795fea449adf">isSymmetrySame</a> (std::vector&lt; proshade_double * &gt; *ret, proshade_double *sym, proshade_double simThres)</td></tr>
<tr class="memdesc:abb4d85e82d1c55d0aa18795fea449adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if a very similar symmetry is not already saved.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#abb4d85e82d1c55d0aa18795fea449adf">More...</a><br /></td></tr>
<tr class="separator:abb4d85e82d1c55d0aa18795fea449adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ac919dd609bc6bded806c0f78201fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ab0ac919dd609bc6bded806c0f78201fd">saveDSymmetry</a> (std::vector&lt; proshade_double * &gt; *ret, std::vector&lt; proshade_double * &gt; *CSymList, proshade_unsign axisOne, proshade_unsign axisTwo)</td></tr>
<tr class="memdesc:ab0ac919dd609bc6bded806c0f78201fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function saves a detected dihedral symmetry to the dihedral symmetries list.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ab0ac919dd609bc6bded806c0f78201fd">More...</a><br /></td></tr>
<tr class="separator:ab0ac919dd609bc6bded806c0f78201fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37925ac477480c718451debb01a9c74a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a37925ac477480c718451debb01a9c74a">detectTetrahedralSymmetry</a> (std::vector&lt; proshade_double * &gt; *CSymList, proshade_double axErr, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:a37925ac477480c718451debb01a9c74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and decides whether basic requirements for tetrahedral symmetry are there.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a37925ac477480c718451debb01a9c74a">More...</a><br /></td></tr>
<tr class="separator:a37925ac477480c718451debb01a9c74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab702e9ca347642df5f49f937000b4184"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ab702e9ca347642df5f49f937000b4184">findTetra4C3s</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, proshade_double axErr, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_unsign verbose, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:ab702e9ca347642df5f49f937000b4184"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and finds the 4 C3 symmetries with correct angles required for full tetrahedral symmetry.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ab702e9ca347642df5f49f937000b4184">More...</a><br /></td></tr>
<tr class="separator:ab702e9ca347642df5f49f937000b4184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c193e95c7069fafa78dccc1de1aaa4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad8c193e95c7069fafa78dccc1de1aaa4">testGroupAgainstSymmetry</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_unsign &gt; *grp, proshade_double *sym, proshade_double axErr, proshade_double angle, bool improve, proshade_unsign pos=0)</td></tr>
<tr class="memdesc:ad8c193e95c7069fafa78dccc1de1aaa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tests whether a symmetry has particular angle to all members of a group.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad8c193e95c7069fafa78dccc1de1aaa4">More...</a><br /></td></tr>
<tr class="separator:ad8c193e95c7069fafa78dccc1de1aaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6093da290ce7b73a33e8b55f2c83491"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af6093da290ce7b73a33e8b55f2c83491">findMissingAxes</a> (std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; *possibilities, std::vector&lt; proshade_double * &gt; *CSymList, proshade_unsign requiredNoAxes, proshade_double axErr, proshade_double angle, proshade_unsign fold, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:af6093da290ce7b73a33e8b55f2c83491"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tries to find an axis which would complete a particular group of axes for polyhedral symmetry detection.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af6093da290ce7b73a33e8b55f2c83491">More...</a><br /></td></tr>
<tr class="separator:af6093da290ce7b73a33e8b55f2c83491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44ed609e8a3d59674b2b2256aec41f8"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad44ed609e8a3d59674b2b2256aec41f8">missingAxisHeight</a> (proshade_double xVal, proshade_double yVal, proshade_double zVal, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_unsign fold, proshade_double axErr)</td></tr>
<tr class="memdesc:ad44ed609e8a3d59674b2b2256aec41f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function searches for the highest peaks average that would produce the required axis and fold.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad44ed609e8a3d59674b2b2256aec41f8">More...</a><br /></td></tr>
<tr class="separator:ad44ed609e8a3d59674b2b2256aec41f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465606e58df7d6a2238d40c6919b2e58"><td class="memItemLeft" align="right" valign="top">std::vector&lt; proshade_double * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a465606e58df7d6a2238d40c6919b2e58">findMissingAxisPoints</a> (proshade_double xVal, proshade_double yVal, proshade_double zVal, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_double axErr)</td></tr>
<tr class="memdesc:a465606e58df7d6a2238d40c6919b2e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function searches for all the self-rotation map points conforming to the axis, returning their angles and heights.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a465606e58df7d6a2238d40c6919b2e58">More...</a><br /></td></tr>
<tr class="separator:a465606e58df7d6a2238d40c6919b2e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d576f90449b7d3fcf5ae4d3114c268"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a68d576f90449b7d3fcf5ae4d3114c268">sortArrVecHlp</a> (const proshade_double *a, const proshade_double *b)</td></tr>
<tr class="memdesc:a68d576f90449b7d3fcf5ae4d3114c268"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compares two arrays of two based on the first number.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a68d576f90449b7d3fcf5ae4d3114c268">More...</a><br /></td></tr>
<tr class="separator:a68d576f90449b7d3fcf5ae4d3114c268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc4353223fc752e0007b2adec193079"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5dc4353223fc752e0007b2adec193079">saveMissingAxisNewOnly</a> (std::vector&lt; proshade_double * &gt; *axVec, proshade_double axX, proshade_double axY, proshade_double axZ, proshade_double height, proshade_unsign fold, proshade_double axErr)</td></tr>
<tr class="memdesc:a5dc4353223fc752e0007b2adec193079"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function saves the recovered information about missing axis into a full symmetry, making sure no duplicates are created.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5dc4353223fc752e0007b2adec193079">More...</a><br /></td></tr>
<tr class="separator:a5dc4353223fc752e0007b2adec193079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ada2416687dbb0bec93603770cb4c83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a1ada2416687dbb0bec93603770cb4c83">searchMissingSymmetrySpace</a> (<a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_unsign &gt; *grp, std::vector&lt; proshade_double * &gt; *hlpVec, proshade_double axErr, proshade_double angle, proshade_unsign fold, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:a1ada2416687dbb0bec93603770cb4c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tests feasible axes against the missing axis criteria, returning a set of matching axes.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a1ada2416687dbb0bec93603770cb4c83">More...</a><br /></td></tr>
<tr class="separator:a1ada2416687dbb0bec93603770cb4c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193b0307e5bfe47bec26d3867d6750c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a193b0307e5bfe47bec26d3867d6750c1">findTetra3C2s</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, proshade_double axErr, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_unsign verbose, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:a193b0307e5bfe47bec26d3867d6750c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and finds the 3 C2 symmetries with correct angles required for full tetrahedral symmetry.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a193b0307e5bfe47bec26d3867d6750c1">More...</a><br /></td></tr>
<tr class="separator:a193b0307e5bfe47bec26d3867d6750c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5360c152697780177eb2676888cd5108"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5360c152697780177eb2676888cd5108">testGroupAgainstGroup</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_unsign &gt; *grp1, std::vector&lt; proshade_double * &gt; *RetList, std::vector&lt; proshade_unsign &gt; *grp2, proshade_double angle, proshade_double axErr)</td></tr>
<tr class="memdesc:a5360c152697780177eb2676888cd5108"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compares two groups of axes for a single pair having the required angle.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5360c152697780177eb2676888cd5108">More...</a><br /></td></tr>
<tr class="separator:a5360c152697780177eb2676888cd5108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d456057604616a7cf6b68f59b4f2d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a18d456057604616a7cf6b68f59b4f2d0">detectOctahedralSymmetry</a> (std::vector&lt; proshade_double * &gt; *CSymList, proshade_double axErr, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:a18d456057604616a7cf6b68f59b4f2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and decides whether basic requirements for octahhedral symmetry are there.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a18d456057604616a7cf6b68f59b4f2d0">More...</a><br /></td></tr>
<tr class="separator:a18d456057604616a7cf6b68f59b4f2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa63ba6643fd35a6fa67a969ef5e92d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#aaa63ba6643fd35a6fa67a969ef5e92d9">findOcta3C4s</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, proshade_double axErr, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_unsign verbose, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:aaa63ba6643fd35a6fa67a969ef5e92d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and finds the 3 C4 symmetries with perpendicular angles required for full octahedral symmetry.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#aaa63ba6643fd35a6fa67a969ef5e92d9">More...</a><br /></td></tr>
<tr class="separator:aaa63ba6643fd35a6fa67a969ef5e92d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae003234a38a3abfff24115ee51d99141"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ae003234a38a3abfff24115ee51d99141">findOcta4C3s</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, proshade_double axErr, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_unsign verbose, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:ae003234a38a3abfff24115ee51d99141"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and finds the four C3 symmetries with correct angles required for full octahedral symmetry.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ae003234a38a3abfff24115ee51d99141">More...</a><br /></td></tr>
<tr class="separator:ae003234a38a3abfff24115ee51d99141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47108b33b0fed84b73fc2d9769d93d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ae47108b33b0fed84b73fc2d9769d93d1">findOcta6C2s</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, proshade_double axErr, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_unsign verbose, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:ae47108b33b0fed84b73fc2d9769d93d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and finds the six C2 symmetries with correct angles required for full octahedral symmetry.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ae47108b33b0fed84b73fc2d9769d93d1">More...</a><br /></td></tr>
<tr class="separator:ae47108b33b0fed84b73fc2d9769d93d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9f533a789bd5c6031fa77b9649ed3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a6d9f533a789bd5c6031fa77b9649ed3d">findMissingAxesDual</a> (std::vector&lt; proshade_unsign &gt; *possibilities, std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, std::vector&lt; proshade_unsign &gt; *retGroup, proshade_unsign requiredNoAxes, proshade_double axErr, proshade_unsign noMatchesG1, proshade_double angle1, proshade_unsign noMatchesG2, proshade_double angle2, proshade_unsign fold, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj)</td></tr>
<tr class="memdesc:a6d9f533a789bd5c6031fa77b9649ed3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tries to find a particular symmetry axes which would complete a group of symmetries with two different angle requirement to another group.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a6d9f533a789bd5c6031fa77b9649ed3d">More...</a><br /></td></tr>
<tr class="separator:a6d9f533a789bd5c6031fa77b9649ed3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56b16f741c8701d43f8f74899c8ab2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad56b16f741c8701d43f8f74899c8ab2c">addAxisUnlessSame</a> (proshade_unsign fold, proshade_double axX, proshade_double axY, proshade_double axZ, proshade_double axHeight, std::vector&lt; proshade_double * &gt; *prosp, proshade_double axErr)</td></tr>
<tr class="memdesc:ad56b16f741c8701d43f8f74899c8ab2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function simply creates a new axis from information in aruments and tests if no such axis already exists, saving it if need be.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad56b16f741c8701d43f8f74899c8ab2c">More...</a><br /></td></tr>
<tr class="separator:ad56b16f741c8701d43f8f74899c8ab2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210ee0af651d440b68168882ead71c66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a210ee0af651d440b68168882ead71c66">checkFittingAxisDualAndSave</a> (std::vector&lt; proshade_unsign &gt; *retGroup, std::vector&lt; proshade_double * &gt; *ret, proshade_unsign fold, proshade_double axX, proshade_double axY, proshade_double axZ, std::vector&lt; proshade_double * &gt; *prosp, proshade_double axErr, proshade_unsign noMatchesG1, proshade_double angle1, proshade_unsign noMatchesG2, proshade_double angle2, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj)</td></tr>
<tr class="memdesc:a210ee0af651d440b68168882ead71c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a newly detected "missing" axis and tests it for belonging to the group, checking the height and replacing lower height members with better members.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a210ee0af651d440b68168882ead71c66">More...</a><br /></td></tr>
<tr class="separator:a210ee0af651d440b68168882ead71c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f09b90de1f15b345ee7998ff31327f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a4f09b90de1f15b345ee7998ff31327f3">detectIcosahedralSymmetry</a> (std::vector&lt; proshade_double * &gt; *CSymList, proshade_double axErr, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:a4f09b90de1f15b345ee7998ff31327f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and decides whether basic requirements for isosahedral symmetry are there.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a4f09b90de1f15b345ee7998ff31327f3">More...</a><br /></td></tr>
<tr class="separator:a4f09b90de1f15b345ee7998ff31327f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65eb2dbdadc031e511734b5a48e31b08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a65eb2dbdadc031e511734b5a48e31b08">findIcos6C5s</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, proshade_double axErr, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_unsign verbose, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:a65eb2dbdadc031e511734b5a48e31b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and finds the six C5 symmetries with given angles required for full icosahedral symmetry.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a65eb2dbdadc031e511734b5a48e31b08">More...</a><br /></td></tr>
<tr class="separator:a65eb2dbdadc031e511734b5a48e31b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fcf9bf5ad27ac119d76312b4bcf90b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad5fcf9bf5ad27ac119d76312b4bcf90b">predictIcosAxes</a> (<a class="el" href="class_pro_s_h_a_d_e__settings.html">ProSHADE_settings</a> *settings, std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, proshade_double axErr, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_unsign verbose, proshade_double minPeakHeight, proshade_double matrixTolerance)</td></tr>
<tr class="memdesc:ad5fcf9bf5ad27ac119d76312b4bcf90b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function predicts all icosahedral point group symmetry axes from the cyclic point groups list.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad5fcf9bf5ad27ac119d76312b4bcf90b">More...</a><br /></td></tr>
<tr class="separator:ad5fcf9bf5ad27ac119d76312b4bcf90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377aa42d9199d427d93efca48e3cd878"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a377aa42d9199d427d93efca48e3cd878">predictOctaAxes</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, proshade_double axErr, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_unsign verbose, proshade_double minPeakHeight, proshade_double matrixTolerance)</td></tr>
<tr class="memdesc:a377aa42d9199d427d93efca48e3cd878"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function predicts all octahedral point group symmetry axes from the cyclic point groups list.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a377aa42d9199d427d93efca48e3cd878">More...</a><br /></td></tr>
<tr class="separator:a377aa42d9199d427d93efca48e3cd878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede68f7d4dd7840b1bfcf8daa3156adf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#aede68f7d4dd7840b1bfcf8daa3156adf">findIcos10C3s</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, proshade_double axErr, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_unsign verbose, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:aede68f7d4dd7840b1bfcf8daa3156adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and finds the ten C3 symmetries with correct angles required for full icosahedral symmetry.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#aede68f7d4dd7840b1bfcf8daa3156adf">More...</a><br /></td></tr>
<tr class="separator:aede68f7d4dd7840b1bfcf8daa3156adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d6480c4de06bce2b7d05c0471eb000"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad0d6480c4de06bce2b7d05c0471eb000">findIcos15C2s</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, proshade_double axErr, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_unsign verbose, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:ad0d6480c4de06bce2b7d05c0471eb000"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and finds the fifteen C3 symmetries with correct angles required for full icosahedral symmetry.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad0d6480c4de06bce2b7d05c0471eb000">More...</a><br /></td></tr>
<tr class="separator:ad0d6480c4de06bce2b7d05c0471eb000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae266053664eb7cf916aa5e2d282e35dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ae266053664eb7cf916aa5e2d282e35dd">findMissingAxesTriple</a> (std::vector&lt; proshade_unsign &gt; *possibilities, std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, std::vector&lt; proshade_unsign &gt; *retGroup, proshade_unsign requiredNoAxes, proshade_double axErr, proshade_unsign noMatchesG1, proshade_double angle1, proshade_unsign noMatchesG2, proshade_double angle2, proshade_unsign noMatchesG3, proshade_double angle3, proshade_unsign fold, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj)</td></tr>
<tr class="memdesc:ae266053664eb7cf916aa5e2d282e35dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tries to find a particular symmetry axis which would complete a group of symmetries with three different angle requirement to another group.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ae266053664eb7cf916aa5e2d282e35dd">More...</a><br /></td></tr>
<tr class="separator:ae266053664eb7cf916aa5e2d282e35dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194944b48a4b6b523ef251a2a03eab17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a194944b48a4b6b523ef251a2a03eab17">checkFittingAxisTripleAndSave</a> (std::vector&lt; proshade_unsign &gt; *retGroup, std::vector&lt; proshade_double * &gt; *ret, proshade_unsign fold, proshade_double axX, proshade_double axY, proshade_double axZ, std::vector&lt; proshade_double * &gt; *prosp, proshade_double axErr, proshade_unsign noMatchesG1, proshade_double angle1, proshade_unsign noMatchesG2, proshade_double angle2, proshade_unsign noMatchesG3, proshade_double angle3, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj)</td></tr>
<tr class="memdesc:a194944b48a4b6b523ef251a2a03eab17"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a newly detected "missing" axis and tests it for belonging to the group, checking the height and replacing lower height members with better members.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a194944b48a4b6b523ef251a2a03eab17">More...</a><br /></td></tr>
<tr class="separator:a194944b48a4b6b523ef251a2a03eab17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace contains the symmetry detection related code. </p>
<p>The <a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html" title="This namespace contains the symmetry detection related code.">ProSHADE_internal_symmetry</a> namespace contains the functions related to the symmetry detection task. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ad56b16f741c8701d43f8f74899c8ab2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad56b16f741c8701d43f8f74899c8ab2c">&#9670;&nbsp;</a></span>addAxisUnlessSame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::addAxisUnlessSame </td>
          <td>(</td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>prosp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function simply creates a new axis from information in aruments and tests if no such axis already exists, saving it if need be. </p>
<p>This is a simple helper function, which takes all the new axis information and creates the ProSHADE axis representation from these. It then proceeds to check if such axis does not already exist in the supplied vector, if not, it saves the new axis; alternatively, it just discards the created axis and terminates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fold</td><td>The fold of the searched for axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axX</td><td>The x-axis element of the new axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axY</td><td>The y-axis element of the new axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axZ</td><td>The z-axis element of the new axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axHeight</td><td>The average peak height of the new axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prosp</td><td>The vector to which the axis is to be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l02527">2527</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02528"></a><span class="lineno"> 2528</span>&#160;{</div>
<div class="line"><a name="l02529"></a><span class="lineno"> 2529</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l02530"></a><span class="lineno"> 2530</span>&#160;    proshade_double* symHlp                           = <span class="keyword">new</span> proshade_double[6];</div>
<div class="line"><a name="l02531"></a><span class="lineno"> 2531</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( symHlp, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l02532"></a><span class="lineno"> 2532</span>&#160;    </div>
<div class="line"><a name="l02533"></a><span class="lineno"> 2533</span>&#160;    <span class="comment">//================================================ Fill in the prospective axis</span></div>
<div class="line"><a name="l02534"></a><span class="lineno"> 2534</span>&#160;    symHlp[0]                                         = <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( fold );</div>
<div class="line"><a name="l02535"></a><span class="lineno"> 2535</span>&#160;    symHlp[1]                                         = axX;</div>
<div class="line"><a name="l02536"></a><span class="lineno"> 2536</span>&#160;    symHlp[2]                                         = axY;</div>
<div class="line"><a name="l02537"></a><span class="lineno"> 2537</span>&#160;    symHlp[3]                                         = axZ;</div>
<div class="line"><a name="l02538"></a><span class="lineno"> 2538</span>&#160;    symHlp[4]                                         = 2.0 * M_PI / symHlp[0];</div>
<div class="line"><a name="l02539"></a><span class="lineno"> 2539</span>&#160;    symHlp[5]                                         = axHeight;</div>
<div class="line"><a name="l02540"></a><span class="lineno"> 2540</span>&#160;    </div>
<div class="line"><a name="l02541"></a><span class="lineno"> 2541</span>&#160;    <span class="comment">//================================================ If it is not the same as already saved axes</span></div>
<div class="line"><a name="l02542"></a><span class="lineno"> 2542</span>&#160;    <span class="keywordflow">if</span> ( !<a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#abb4d85e82d1c55d0aa18795fea449adf">ProSHADE_internal_symmetry::isSymmetrySame</a> ( prosp, symHlp, axErr ) )</div>
<div class="line"><a name="l02543"></a><span class="lineno"> 2543</span>&#160;    {</div>
<div class="line"><a name="l02544"></a><span class="lineno"> 2544</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a>     ( prosp, symHlp );</div>
<div class="line"><a name="l02545"></a><span class="lineno"> 2545</span>&#160;    }</div>
<div class="line"><a name="l02546"></a><span class="lineno"> 2546</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l02547"></a><span class="lineno"> 2547</span>&#160;    {</div>
<div class="line"><a name="l02548"></a><span class="lineno"> 2548</span>&#160;        <span class="keyword">delete</span>[] symHlp;</div>
<div class="line"><a name="l02549"></a><span class="lineno"> 2549</span>&#160;    }</div>
<div class="line"><a name="l02550"></a><span class="lineno"> 2550</span>&#160;    </div>
<div class="line"><a name="l02551"></a><span class="lineno"> 2551</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l02552"></a><span class="lineno"> 2552</span>&#160;    return ;</div>
<div class="line"><a name="l02553"></a><span class="lineno"> 2553</span>&#160;    </div>
<div class="line"><a name="l02554"></a><span class="lineno"> 2554</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ade9b717260e86c8f24bcbe6d17fe4e06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9b717260e86c8f24bcbe6d17fe4e06">&#9670;&nbsp;</a></span>addZeroPeakToGroups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::addZeroPeakToGroups </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>grpsVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; &amp;&#160;</td>
          <td class="paramname"><em>peaks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes the peak groups and adds zero peak to each of them. </p>
<p>This function takes all of the detected peak axis groups and the list of peaks. It then proceeds to add a single peak per a group to the peaks list; this newly added peak has the same axis as the group, but zero angle. The function also adds the index of this new peak to the peak group, so that the group now has a new member, a peak with zero angle and the same axis.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grpsVec</td><td>A list of all symmetry axis groups. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">peaks</td><td>The vector of all peaks from which the group indices are to be drawn. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00621">621</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;{</div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;    <span class="comment">//================================================ Do your job</span></div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; static_cast&lt;proshade_unsign&gt; ( grpsVec.size() ); iter++ )</div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;    {</div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;        proshade_double* hlpP                         = <span class="keyword">new</span> proshade_double [5];</div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a> ( hlpP, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;        hlpP[0]                                       = peaks.at(grpsVec.at(iter).at(0))[0];</div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;        hlpP[1]                                       = peaks.at(grpsVec.at(iter).at(0))[1];</div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;        hlpP[2]                                       = peaks.at(grpsVec.at(iter).at(0))[2];</div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;        hlpP[3]                                       = 0.0;</div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;        hlpP[4]                                       = peaks.at(grpsVec.at(iter).at(0))[4];</div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a>     ( &amp;grpsVec.at(iter), <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( peaks.size() ) );</div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a>     ( &amp;peaks, hlpP );</div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;    }</div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;    </div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;    return ;</div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160; </div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a074d9c1d40d7491ea9f9f9639744e18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a074d9c1d40d7491ea9f9f9639744e18d">&#9670;&nbsp;</a></span>checkExpectedAgainstFound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">proshade_unsign ProSHADE_internal_symmetry::checkExpectedAgainstFound </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt;&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt;&#160;</td>
          <td class="paramname"><em>peaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double &gt; *&#160;</td>
          <td class="paramname"><em>expAngs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>matchedAngs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>missingAngs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>angTol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes the expected peak rotations for given fold. </p>
<p>This function compares the expected and the detected peak rotation angle values to check if the complete C symmetry is found within this peak axis group. It also saves the indices of the matched and missing peaks and returns the number of consecutive mathes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>A single symmetry axis group indices to be processed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">peaks</td><td>The vector of all peaks from which the indices are drawn. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expAngs</td><td>A vector where the expected peak rotation values are saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matchedAngs</td><td>A vector where the indices of matched peaks will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">missingAngs</td><td>A vector where the indices of missing peaks will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angTol</td><td>The tolerance for matching the expected and found peak rotation angles. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>An integer with the longest consecutive streak of matched values. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00734">734</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;{</div>
<div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;    proshade_unsign ret                               = 0;</div>
<div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;    proshade_unsign retHlp                            = 0;</div>
<div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;    proshade_double groupAngle                        = expAngs-&gt;at(1) - expAngs-&gt;at(0);</div>
<div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;    <span class="keywordtype">bool</span> matchedThisPeak                              = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;    <span class="keywordtype">bool</span> noDoubleMatches                              = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;    std::vector &lt; proshade_unsign &gt; matchedAlready;</div>
<div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;    </div>
<div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;    <span class="comment">//================================================ For each expected peak rotation angle value</span></div>
<div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign expAngIt = 0; expAngIt &lt; static_cast&lt;proshade_unsign&gt; ( expAngs-&gt;size() ); expAngIt++ )</div>
<div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;    {</div>
<div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;        <span class="comment">//============================================ For each peak in the group</span></div>
<div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;        matchedThisPeak                               = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign peakIt = 0; peakIt &lt; static_cast&lt;proshade_unsign&gt; ( grp.size() ); peakIt++ )</div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;        {</div>
<div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;            <span class="keywordflow">if</span> ( ( expAngs-&gt;at(expAngIt) &lt; ( peaks.at(grp.at(peakIt))[3] + angTol ) ) &amp;&amp;</div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;                 ( expAngs-&gt;at(expAngIt) &gt; ( peaks.at(grp.at(peakIt))[3] - angTol ) ) )</div>
<div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;            {</div>
<div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;                noDoubleMatches                       = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;                <span class="keywordflow">for</span> ( proshade_unsign ndm = 0; ndm &lt; static_cast&lt;proshade_unsign&gt; ( matchedAlready.size() ); ndm++ )</div>
<div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;                {</div>
<div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;                    <span class="keywordflow">if</span> ( matchedAlready.at(ndm) == grp.at(peakIt) ) { noDoubleMatches = <span class="keyword">true</span>; <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;                }</div>
<div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;                </div>
<div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;                <span class="keywordflow">if</span> ( !noDoubleMatches )</div>
<div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;                {</div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;                    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( matchedAngs, grp.at(peakIt) );</div>
<div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;                    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;matchedAlready, grp.at(peakIt) );</div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;                    matchedThisPeak                   = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;                    <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;                }</div>
<div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;            }</div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;        }</div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;        </div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;        <span class="comment">//============================================ If not matched, add to missing</span></div>
<div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;        <span class="keywordflow">if</span> ( !matchedThisPeak )</div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;        {</div>
<div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( missingAngs, expAngIt );</div>
<div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;        }</div>
<div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;    }</div>
<div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;    </div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;    <span class="comment">//================================================ Find the number of consecutive matches</span></div>
<div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;    <span class="keywordflow">if</span> ( matchedAngs-&gt;size () &gt; 1 )</div>
<div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;    {</div>
<div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign iter = 1; iter &lt; static_cast&lt;unsigned int&gt; ( matchedAngs-&gt;size () ); iter++ )</div>
<div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;        {</div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;            <span class="keywordflow">if</span> ( ( ( peaks.at(matchedAngs-&gt;at(iter-1))[3] + groupAngle ) &lt; ( peaks.at(matchedAngs-&gt;at(iter))[3] + angTol ) ) &amp;&amp;</div>
<div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;                 ( ( peaks.at(matchedAngs-&gt;at(iter-1))[3] + groupAngle ) &gt; ( peaks.at(matchedAngs-&gt;at(iter))[3] - angTol ) ) )</div>
<div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;            {</div>
<div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;                retHlp                       += 1;</div>
<div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;            }</div>
<div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;            {</div>
<div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;                retHlp                        = 0;</div>
<div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;            }</div>
<div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;            <span class="keywordflow">if</span> ( retHlp &gt; ret ) { ret = retHlp; }</div>
<div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;        }</div>
<div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;    }</div>
<div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160; </div>
<div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;    <span class="keywordflow">return</span>                                            ( ret + 1 ); <span class="comment">// This is because the count of matches is the count of intervals between numbers, so +1 to get the count of matched numbers.</span></div>
<div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160; </div>
<div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a210ee0af651d440b68168882ead71c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210ee0af651d440b68168882ead71c66">&#9670;&nbsp;</a></span>checkFittingAxisDualAndSave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_symmetry::checkFittingAxisDualAndSave </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>retGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>prosp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>noMatchesG1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>angle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>noMatchesG2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>angle2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes a newly detected "missing" axis and tests it for belonging to the group, checking the height and replacing lower height members with better members. </p>
<p>This function takes the list of already detected axes, information about the tested new axis and the conditions for belonging. It then proceeds to check if the new axis conforms to the conditions of belonging. If so, it then checks if the axis height is high enough to be considered as part of the group. Again, if so, it will save this new axis to the old set, replacing any old axis with this new one, if it is the same and has better height.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">retGroup</td><td>A vector of indices in the ret list which form the group to which new axes are compared to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>A list of already detected axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fold</td><td>The fold of the searched for axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axX</td><td>The x-axis element of the new axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axY</td><td>The y-axis element of the new axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axZ</td><td>The z-axis element of the new axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prosp</td><td>The vector to which the axis is to be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noMatchesG1</td><td>The number of axes from ret that need to be matched with angle1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle1</td><td>The angle with which noMatchesG1 axes need to be matched with the retGroup axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noMatchesG2</td><td>The number of axes from ret that need to be matched with angle2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle2</td><td>The angle with which noMatchesG2 axes need to be matched with the retGroup axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataObj</td><td>The full data holding object pointer - this is to get access to self-rotation function values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Bool</td><td>True if the axis was added to the group, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l02577">2577</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02578"></a><span class="lineno"> 2578</span>&#160;{</div>
<div class="line"><a name="l02579"></a><span class="lineno"> 2579</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l02580"></a><span class="lineno"> 2580</span>&#160;    proshade_unsign noG1                              = 0;</div>
<div class="line"><a name="l02581"></a><span class="lineno"> 2581</span>&#160;    proshade_unsign noG2                              = 0;</div>
<div class="line"><a name="l02582"></a><span class="lineno"> 2582</span>&#160;    proshade_double dotProd                           = 0.0;</div>
<div class="line"><a name="l02583"></a><span class="lineno"> 2583</span>&#160;    proshade_double axHeight                          = 0.0;</div>
<div class="line"><a name="l02584"></a><span class="lineno"> 2584</span>&#160;    </div>
<div class="line"><a name="l02585"></a><span class="lineno"> 2585</span>&#160;    <span class="comment">//================================================ Find the angle and count dual matching frequencies</span></div>
<div class="line"><a name="l02586"></a><span class="lineno"> 2586</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign rIt = 0; rIt &lt; static_cast&lt;proshade_unsign&gt; ( retGroup-&gt;size() ); rIt++ )</div>
<div class="line"><a name="l02587"></a><span class="lineno"> 2587</span>&#160;    {</div>
<div class="line"><a name="l02588"></a><span class="lineno"> 2588</span>&#160;        dotProd                                       = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> ( &amp;ret-&gt;at(retGroup-&gt;at(rIt))[1],</div>
<div class="line"><a name="l02589"></a><span class="lineno"> 2589</span>&#160;                                                                                                     &amp;ret-&gt;at(retGroup-&gt;at(rIt))[2],</div>
<div class="line"><a name="l02590"></a><span class="lineno"> 2590</span>&#160;                                                                                                     &amp;ret-&gt;at(retGroup-&gt;at(rIt))[3],</div>
<div class="line"><a name="l02591"></a><span class="lineno"> 2591</span>&#160;                                                                                                     &amp;axX, &amp;axY, &amp;axZ );</div>
<div class="line"><a name="l02592"></a><span class="lineno"> 2592</span>&#160;        </div>
<div class="line"><a name="l02593"></a><span class="lineno"> 2593</span>&#160;        <span class="keywordflow">if</span> ( ( std::abs ( dotProd ) &gt; ( angle1 - axErr ) ) &amp;&amp; ( std::abs ( dotProd ) &lt; ( angle1 + axErr ) ) ) { noG1 += 1; <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l02594"></a><span class="lineno"> 2594</span>&#160;        <span class="keywordflow">if</span> ( ( std::abs ( dotProd ) &gt; ( angle2 - axErr ) ) &amp;&amp; ( std::abs ( dotProd ) &lt; ( angle2 + axErr ) ) ) { noG2 += 1; <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l02595"></a><span class="lineno"> 2595</span>&#160;    }</div>
<div class="line"><a name="l02596"></a><span class="lineno"> 2596</span>&#160;    </div>
<div class="line"><a name="l02597"></a><span class="lineno"> 2597</span>&#160;    <span class="comment">//================================================ If correct frequencies are matched, check height.</span></div>
<div class="line"><a name="l02598"></a><span class="lineno"> 2598</span>&#160;    <span class="keywordflow">if</span> ( ( noG1 == noMatchesG1 ) &amp;&amp; ( noG2 == noMatchesG2 ) )</div>
<div class="line"><a name="l02599"></a><span class="lineno"> 2599</span>&#160;    {</div>
<div class="line"><a name="l02600"></a><span class="lineno"> 2600</span>&#160;        <span class="comment">//============================================ Is the height good enough?</span></div>
<div class="line"><a name="l02601"></a><span class="lineno"> 2601</span>&#160;        axHeight                                      = <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad44ed609e8a3d59674b2b2256aec41f8">ProSHADE_internal_symmetry::missingAxisHeight</a> ( axX, axY, axZ, dataObj, fold, axErr );</div>
<div class="line"><a name="l02602"></a><span class="lineno"> 2602</span>&#160;        </div>
<div class="line"><a name="l02603"></a><span class="lineno"> 2603</span>&#160;        <span class="comment">//============================================ If so, save</span></div>
<div class="line"><a name="l02604"></a><span class="lineno"> 2604</span>&#160;        <span class="keywordflow">if</span> ( axHeight &gt; 0.1 )</div>
<div class="line"><a name="l02605"></a><span class="lineno"> 2605</span>&#160;        {</div>
<div class="line"><a name="l02606"></a><span class="lineno"> 2606</span>&#160;            proshade_unsign prevProsp                 = <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( prosp-&gt;size() );</div>
<div class="line"><a name="l02607"></a><span class="lineno"> 2607</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad56b16f741c8701d43f8f74899c8ab2c">ProSHADE_internal_symmetry::addAxisUnlessSame</a> ( fold, axX, axY, axZ, axHeight, prosp, axErr );</div>
<div class="line"><a name="l02608"></a><span class="lineno"> 2608</span>&#160;            </div>
<div class="line"><a name="l02609"></a><span class="lineno"> 2609</span>&#160;            <span class="keywordflow">if</span> ( <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( prosp-&gt;size() ) &gt; prevProsp ) { <span class="keywordflow">return</span> ( <span class="keyword">true</span> ); }</div>
<div class="line"><a name="l02610"></a><span class="lineno"> 2610</span>&#160;            <span class="keywordflow">else</span>                                                              { <span class="keywordflow">return</span> ( <span class="keyword">false</span> ); }</div>
<div class="line"><a name="l02611"></a><span class="lineno"> 2611</span>&#160;        }</div>
<div class="line"><a name="l02612"></a><span class="lineno"> 2612</span>&#160;    }</div>
<div class="line"><a name="l02613"></a><span class="lineno"> 2613</span>&#160;    </div>
<div class="line"><a name="l02614"></a><span class="lineno"> 2614</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l02615"></a><span class="lineno"> 2615</span>&#160;    <span class="keywordflow">return</span>                                            ( <span class="keyword">false</span> );</div>
<div class="line"><a name="l02616"></a><span class="lineno"> 2616</span>&#160;    </div>
<div class="line"><a name="l02617"></a><span class="lineno"> 2617</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a194944b48a4b6b523ef251a2a03eab17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194944b48a4b6b523ef251a2a03eab17">&#9670;&nbsp;</a></span>checkFittingAxisTripleAndSave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::checkFittingAxisTripleAndSave </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>retGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>prosp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>noMatchesG1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>angle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>noMatchesG2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>angle2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>noMatchesG3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>angle3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes a newly detected "missing" axis and tests it for belonging to the group, checking the height and replacing lower height members with better members. </p>
<p>This function takes the list of already detected axes, information about the tested new axis and the conditions for belonging. It then proceeds to check if the new axis conforms to the conditions of belonging. If so, it then checks if the axis height is high enough to be considered as part of the group. Again, if so, it will save this new axis to the old set, replacing any old axis with this new one, if it is the same and has better height.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">retGroup</td><td>A vector of indices in the ret list which form the group to which new axes are compared to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>A list of already detected axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fold</td><td>The fold of the searched for axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axX</td><td>The x-axis element of the new axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axY</td><td>The y-axis element of the new axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axZ</td><td>The z-axis element of the new axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prosp</td><td>The vector to which the axis is to be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noMatchesG1</td><td>The number of axes from ret that need to be matched with angle1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle1</td><td>The angle with which noMatchesG1 axes need to be matched with the retGroup axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noMatchesG2</td><td>The number of axes from ret that need to be matched with angle2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle2</td><td>The angle with which noMatchesG2 axes need to be matched with the retGroup axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noMatchesG3</td><td>The number of axes from ret that need to be matched with angle3. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle3</td><td>The angle with which noMatchesG3 axes need to be matched with the retGroup axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataObj</td><td>The full data holding object pointer - this is to get access to self-rotation function values. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l03522">3522</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03523"></a><span class="lineno"> 3523</span>&#160;{</div>
<div class="line"><a name="l03524"></a><span class="lineno"> 3524</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l03525"></a><span class="lineno"> 3525</span>&#160;    proshade_unsign noG1                              = 0;</div>
<div class="line"><a name="l03526"></a><span class="lineno"> 3526</span>&#160;    proshade_unsign noG2                              = 0;</div>
<div class="line"><a name="l03527"></a><span class="lineno"> 3527</span>&#160;    proshade_unsign noG3                              = 0;</div>
<div class="line"><a name="l03528"></a><span class="lineno"> 3528</span>&#160;    proshade_double dotProd                           = 0.0;</div>
<div class="line"><a name="l03529"></a><span class="lineno"> 3529</span>&#160;    proshade_double axHeight                          = 0.0;</div>
<div class="line"><a name="l03530"></a><span class="lineno"> 3530</span>&#160;    </div>
<div class="line"><a name="l03531"></a><span class="lineno"> 3531</span>&#160;    <span class="comment">//================================================ Find the angle and count dual matching frequencies</span></div>
<div class="line"><a name="l03532"></a><span class="lineno"> 3532</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign rIt = 0; rIt &lt; static_cast&lt;proshade_unsign&gt; ( retGroup-&gt;size() ); rIt++ )</div>
<div class="line"><a name="l03533"></a><span class="lineno"> 3533</span>&#160;    {</div>
<div class="line"><a name="l03534"></a><span class="lineno"> 3534</span>&#160;        dotProd                                       = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> ( &amp;ret-&gt;at(retGroup-&gt;at(rIt))[1],</div>
<div class="line"><a name="l03535"></a><span class="lineno"> 3535</span>&#160;                                                                                                     &amp;ret-&gt;at(retGroup-&gt;at(rIt))[2],</div>
<div class="line"><a name="l03536"></a><span class="lineno"> 3536</span>&#160;                                                                                                     &amp;ret-&gt;at(retGroup-&gt;at(rIt))[3],</div>
<div class="line"><a name="l03537"></a><span class="lineno"> 3537</span>&#160;                                                                                                     &amp;axX, &amp;axY, &amp;axZ );</div>
<div class="line"><a name="l03538"></a><span class="lineno"> 3538</span>&#160;        </div>
<div class="line"><a name="l03539"></a><span class="lineno"> 3539</span>&#160;        <span class="keywordflow">if</span> ( ( std::abs ( dotProd ) &gt; ( angle1 - axErr ) ) &amp;&amp; ( std::abs ( dotProd ) &lt; ( angle1 + axErr ) ) ) { noG1 += 1; <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l03540"></a><span class="lineno"> 3540</span>&#160;        <span class="keywordflow">if</span> ( ( std::abs ( dotProd ) &gt; ( angle2 - axErr ) ) &amp;&amp; ( std::abs ( dotProd ) &lt; ( angle2 + axErr ) ) ) { noG2 += 1; <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l03541"></a><span class="lineno"> 3541</span>&#160;        <span class="keywordflow">if</span> ( ( std::abs ( dotProd ) &gt; ( angle3 - axErr ) ) &amp;&amp; ( std::abs ( dotProd ) &lt; ( angle3 + axErr ) ) ) { noG3 += 1; <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l03542"></a><span class="lineno"> 3542</span>&#160;    }</div>
<div class="line"><a name="l03543"></a><span class="lineno"> 3543</span>&#160;    </div>
<div class="line"><a name="l03544"></a><span class="lineno"> 3544</span>&#160;    <span class="comment">//================================================ If correct frequencies are matched, check height.</span></div>
<div class="line"><a name="l03545"></a><span class="lineno"> 3545</span>&#160;    <span class="keywordflow">if</span> ( ( noG1 == noMatchesG1 ) &amp;&amp; ( noG2 == noMatchesG2 ) &amp;&amp; ( noG3 == noMatchesG3 ) )</div>
<div class="line"><a name="l03546"></a><span class="lineno"> 3546</span>&#160;    {</div>
<div class="line"><a name="l03547"></a><span class="lineno"> 3547</span>&#160;        <span class="comment">//============================================ Is the height good enough?</span></div>
<div class="line"><a name="l03548"></a><span class="lineno"> 3548</span>&#160;        axHeight                                      = <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad44ed609e8a3d59674b2b2256aec41f8">ProSHADE_internal_symmetry::missingAxisHeight</a> ( axX, axY, axZ, dataObj, fold, axErr );</div>
<div class="line"><a name="l03549"></a><span class="lineno"> 3549</span>&#160;        </div>
<div class="line"><a name="l03550"></a><span class="lineno"> 3550</span>&#160;        <span class="comment">//============================================ If so, save</span></div>
<div class="line"><a name="l03551"></a><span class="lineno"> 3551</span>&#160;        <span class="keywordflow">if</span> ( axHeight &gt; 0.1 )</div>
<div class="line"><a name="l03552"></a><span class="lineno"> 3552</span>&#160;        {</div>
<div class="line"><a name="l03553"></a><span class="lineno"> 3553</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad56b16f741c8701d43f8f74899c8ab2c">ProSHADE_internal_symmetry::addAxisUnlessSame</a> ( fold, axX, axY, axZ, axHeight, prosp, axErr );</div>
<div class="line"><a name="l03554"></a><span class="lineno"> 3554</span>&#160;        }</div>
<div class="line"><a name="l03555"></a><span class="lineno"> 3555</span>&#160;    }</div>
<div class="line"><a name="l03556"></a><span class="lineno"> 3556</span>&#160;    </div>
<div class="line"><a name="l03557"></a><span class="lineno"> 3557</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l03558"></a><span class="lineno"> 3558</span>&#160;    return ;</div>
<div class="line"><a name="l03559"></a><span class="lineno"> 3559</span>&#160;    </div>
<div class="line"><a name="l03560"></a><span class="lineno"> 3560</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aacced7feb8ce5251dce199505912d997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacced7feb8ce5251dce199505912d997">&#9670;&nbsp;</a></span>checkForMissingPeak()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">proshade_double ProSHADE_internal_symmetry::checkForMissingPeak </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>heightThres</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axTol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks for the high of the correlation for particular rotation angle and axis. </p>
<p>This is the core of missing peaks procedure. This function takes the angle-axis representation of the sought after peak/rotation and searches the data objects (respectivelly its inverse SO(3) Fourier Transform map) for the highest point conforming to these specifications. It then returns the highest value found, so that it could be decided whether the symmetry search has been successfully completed or whether the symmetry was not found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataObj</td><td>The data object for which symmetry is being searched. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The x-axis element of the searched for rotation angle-axis representation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The y-axis element of the searched for rotation angle-axis representation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>The z-axis element of the searched for rotation angle-axis representation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle</td><td>The angle element of the searched for rotation angle-axis representation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heightThres</td><td>The required self-rotation map height for this rotation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axTol</td><td>The tolerance on axis matching when searching for the rotation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>The height of highest matching map point. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00816">816</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;{</div>
<div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;    proshade_double ret                               = 0.0;</div>
<div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;    proshade_unsign arrIndex                          = 0;</div>
<div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;    proshade_double* rotMat                           = <span class="keyword">new</span> proshade_double [9];</div>
<div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( rotMat, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;    proshade_double pointHeight, euA, euB, euG, xPk, yPk, zPk, anglPk;</div>
<div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;    proshade_double angTol                            = std::acos ( 1.0 - axTol );</div>
<div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;    </div>
<div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;    <span class="comment">//================================================ Search the self-rotation map</span></div>
<div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign xIt = 0; xIt &lt; ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a152b43815a3d3debd4b60751d9c8afdd">getMaxBand</a>() * 2 ); xIt++ )</div>
<div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;    {</div>
<div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign yIt = 0; yIt &lt; ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a152b43815a3d3debd4b60751d9c8afdd">getMaxBand</a>() * 2 ); yIt++ )</div>
<div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;        {</div>
<div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;            <span class="keywordflow">for</span> ( proshade_unsign zIt = 0; zIt &lt; ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a152b43815a3d3debd4b60751d9c8afdd">getMaxBand</a>() * 2 ); zIt++ )</div>
<div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;            {</div>
<div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;                <span class="comment">//==================================== Get height and check against threshold</span></div>
<div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;                arrIndex                              = zIt  + ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a152b43815a3d3debd4b60751d9c8afdd">getMaxBand</a>() * 2 ) * ( yIt  + ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a152b43815a3d3debd4b60751d9c8afdd">getMaxBand</a>() * 2 ) * xIt );</div>
<div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;                pointHeight                           = pow( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a2eb10989a2f8d46b849cdaf8410b68be">getInvSO3Coeffs</a>()[arrIndex][0], 2.0 ) + pow( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a2eb10989a2f8d46b849cdaf8410b68be">getInvSO3Coeffs</a>()[arrIndex][1], 2.0 );</div>
<div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;                <span class="keywordflow">if</span> ( pointHeight &lt; heightThres ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;                </div>
<div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;                <span class="comment">//==================================== Get angle-axis values</span></div>
<div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;                <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#acf6c5376edac98e54ef0e418cd05d706">ProSHADE_internal_maths::getEulerZXZFromSOFTPosition</a> ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a152b43815a3d3debd4b60751d9c8afdd">getMaxBand</a>(), <span class="keyword">static_cast&lt;</span>proshade_signed<span class="keyword">&gt;</span> ( xIt ),</div>
<div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;                                                                       <span class="keyword">static_cast&lt;</span>proshade_signed<span class="keyword">&gt;</span> ( yIt ), <span class="keyword">static_cast&lt;</span>proshade_signed<span class="keyword">&gt;</span> ( zIt ),</div>
<div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;                                                                       &amp;euA, &amp;euB, &amp;euG );</div>
<div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;                <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#abd9fe573a48f499dd7d1df4f779222f1">ProSHADE_internal_maths::getRotationMatrixFromEulerZXZAngles</a> ( euA, euB, euG, rotMat );</div>
<div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;                <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#aafc6f1626c7463de53c9f4f6fa11db22">ProSHADE_internal_maths::getAxisAngleFromRotationMatrix</a> ( rotMat, &amp;xPk, &amp;yPk, &amp;zPk, &amp;anglPk );</div>
<div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;                </div>
<div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;                <span class="comment">//==================================== Check for matching angle</span></div>
<div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;                <span class="keywordflow">if</span> ( ( ( std::abs( anglPk ) - angTol ) &lt; std::abs ( angle ) ) &amp;&amp; ( ( std::abs( anglPk ) + angTol ) &gt; std::abs ( angle ) ) )</div>
<div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;                {</div>
<div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;                    <span class="comment">//================================ Make sure vector direction is the same</span></div>
<div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;                    <span class="keywordflow">if</span> ( ( ( std::max( std::abs( xPk ), std::max( std::abs( yPk ), std::abs( zPk ) ) ) == std::abs( xPk ) ) &amp;&amp; ( xPk &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;                         ( ( std::max( std::abs( xPk ), std::max( std::abs( yPk ), std::abs( zPk ) ) ) == std::abs( yPk ) ) &amp;&amp; ( yPk &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;                         ( ( std::max( std::abs( xPk ), std::max( std::abs( yPk ), std::abs( zPk ) ) ) == std::abs( zPk ) ) &amp;&amp; ( zPk &lt; 0.0 ) ) )</div>
<div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;                    {</div>
<div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;                        xPk                          *= -1.0;</div>
<div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;                        yPk                          *= -1.0;</div>
<div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;                        zPk                          *= -1.0;</div>
<div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;                        anglPk                       *= -1.0;</div>
<div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;                    }</div>
<div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;                    </div>
<div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;                    <span class="comment">//================================ Compare axis elements</span></div>
<div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;                    <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2b2f67cba1eea57f19fdaf062db74fde">ProSHADE_internal_maths::vectorOrientationSimilarity</a> ( xPk, yPk, zPk, x, y, z, axTol ) )</div>
<div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;                    {</div>
<div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;                        <span class="keywordflow">if</span> ( ret &lt; pointHeight ) { ret = pointHeight; }</div>
<div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;                    }</div>
<div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;                }</div>
<div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;            }</div>
<div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;        }</div>
<div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;    }</div>
<div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;    </div>
<div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;    <span class="keywordflow">return</span>                                            ( ret );</div>
<div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160; </div>
<div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3008592c3ce58393395e03dac26c3626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3008592c3ce58393395e03dac26c3626">&#9670;&nbsp;</a></span>completeMissingCSymmetry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_symmetry::completeMissingCSymmetry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>peaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>missingPeaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double &gt; *&#160;</td>
          <td class="paramname"><em>expectedAngles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>matchedPeaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErrTolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function does the complete missing peak searching and filling in the missing peaks. </p>
<p>This function does the complete work on missing peaks and detection of symmetries affected by them. It firstly decides on the threshold for a missing peak height and it then proceeds to check all missing peaks for being in the inverse SO(3) FT map. Any detected peaks will be saved to all appropriate variables (as supplied) and finally, if all missing peaks were sucessfully found, it will return true, otherwise false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataObj</td><td>The data object for which symmetry is being searched. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fold</td><td>This is the fold value of the detected C symmetry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>Vector with the indices of members of this symmetry axis group. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">peaks</td><td>A vector of pointers where angle-axis representations of the peaks is saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">missingPeaks</td><td>Vector with the indices of missing rotation angles (indices are from the expected peaks vector, not peaks vector!). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expectedAngles</td><td>Vector with the expected rotation angle values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErrTolerance</td><td>The allowed error on matching axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>How loud the standard output of this run should be? </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>Was the missing symmetry part completion successfull? </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00924">924</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;{</div>
<div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;    <span class="keywordtype">bool</span> ret                                          = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;    </div>
<div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;    <span class="comment">//================================================ Report searching for missing peaks</span></div>
<div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;    std::stringstream hlpSSP;</div>
<div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;    hlpSSP &lt;&lt; <span class="stringliteral">&quot;Searching for missing peaks for symmetry C&quot;</span> &lt;&lt; fold;</div>
<div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a6aa8cdb600cad623409802cfaed494fa">ProSHADE_internal_messages::printProgressMessage</a> ( verbose, 4, hlpSSP.str() );</div>
<div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;    </div>
<div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;    <span class="comment">//================================================ Height threshold for missing peak</span></div>
<div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;    proshade_double heightThreshold                   = 0.0;</div>
<div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign grIt = 0; grIt &lt; static_cast&lt;proshade_unsign&gt; ( grp-&gt;size() ); grIt++ ) { heightThreshold += peaks-&gt;at(grp-&gt;at(grIt))[4]; }</div>
<div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;    heightThreshold                                  /= <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( grp-&gt;size() );</div>
<div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;    heightThreshold                                  *= 0.5;</div>
<div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;    </div>
<div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;    <span class="comment">//================================================ For each missing value</span></div>
<div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign misPkIt = 0; misPkIt &lt; static_cast&lt;proshade_unsign&gt; ( missingPeaks-&gt;size() ); misPkIt++ )</div>
<div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;    {</div>
<div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;        <span class="comment">//============================================ Ignore the extra values in the expected values</span></div>
<div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;        <span class="keywordflow">if</span> ( expectedAngles-&gt;at(missingPeaks-&gt;at(misPkIt)) &gt;   M_PI ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;        <span class="keywordflow">if</span> ( expectedAngles-&gt;at(missingPeaks-&gt;at(misPkIt)) &lt;  -M_PI ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;        </div>
<div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;        <span class="comment">//============================================ Search for the missing peak</span></div>
<div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;        proshade_double misHeight = <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#aacced7feb8ce5251dce199505912d997">ProSHADE_internal_symmetry::checkForMissingPeak</a> ( dataObj, peaks-&gt;at(grp-&gt;at(0))[0], peaks-&gt;at(grp-&gt;at(0))[1], peaks-&gt;at(grp-&gt;at(0))[2], expectedAngles-&gt;at(missingPeaks-&gt;at(misPkIt)), heightThreshold, axErrTolerance );</div>
<div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;        <span class="keywordflow">if</span> ( misHeight != 0.0 )</div>
<div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;        {</div>
<div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;            <span class="comment">//======================================== Missing peak detected - save it to the group</span></div>
<div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;            proshade_double* hlpP                     = <span class="keyword">new</span> proshade_double [5];</div>
<div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a> ( hlpP, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;            hlpP[0]                                   = peaks-&gt;at(grp-&gt;at(0))[0];</div>
<div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;            hlpP[1]                                   = peaks-&gt;at(grp-&gt;at(0))[1];</div>
<div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;            hlpP[2]                                   = peaks-&gt;at(grp-&gt;at(0))[2];</div>
<div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;            hlpP[3]                                   = expectedAngles-&gt;at(missingPeaks-&gt;at(misPkIt));</div>
<div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;            hlpP[4]                                   = misHeight;</div>
<div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( matchedPeaks, <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( peaks-&gt;size() ) );</div>
<div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a> ( peaks, hlpP );</div>
<div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;        }</div>
<div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;        {</div>
<div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;            ret                                       = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;        }</div>
<div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;    }</div>
<div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;    </div>
<div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;    <span class="keywordflow">return</span>                                            ( ret );</div>
<div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160; </div>
<div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4f09b90de1f15b345ee7998ff31327f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f09b90de1f15b345ee7998ff31327f3">&#9670;&nbsp;</a></span>detectIcosahedralSymmetry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_symmetry::detectIcosahedralSymmetry </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes the list of C symmetries and decides whether basic requirements for isosahedral symmetry are there. </p>
<p>This function first finds all the C5 symmetries in the C symmetries list and then it checks each present C5 against all C3 symmetries for having the angle between the pair equal to the dihedral angle of an icosahedron ( acos( sqrt(5)/3 ) ). If a single such pair is detected, this is likely an icosahedral symmetry and all other axes need to be located. Otherwise, false is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum average peak height required for symmetry axis to be considered. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>Boolean value telling whether there are C5 and C3 symmetries with icosahedral dihhedral angle. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l02765">2765</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02766"></a><span class="lineno"> 2766</span>&#160;{</div>
<div class="line"><a name="l02767"></a><span class="lineno"> 2767</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l02768"></a><span class="lineno"> 2768</span>&#160;    std::vector&lt; proshade_unsign &gt; C5List;</div>
<div class="line"><a name="l02769"></a><span class="lineno"> 2769</span>&#160;    proshade_double dotProduct;</div>
<div class="line"><a name="l02770"></a><span class="lineno"> 2770</span>&#160;    </div>
<div class="line"><a name="l02771"></a><span class="lineno"> 2771</span>&#160;    <span class="comment">//================================================ Find all C5 symmetries</span></div>
<div class="line"><a name="l02772"></a><span class="lineno"> 2772</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign cSym = 0; cSym &lt; static_cast&lt;proshade_unsign&gt; ( CSymList-&gt;size() ); cSym++ )</div>
<div class="line"><a name="l02773"></a><span class="lineno"> 2773</span>&#160;    {</div>
<div class="line"><a name="l02774"></a><span class="lineno"> 2774</span>&#160;        <span class="keywordflow">if</span> ( CSymList-&gt;at(cSym)[0] == 5 &amp;&amp; CSymList-&gt;at(cSym)[5] &gt;= minPeakHeight ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C5List, cSym ); }</div>
<div class="line"><a name="l02775"></a><span class="lineno"> 2775</span>&#160;    }</div>
<div class="line"><a name="l02776"></a><span class="lineno"> 2776</span>&#160;    </div>
<div class="line"><a name="l02777"></a><span class="lineno"> 2777</span>&#160;    <span class="comment">//================================================ For each unique pair of C5 and C3</span></div>
<div class="line"><a name="l02778"></a><span class="lineno"> 2778</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign c5 = 0; c5 &lt; static_cast&lt;proshade_unsign&gt; ( C5List.size() ); c5++ )</div>
<div class="line"><a name="l02779"></a><span class="lineno"> 2779</span>&#160;    {</div>
<div class="line"><a name="l02780"></a><span class="lineno"> 2780</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign cSym = 0; cSym &lt; static_cast&lt;proshade_unsign&gt; ( CSymList-&gt;size() ); cSym++ )</div>
<div class="line"><a name="l02781"></a><span class="lineno"> 2781</span>&#160;        {</div>
<div class="line"><a name="l02782"></a><span class="lineno"> 2782</span>&#160;            <span class="comment">//======================================== Compare only C3s to the C5List</span></div>
<div class="line"><a name="l02783"></a><span class="lineno"> 2783</span>&#160;            <span class="keywordflow">if</span> ( CSymList-&gt;at(cSym)[0] != 3 ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l02784"></a><span class="lineno"> 2784</span>&#160;            </div>
<div class="line"><a name="l02785"></a><span class="lineno"> 2785</span>&#160;            <span class="comment">//========================================  Check the angle between the C5 and C3 axes</span></div>
<div class="line"><a name="l02786"></a><span class="lineno"> 2786</span>&#160;            dotProduct                                = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> ( &amp;CSymList-&gt;at(C5List.at(c5))[1],</div>
<div class="line"><a name="l02787"></a><span class="lineno"> 2787</span>&#160;                                                                                                     &amp;CSymList-&gt;at(C5List.at(c5))[2],</div>
<div class="line"><a name="l02788"></a><span class="lineno"> 2788</span>&#160;                                                                                                     &amp;CSymList-&gt;at(C5List.at(c5))[3],</div>
<div class="line"><a name="l02789"></a><span class="lineno"> 2789</span>&#160;                                                                                                     &amp;CSymList-&gt;at(cSym)[1],</div>
<div class="line"><a name="l02790"></a><span class="lineno"> 2790</span>&#160;                                                                                                     &amp;CSymList-&gt;at(cSym)[2],</div>
<div class="line"><a name="l02791"></a><span class="lineno"> 2791</span>&#160;                                                                                                     &amp;CSymList-&gt;at(cSym)[3] );</div>
<div class="line"><a name="l02792"></a><span class="lineno"> 2792</span>&#160;            </div>
<div class="line"><a name="l02793"></a><span class="lineno"> 2793</span>&#160;            <span class="comment">//======================================== Is the angle approximately the dihedral angle</span></div>
<div class="line"><a name="l02794"></a><span class="lineno"> 2794</span>&#160;            <span class="keywordflow">if</span> ( std::abs ( std::abs( -sqrt ( 5.0 ) / 3.0 ) - std::abs( dotProduct ) ) &lt; axErr )</div>
<div class="line"><a name="l02795"></a><span class="lineno"> 2795</span>&#160;            {</div>
<div class="line"><a name="l02796"></a><span class="lineno"> 2796</span>&#160;                <span class="keywordflow">return</span>                                ( <span class="keyword">true</span> );</div>
<div class="line"><a name="l02797"></a><span class="lineno"> 2797</span>&#160;            }</div>
<div class="line"><a name="l02798"></a><span class="lineno"> 2798</span>&#160;        }</div>
<div class="line"><a name="l02799"></a><span class="lineno"> 2799</span>&#160;    }</div>
<div class="line"><a name="l02800"></a><span class="lineno"> 2800</span>&#160;    </div>
<div class="line"><a name="l02801"></a><span class="lineno"> 2801</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l02802"></a><span class="lineno"> 2802</span>&#160;    <span class="keywordflow">return</span>                                            ( <span class="keyword">false</span> );</div>
<div class="line"><a name="l02803"></a><span class="lineno"> 2803</span>&#160;    </div>
<div class="line"><a name="l02804"></a><span class="lineno"> 2804</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a18d456057604616a7cf6b68f59b4f2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d456057604616a7cf6b68f59b4f2d0">&#9670;&nbsp;</a></span>detectOctahedralSymmetry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_symmetry::detectOctahedralSymmetry </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes the list of C symmetries and decides whether basic requirements for octahhedral symmetry are there. </p>
<p>This function first finds all the C4 symmetries in the C symmetries list and then it checks each present C4 against all C3 symmetries for having the angle between the pair equal to the dihedral angle of an octahedron ( acos(1/sqrt(3)) ). If a single such pair is detected, this is likely an octahedral symmetry and all other axes need to be located. Otherwise, false is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum average peak height for axis to be considered. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>Boolean value telling whether there are C4 and C3 symmetries with octahedral dihhedral angle. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l02152">2152</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02153"></a><span class="lineno"> 2153</span>&#160;{</div>
<div class="line"><a name="l02154"></a><span class="lineno"> 2154</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l02155"></a><span class="lineno"> 2155</span>&#160;    std::vector&lt; proshade_unsign &gt; C4List;</div>
<div class="line"><a name="l02156"></a><span class="lineno"> 2156</span>&#160;    proshade_double dotProduct;</div>
<div class="line"><a name="l02157"></a><span class="lineno"> 2157</span>&#160;    </div>
<div class="line"><a name="l02158"></a><span class="lineno"> 2158</span>&#160;    <span class="comment">//================================================ Find all C4 symmetries</span></div>
<div class="line"><a name="l02159"></a><span class="lineno"> 2159</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign cSym = 0; cSym &lt; static_cast&lt;proshade_unsign&gt; ( CSymList-&gt;size() ); cSym++ )</div>
<div class="line"><a name="l02160"></a><span class="lineno"> 2160</span>&#160;    {</div>
<div class="line"><a name="l02161"></a><span class="lineno"> 2161</span>&#160;        <span class="keywordflow">if</span> ( CSymList-&gt;at(cSym)[0] == 4 &amp;&amp; CSymList-&gt;at(cSym)[5] &gt;= minPeakHeight ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C4List, cSym ); }</div>
<div class="line"><a name="l02162"></a><span class="lineno"> 2162</span>&#160;    }</div>
<div class="line"><a name="l02163"></a><span class="lineno"> 2163</span>&#160;    </div>
<div class="line"><a name="l02164"></a><span class="lineno"> 2164</span>&#160;    <span class="comment">//================================================ For each unique pair of C3s</span></div>
<div class="line"><a name="l02165"></a><span class="lineno"> 2165</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign c4 = 0; c4 &lt; static_cast&lt;proshade_unsign&gt; ( C4List.size() ); c4++ )</div>
<div class="line"><a name="l02166"></a><span class="lineno"> 2166</span>&#160;    {</div>
<div class="line"><a name="l02167"></a><span class="lineno"> 2167</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign cSym = 0; cSym &lt; static_cast&lt;proshade_unsign&gt; ( CSymList-&gt;size() ); cSym++ )</div>
<div class="line"><a name="l02168"></a><span class="lineno"> 2168</span>&#160;        {</div>
<div class="line"><a name="l02169"></a><span class="lineno"> 2169</span>&#160;            <span class="comment">//======================================== Compare only C3s to the C3List</span></div>
<div class="line"><a name="l02170"></a><span class="lineno"> 2170</span>&#160;            <span class="keywordflow">if</span> ( CSymList-&gt;at(cSym)[0] != 3 ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l02171"></a><span class="lineno"> 2171</span>&#160;            </div>
<div class="line"><a name="l02172"></a><span class="lineno"> 2172</span>&#160;            <span class="comment">//========================================  Check the angle between the C4 and C3 axes</span></div>
<div class="line"><a name="l02173"></a><span class="lineno"> 2173</span>&#160;            dotProduct                                = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> ( &amp;CSymList-&gt;at(C4List.at(c4))[1],</div>
<div class="line"><a name="l02174"></a><span class="lineno"> 2174</span>&#160;                                                                                                     &amp;CSymList-&gt;at(C4List.at(c4))[2],</div>
<div class="line"><a name="l02175"></a><span class="lineno"> 2175</span>&#160;                                                                                                     &amp;CSymList-&gt;at(C4List.at(c4))[3],</div>
<div class="line"><a name="l02176"></a><span class="lineno"> 2176</span>&#160;                                                                                                     &amp;CSymList-&gt;at(cSym)[1],</div>
<div class="line"><a name="l02177"></a><span class="lineno"> 2177</span>&#160;                                                                                                     &amp;CSymList-&gt;at(cSym)[2],</div>
<div class="line"><a name="l02178"></a><span class="lineno"> 2178</span>&#160;                                                                                                     &amp;CSymList-&gt;at(cSym)[3] );</div>
<div class="line"><a name="l02179"></a><span class="lineno"> 2179</span>&#160;            </div>
<div class="line"><a name="l02180"></a><span class="lineno"> 2180</span>&#160;            <span class="comment">//======================================== Is the angle approximately the dihedral angle</span></div>
<div class="line"><a name="l02181"></a><span class="lineno"> 2181</span>&#160;            <span class="keywordflow">if</span> ( ( ( 1.0 / sqrt ( 3.0 ) ) &gt; ( dotProduct - axErr ) ) &amp;&amp; ( ( 1.0 / sqrt ( 3.0 ) ) &lt; ( dotProduct + axErr ) ) )</div>
<div class="line"><a name="l02182"></a><span class="lineno"> 2182</span>&#160;            {</div>
<div class="line"><a name="l02183"></a><span class="lineno"> 2183</span>&#160;                <span class="keywordflow">return</span>                                ( <span class="keyword">true</span> );</div>
<div class="line"><a name="l02184"></a><span class="lineno"> 2184</span>&#160;            }</div>
<div class="line"><a name="l02185"></a><span class="lineno"> 2185</span>&#160;        }</div>
<div class="line"><a name="l02186"></a><span class="lineno"> 2186</span>&#160;    }</div>
<div class="line"><a name="l02187"></a><span class="lineno"> 2187</span>&#160;    </div>
<div class="line"><a name="l02188"></a><span class="lineno"> 2188</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l02189"></a><span class="lineno"> 2189</span>&#160;    <span class="keywordflow">return</span>                                            ( <span class="keyword">false</span> );</div>
<div class="line"><a name="l02190"></a><span class="lineno"> 2190</span>&#160;    </div>
<div class="line"><a name="l02191"></a><span class="lineno"> 2191</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a37925ac477480c718451debb01a9c74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37925ac477480c718451debb01a9c74a">&#9670;&nbsp;</a></span>detectTetrahedralSymmetry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_symmetry::detectTetrahedralSymmetry </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes the list of C symmetries and decides whether basic requirements for tetrahedral symmetry are there. </p>
<p>This function first finds all the C3 symmetries in the C symmetries list and then it checks all pais of such present C3s for have the angle between the pair equal to the dihedral angle of a tetrahedron ( acos(1/3) ). If a single such pair is detected, this is likely a tetrahedral symmetry and all other axes need to be located. Otherwise, false is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum average peak height for axis to be considered. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>Boolean value telling whether there are two C3 symmetries with tetrahedral dihhedral angle. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01396">1396</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01397"></a><span class="lineno"> 1397</span>&#160;{</div>
<div class="line"><a name="l01398"></a><span class="lineno"> 1398</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l01399"></a><span class="lineno"> 1399</span>&#160;    std::vector&lt; proshade_unsign &gt; C3List;</div>
<div class="line"><a name="l01400"></a><span class="lineno"> 1400</span>&#160;    proshade_double dotProduct;</div>
<div class="line"><a name="l01401"></a><span class="lineno"> 1401</span>&#160;    </div>
<div class="line"><a name="l01402"></a><span class="lineno"> 1402</span>&#160;    <span class="comment">//================================================ Find all C3 symmetries</span></div>
<div class="line"><a name="l01403"></a><span class="lineno"> 1403</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign cSym = 0; cSym &lt; static_cast&lt;proshade_unsign&gt; ( CSymList-&gt;size() ); cSym++ )</div>
<div class="line"><a name="l01404"></a><span class="lineno"> 1404</span>&#160;    {</div>
<div class="line"><a name="l01405"></a><span class="lineno"> 1405</span>&#160;        <span class="keywordflow">if</span> ( CSymList-&gt;at(cSym)[0] == 3 &amp;&amp; CSymList-&gt;at(cSym)[5] &gt;= minPeakHeight ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C3List, cSym ); }</div>
<div class="line"><a name="l01406"></a><span class="lineno"> 1406</span>&#160;    }</div>
<div class="line"><a name="l01407"></a><span class="lineno"> 1407</span>&#160;    </div>
<div class="line"><a name="l01408"></a><span class="lineno"> 1408</span>&#160;    <span class="comment">//================================================ For each unique pair of C3s</span></div>
<div class="line"><a name="l01409"></a><span class="lineno"> 1409</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign c31 = 0; c31 &lt; static_cast&lt;proshade_unsign&gt; ( C3List.size() ); c31++ )</div>
<div class="line"><a name="l01410"></a><span class="lineno"> 1410</span>&#160;    {</div>
<div class="line"><a name="l01411"></a><span class="lineno"> 1411</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign c32 = 1; c32 &lt; static_cast&lt;proshade_unsign&gt; ( C3List.size() ); c32++ )</div>
<div class="line"><a name="l01412"></a><span class="lineno"> 1412</span>&#160;        {</div>
<div class="line"><a name="l01413"></a><span class="lineno"> 1413</span>&#160;            <span class="comment">//================================ Unique pairs only</span></div>
<div class="line"><a name="l01414"></a><span class="lineno"> 1414</span>&#160;            <span class="keywordflow">if</span> ( c31 &gt;= c32 ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l01415"></a><span class="lineno"> 1415</span>&#160;            </div>
<div class="line"><a name="l01416"></a><span class="lineno"> 1416</span>&#160;            <span class="comment">//========================================  Check the angle between the C3 axes</span></div>
<div class="line"><a name="l01417"></a><span class="lineno"> 1417</span>&#160;            dotProduct                                = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> ( &amp;CSymList-&gt;at(C3List.at(c31))[1], &amp;CSymList-&gt;at(C3List.at(c31))[2], &amp;CSymList-&gt;at(C3List.at(c31))[3], &amp;CSymList-&gt;at(C3List.at(c32))[1], &amp;CSymList-&gt;at(C3List.at(c32))[2], &amp;CSymList-&gt;at(C3List.at(c32))[3] );</div>
<div class="line"><a name="l01418"></a><span class="lineno"> 1418</span>&#160;            </div>
<div class="line"><a name="l01419"></a><span class="lineno"> 1419</span>&#160;            <span class="comment">//================================ Is the angle approximately the dihedral angle</span></div>
<div class="line"><a name="l01420"></a><span class="lineno"> 1420</span>&#160;            <span class="keywordflow">if</span> ( ( ( 1.0 / 3.0 ) &gt; ( dotProduct - axErr ) ) &amp;&amp; ( ( 1.0 / 3.0 ) &lt; ( dotProduct + axErr ) ) )</div>
<div class="line"><a name="l01421"></a><span class="lineno"> 1421</span>&#160;            {</div>
<div class="line"><a name="l01422"></a><span class="lineno"> 1422</span>&#160;                <span class="keywordflow">return</span>                                ( <span class="keyword">true</span> );</div>
<div class="line"><a name="l01423"></a><span class="lineno"> 1423</span>&#160;            }</div>
<div class="line"><a name="l01424"></a><span class="lineno"> 1424</span>&#160;        }</div>
<div class="line"><a name="l01425"></a><span class="lineno"> 1425</span>&#160;    }</div>
<div class="line"><a name="l01426"></a><span class="lineno"> 1426</span>&#160;    </div>
<div class="line"><a name="l01427"></a><span class="lineno"> 1427</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01428"></a><span class="lineno"> 1428</span>&#160;    <span class="keywordflow">return</span>                                            ( <span class="keyword">false</span> );</div>
<div class="line"><a name="l01429"></a><span class="lineno"> 1429</span>&#160;    </div>
<div class="line"><a name="l01430"></a><span class="lineno"> 1430</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac0a8dc71c37de02256521ebc9178c8d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a8dc71c37de02256521ebc9178c8d4">&#9670;&nbsp;</a></span>determineFoldToTry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_symmetry::determineFoldToTry </td>
          <td>(</td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>divBasis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>divRem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>peakErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>symmErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>angsToTry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function determines the symmetry fold to be searched for. </p>
<p>This function detects which fold would belong to the rotation angle distance supplied. This is done by finding the division basis for the simple 2pi/dist equation and minimising the remainder. The function then checks whether the remainder is smaller than a threshold and whether the error on fold detection is not close to fold+1 value in terms of peak misplacement in the map - if it is, then surrounding fold values are also added to be tested. Finally, the function returns boolean value stating whether at least one testable fold value passed the checks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dist</td><td>The distance between rotation angles that should form the symmetry group. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">divBasis</td><td>Pointer to where to save the basis of the division 2pi/dist. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">divRem</td><td>Pointer to where to save the remainder of the division 2pi/dist. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">peakErr</td><td>The error in radians which would be the result of misplacing a peak by single map index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">symmErr</td><td>Pointer to where to save the error which would be caused by mis-predicting the fold by 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angsToTry</td><td>A vector where all the suggested fold values to be tested are saved. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>Boolean value whether at least single testable fold value was found </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00658">658</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;{</div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;    <span class="keywordtype">bool</span> ret                                          = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;    </div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;    <span class="comment">//================================================ Find the basis and remainder of the 2pi/dist equation</span></div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;   *divRem                                            = std::modf ( <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( ( 2.0 * M_PI ) / std::abs ( dist ) ), divBasis );</div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;    </div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;    <span class="comment">//================================================ If the remainder would be smaller for larger basis, so this basis</span></div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;    <span class="keywordflow">if</span> ( *divRem &gt; 0.5 )</div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;    {</div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;       *divRem                                       -= 1.0;</div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;       *divBasis                                     += 1.0;</div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;    }</div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;    </div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;    <span class="comment">//================================================ Determine errors on peaks and on folds</span></div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;   *symmErr                                           = ( M_PI * 2.0 / *divBasis ) - ( M_PI * 2.0 / ( *divBasis + 1.0 ) );</div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;    proshade_double angTolerance                      = ( peakErr / *symmErr  );</div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;    </div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;    <span class="comment">//================================================ Is remainder small enough?</span></div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;    <span class="keywordflow">if</span> ( ( *divRem &lt; ( 0.0 + angTolerance ) ) &amp;&amp; ( *divRem &gt; ( 0.0 - angTolerance ) ) )</div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;    {</div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;        <span class="comment">//============================================ Are we sure about the fold determination accuracy</span></div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;        proshade_signed angTolRound                   = std::min ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__map_manip.html#a50df80b02427f9f55a2c7af033a9fb93">ProSHADE_internal_mapManip::myRound</a> ( angTolerance ), <span class="keyword">static_cast&lt;</span>proshade_signed<span class="keyword">&gt;</span> ( 10 ) );</div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;        <span class="keywordflow">for</span> ( proshade_signed iter = -angTolRound; iter &lt;= angTolRound; iter++ )</div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;        {</div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( angsToTry, <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( std::max ( *divBasis + iter, 2.0 ) ) );</div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;        }</div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;    }</div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;    </div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;    <span class="comment">//================================================ Return indication of whether testable fold value(s) was found.</span></div>
<div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;    <span class="keywordflow">if</span> ( angsToTry-&gt;size() == 0 ) { ret = <span class="keyword">false</span>; }</div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;    <span class="keywordflow">else</span> { ret = <span class="keyword">true</span>; }</div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;    </div>
<div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;    <span class="keywordflow">return</span>                                    ( ret );</div>
<div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160; </div>
<div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af4f982fc282e8fca11b6a85f2d2069a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f982fc282e8fca11b6a85f2d2069a5">&#9670;&nbsp;</a></span>findExpectedPeakRotations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::findExpectedPeakRotations </td>
          <td>(</td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double &gt; *&#160;</td>
          <td class="paramname"><em>expAngs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes the expected peak rotations for given fold. </p>
<p>This function computes the expected peak rotation angle values for the peak range between -180 to +180 degrees plus one distance on both sides for a good measure. The resulting values are then saved to the second parameter vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fold</td><td>The fold for which peak rotation angles should be predicted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expAngs</td><td>A vector where the expected peak rotation values will be saved to. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00705">705</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;{</div>
<div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;    proshade_double groupAngle                        = ( 2.0 * M_PI ) / <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( fold );</div>
<div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;    </div>
<div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;    <span class="comment">//================================================ Generate expected angles</span></div>
<div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;    <span class="keywordflow">for</span> ( proshade_signed iter = <span class="keyword">static_cast&lt;</span>proshade_signed<span class="keyword">&gt;</span> ( -( <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( fold ) / 2.0 + 1.0) ); iter &lt;= static_cast&lt;proshade_signed&gt; ( <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( fold )/2.0 + 1.0 ); iter++ )</div>
<div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;    {</div>
<div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a>     ( expAngs, iter * groupAngle );</div>
<div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;    }</div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;    </div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;    return ;</div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160; </div>
<div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aede68f7d4dd7840b1bfcf8daa3156adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede68f7d4dd7840b1bfcf8daa3156adf">&#9670;&nbsp;</a></span>findIcos10C3s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::findIcos10C3s </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes the list of C symmetries and finds the ten C3 symmetries with correct angles required for full icosahedral symmetry. </p>
<p>This function is specific to detecting the icosahedral symmetry. It should be called once icosahedral symmetry is suspected (by detecting its dihedral angles) and it needs to be fully described. This function specifically searches for the ten C3 symmetries which must all be detected in order to fully describe icosahedral symmetry. If all ten are found, the ret vector will have these ten axes added to the already present six C5 axes; alternatively, the ret array size will not change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>The vector containing the already detected axes to which newly detected axes (if any) will be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum average peak height for axis to be considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verobse</td><td>How loud the announcments should be? </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l03257">3257</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03258"></a><span class="lineno"> 3258</span>&#160;{</div>
<div class="line"><a name="l03259"></a><span class="lineno"> 3259</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l03260"></a><span class="lineno"> 3260</span>&#160;    std::vector&lt; proshade_unsign &gt; prospectiveC3s, retGrp;</div>
<div class="line"><a name="l03261"></a><span class="lineno"> 3261</span>&#160;    proshade_double dotProd;</div>
<div class="line"><a name="l03262"></a><span class="lineno"> 3262</span>&#160;    proshade_unsign noClose, noAway;</div>
<div class="line"><a name="l03263"></a><span class="lineno"> 3263</span>&#160;    </div>
<div class="line"><a name="l03264"></a><span class="lineno"> 3264</span>&#160;    <span class="comment">//================================================ Report progress</span></div>
<div class="line"><a name="l03265"></a><span class="lineno"> 3265</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a6aa8cdb600cad623409802cfaed494fa">ProSHADE_internal_messages::printProgressMessage</a>  ( verbose, 2, <span class="stringliteral">&quot;Starting detection of ten C3 axes.&quot;</span> );</div>
<div class="line"><a name="l03266"></a><span class="lineno"> 3266</span>&#160; </div>
<div class="line"><a name="l03267"></a><span class="lineno"> 3267</span>&#160;    <span class="comment">//================================================ For each C3</span></div>
<div class="line"><a name="l03268"></a><span class="lineno"> 3268</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign cIt = 0; cIt &lt; static_cast&lt;proshade_unsign&gt; ( CSymList-&gt;size() ); cIt++ )</div>
<div class="line"><a name="l03269"></a><span class="lineno"> 3269</span>&#160;    {</div>
<div class="line"><a name="l03270"></a><span class="lineno"> 3270</span>&#160;        <span class="comment">//============================================ Use only C3s with hight enough average</span></div>
<div class="line"><a name="l03271"></a><span class="lineno"> 3271</span>&#160;        <span class="keywordflow">if</span> ( CSymList-&gt;at(cIt)[0] != 3.0 || CSymList-&gt;at(cIt)[0] &lt; minPeakHeight ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l03272"></a><span class="lineno"> 3272</span>&#160; </div>
<div class="line"><a name="l03273"></a><span class="lineno"> 3273</span>&#160;        <span class="comment">//============================================ Check the C3 has acos ( sqrt ( 5.0 ) / 3.0 ) to 3 C5s and acos ( 1.0 - ( sqrt ( 5.0 ) / 3.0 ) ) to the other three C5s</span></div>
<div class="line"><a name="l03274"></a><span class="lineno"> 3274</span>&#160;        noClose = 0; noAway = 0;</div>
<div class="line"><a name="l03275"></a><span class="lineno"> 3275</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign rIt = 0; rIt &lt; 6; rIt++ )</div>
<div class="line"><a name="l03276"></a><span class="lineno"> 3276</span>&#160;        {</div>
<div class="line"><a name="l03277"></a><span class="lineno"> 3277</span>&#160;            dotProd                                   = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> ( &amp;ret-&gt;at(rIt)[1],</div>
<div class="line"><a name="l03278"></a><span class="lineno"> 3278</span>&#160;                                                                                                     &amp;ret-&gt;at(rIt)[2],</div>
<div class="line"><a name="l03279"></a><span class="lineno"> 3279</span>&#160;                                                                                                     &amp;ret-&gt;at(rIt)[3],</div>
<div class="line"><a name="l03280"></a><span class="lineno"> 3280</span>&#160;                                                                                                     &amp;CSymList-&gt;at(cIt)[1],</div>
<div class="line"><a name="l03281"></a><span class="lineno"> 3281</span>&#160;                                                                                                     &amp;CSymList-&gt;at(cIt)[2],</div>
<div class="line"><a name="l03282"></a><span class="lineno"> 3282</span>&#160;                                                                                                     &amp;CSymList-&gt;at(cIt)[3] );</div>
<div class="line"><a name="l03283"></a><span class="lineno"> 3283</span>&#160; </div>
<div class="line"><a name="l03284"></a><span class="lineno"> 3284</span>&#160;            <span class="keywordflow">if</span> ( ( std::abs ( dotProd ) &gt; (       ( sqrt ( 5.0 ) / 3.0 ) - axErr ) ) &amp;&amp; ( std::abs ( dotProd ) &lt; (       ( sqrt ( 5.0 ) / 3.0 ) + axErr ) ) ) { noClose += 1; <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l03285"></a><span class="lineno"> 3285</span>&#160;            <span class="keywordflow">if</span> ( ( std::abs ( dotProd ) &gt; ( 1.0 - ( sqrt ( 5.0 ) / 3.0 ) - axErr ) ) &amp;&amp; ( std::abs ( dotProd ) &lt; ( 1.0 - ( sqrt ( 5.0 ) / 3.0 ) + axErr ) ) ) { noAway  += 1; <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l03286"></a><span class="lineno"> 3286</span>&#160;        }</div>
<div class="line"><a name="l03287"></a><span class="lineno"> 3287</span>&#160; </div>
<div class="line"><a name="l03288"></a><span class="lineno"> 3288</span>&#160;        <span class="comment">//============================================ If correct angles distribution is found, save the axis</span></div>
<div class="line"><a name="l03289"></a><span class="lineno"> 3289</span>&#160;        <span class="keywordflow">if</span> ( ( noClose == 3 ) &amp;&amp; ( noAway == 3 ) )</div>
<div class="line"><a name="l03290"></a><span class="lineno"> 3290</span>&#160;        {</div>
<div class="line"><a name="l03291"></a><span class="lineno"> 3291</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;prospectiveC3s, cIt );</div>
<div class="line"><a name="l03292"></a><span class="lineno"> 3292</span>&#160;        }</div>
<div class="line"><a name="l03293"></a><span class="lineno"> 3293</span>&#160;    }</div>
<div class="line"><a name="l03294"></a><span class="lineno"> 3294</span>&#160; </div>
<div class="line"><a name="l03295"></a><span class="lineno"> 3295</span>&#160;    <span class="comment">//================================================ Search for missing axes</span></div>
<div class="line"><a name="l03296"></a><span class="lineno"> 3296</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; 6; iter++ ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;retGrp, iter ); }</div>
<div class="line"><a name="l03297"></a><span class="lineno"> 3297</span>&#160;    <span class="keywordflow">if</span> ( !<a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a6d9f533a789bd5c6031fa77b9649ed3d">ProSHADE_internal_symmetry::findMissingAxesDual</a> ( &amp;prospectiveC3s, CSymList, ret, &amp;retGrp, 10, axErr, 3, sqrt ( 5.0 ) / 3.0, 3, 1.0 - ( sqrt ( 5.0 ) / 3.0 ), 3, dataObj ) )</div>
<div class="line"><a name="l03298"></a><span class="lineno"> 3298</span>&#160;    {</div>
<div class="line"><a name="l03299"></a><span class="lineno"> 3299</span>&#160;        return ;</div>
<div class="line"><a name="l03300"></a><span class="lineno"> 3300</span>&#160;    }</div>
<div class="line"><a name="l03301"></a><span class="lineno"> 3301</span>&#160; </div>
<div class="line"><a name="l03302"></a><span class="lineno"> 3302</span>&#160;    <span class="comment">//================================================ Found correct number of axes! Now save the</span></div>
<div class="line"><a name="l03303"></a><span class="lineno"> 3303</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; static_cast&lt;proshade_unsign&gt; ( prospectiveC3s.size() ); iter++ )</div>
<div class="line"><a name="l03304"></a><span class="lineno"> 3304</span>&#160;    {</div>
<div class="line"><a name="l03305"></a><span class="lineno"> 3305</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a>     ( ret, CSymList-&gt;at(prospectiveC3s.at(iter)) );</div>
<div class="line"><a name="l03306"></a><span class="lineno"> 3306</span>&#160;    }</div>
<div class="line"><a name="l03307"></a><span class="lineno"> 3307</span>&#160; </div>
<div class="line"><a name="l03308"></a><span class="lineno"> 3308</span>&#160;    <span class="comment">//================================================ Report progress</span></div>
<div class="line"><a name="l03309"></a><span class="lineno"> 3309</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a6aa8cdb600cad623409802cfaed494fa">ProSHADE_internal_messages::printProgressMessage</a>  ( verbose, 3, <span class="stringliteral">&quot;Detection of ten C3 axes successfull.&quot;</span> );</div>
<div class="line"><a name="l03310"></a><span class="lineno"> 3310</span>&#160;    </div>
<div class="line"><a name="l03311"></a><span class="lineno"> 3311</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l03312"></a><span class="lineno"> 3312</span>&#160;    return ;</div>
<div class="line"><a name="l03313"></a><span class="lineno"> 3313</span>&#160;    </div>
<div class="line"><a name="l03314"></a><span class="lineno"> 3314</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad0d6480c4de06bce2b7d05c0471eb000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0d6480c4de06bce2b7d05c0471eb000">&#9670;&nbsp;</a></span>findIcos15C2s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::findIcos15C2s </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes the list of C symmetries and finds the fifteen C3 symmetries with correct angles required for full icosahedral symmetry. </p>
<p>This function is specific to detecting the icosahedral symmetry. It should be called once icosahedral symmetry is suspected (by detecting its dihedral angles) and it needs to be fully described. This function specifically searches for the ten C3 symmetries which must all be detected in order to fully describe icosahedral symmetry. If all ten are found, the ret vector will have these ten axes added to the already present six C5 axes; alternatively, the ret array size will not change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>The vector containing the already detected axes to which newly detected axes (if any) will be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum average peak height for axis to be considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verobse</td><td>How loud the announcments should be? </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l03329">3329</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03330"></a><span class="lineno"> 3330</span>&#160;{</div>
<div class="line"><a name="l03331"></a><span class="lineno"> 3331</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l03332"></a><span class="lineno"> 3332</span>&#160;    std::vector&lt; proshade_unsign &gt; prospectiveC2s, retGrp;</div>
<div class="line"><a name="l03333"></a><span class="lineno"> 3333</span>&#160;    proshade_double dotProd;</div>
<div class="line"><a name="l03334"></a><span class="lineno"> 3334</span>&#160;    proshade_unsign noClose, noMidway, noAway;</div>
<div class="line"><a name="l03335"></a><span class="lineno"> 3335</span>&#160;    </div>
<div class="line"><a name="l03336"></a><span class="lineno"> 3336</span>&#160;    <span class="comment">//================================================ Report progress</span></div>
<div class="line"><a name="l03337"></a><span class="lineno"> 3337</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a6aa8cdb600cad623409802cfaed494fa">ProSHADE_internal_messages::printProgressMessage</a>  ( verbose, 2, <span class="stringliteral">&quot;Starting detection of fifteen C2 axes.&quot;</span> );</div>
<div class="line"><a name="l03338"></a><span class="lineno"> 3338</span>&#160; </div>
<div class="line"><a name="l03339"></a><span class="lineno"> 3339</span>&#160;    <span class="comment">//================================================ For each C2</span></div>
<div class="line"><a name="l03340"></a><span class="lineno"> 3340</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign cIt = 0; cIt &lt; static_cast&lt;proshade_unsign&gt; ( CSymList-&gt;size() ); cIt++ )</div>
<div class="line"><a name="l03341"></a><span class="lineno"> 3341</span>&#160;    {</div>
<div class="line"><a name="l03342"></a><span class="lineno"> 3342</span>&#160;        <span class="comment">//============================================ Use only C2s</span></div>
<div class="line"><a name="l03343"></a><span class="lineno"> 3343</span>&#160;        <span class="keywordflow">if</span> ( CSymList-&gt;at(cIt)[0] != 2.0 || CSymList-&gt;at(cIt)[0] &lt; minPeakHeight ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l03344"></a><span class="lineno"> 3344</span>&#160; </div>
<div class="line"><a name="l03345"></a><span class="lineno"> 3345</span>&#160;        <span class="comment">//============================================ Check the C2 has acos ( 0.0 ) to 2 C5s, acos ( 0.5 ) to another 2 C5s and acos ( sqrt ( 3.0 ) / 2.0 ) to the last two C5s</span></div>
<div class="line"><a name="l03346"></a><span class="lineno"> 3346</span>&#160;        noClose = 0; noMidway = 0; noAway = 0;</div>
<div class="line"><a name="l03347"></a><span class="lineno"> 3347</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign rIt = 0; rIt &lt; 6; rIt++ )</div>
<div class="line"><a name="l03348"></a><span class="lineno"> 3348</span>&#160;        {</div>
<div class="line"><a name="l03349"></a><span class="lineno"> 3349</span>&#160;            dotProd                                   = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> ( &amp;ret-&gt;at(rIt)[1],</div>
<div class="line"><a name="l03350"></a><span class="lineno"> 3350</span>&#160;                                                                                                     &amp;ret-&gt;at(rIt)[2],</div>
<div class="line"><a name="l03351"></a><span class="lineno"> 3351</span>&#160;                                                                                                     &amp;ret-&gt;at(rIt)[3],</div>
<div class="line"><a name="l03352"></a><span class="lineno"> 3352</span>&#160;                                                                                                     &amp;CSymList-&gt;at(cIt)[1],</div>
<div class="line"><a name="l03353"></a><span class="lineno"> 3353</span>&#160;                                                                                                     &amp;CSymList-&gt;at(cIt)[2],</div>
<div class="line"><a name="l03354"></a><span class="lineno"> 3354</span>&#160;                                                                                                     &amp;CSymList-&gt;at(cIt)[3] );</div>
<div class="line"><a name="l03355"></a><span class="lineno"> 3355</span>&#160; </div>
<div class="line"><a name="l03356"></a><span class="lineno"> 3356</span>&#160;            <span class="keywordflow">if</span> ( ( std::abs ( dotProd ) &gt; ( ( sqrt ( 3.0 ) / 2.0 ) - axErr ) ) &amp;&amp; ( std::abs ( dotProd ) &lt; ( ( sqrt ( 3.0 ) / 2.0 ) + axErr ) ) ) { noAway    += 1; <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l03357"></a><span class="lineno"> 3357</span>&#160;            <span class="keywordflow">if</span> ( ( std::abs ( dotProd ) &gt; ( ( 1.0 / 2.0 )          - axErr ) ) &amp;&amp; ( std::abs ( dotProd ) &lt; ( ( 1.0 / 2.0 )          + axErr ) ) ) { noMidway  += 1; <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l03358"></a><span class="lineno"> 3358</span>&#160;            <span class="keywordflow">if</span> ( ( std::abs ( dotProd ) &gt; ( ( 0.0 )                - axErr ) ) &amp;&amp; ( std::abs ( dotProd ) &lt; ( ( 0.0 )                + axErr ) ) ) { noClose   += 1; <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l03359"></a><span class="lineno"> 3359</span>&#160;        }</div>
<div class="line"><a name="l03360"></a><span class="lineno"> 3360</span>&#160; </div>
<div class="line"><a name="l03361"></a><span class="lineno"> 3361</span>&#160;        <span class="comment">//============================================ If correct angles distribution is found, save the axis</span></div>
<div class="line"><a name="l03362"></a><span class="lineno"> 3362</span>&#160;        <span class="keywordflow">if</span> ( ( noClose == 2 ) &amp;&amp; ( noMidway == 2 ) &amp;&amp; ( noAway == 2 ) )</div>
<div class="line"><a name="l03363"></a><span class="lineno"> 3363</span>&#160;        {</div>
<div class="line"><a name="l03364"></a><span class="lineno"> 3364</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;prospectiveC2s, cIt );</div>
<div class="line"><a name="l03365"></a><span class="lineno"> 3365</span>&#160;        }</div>
<div class="line"><a name="l03366"></a><span class="lineno"> 3366</span>&#160;    }</div>
<div class="line"><a name="l03367"></a><span class="lineno"> 3367</span>&#160; </div>
<div class="line"><a name="l03368"></a><span class="lineno"> 3368</span>&#160;    <span class="comment">//================================================ Search for missing axes</span></div>
<div class="line"><a name="l03369"></a><span class="lineno"> 3369</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; 6; iter++ ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;retGrp, iter ); }</div>
<div class="line"><a name="l03370"></a><span class="lineno"> 3370</span>&#160;    <span class="keywordflow">if</span> ( !<a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ae266053664eb7cf916aa5e2d282e35dd">ProSHADE_internal_symmetry::findMissingAxesTriple</a> ( &amp;prospectiveC2s, CSymList, ret, &amp;retGrp, 15, axErr, 2, 0.0, 2, 1.0/2.0, 2, sqrt ( 3.0 ) / 2.0, 2, dataObj ) )</div>
<div class="line"><a name="l03371"></a><span class="lineno"> 3371</span>&#160;    {</div>
<div class="line"><a name="l03372"></a><span class="lineno"> 3372</span>&#160;        return ;</div>
<div class="line"><a name="l03373"></a><span class="lineno"> 3373</span>&#160;    }</div>
<div class="line"><a name="l03374"></a><span class="lineno"> 3374</span>&#160;    </div>
<div class="line"><a name="l03375"></a><span class="lineno"> 3375</span>&#160;    <span class="comment">//================================================ Found correct number of axes! Now save the</span></div>
<div class="line"><a name="l03376"></a><span class="lineno"> 3376</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; static_cast&lt;proshade_unsign&gt; ( prospectiveC2s.size() ); iter++ )</div>
<div class="line"><a name="l03377"></a><span class="lineno"> 3377</span>&#160;    {</div>
<div class="line"><a name="l03378"></a><span class="lineno"> 3378</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a>     ( ret, CSymList-&gt;at(prospectiveC2s.at(iter)) );</div>
<div class="line"><a name="l03379"></a><span class="lineno"> 3379</span>&#160;    }</div>
<div class="line"><a name="l03380"></a><span class="lineno"> 3380</span>&#160; </div>
<div class="line"><a name="l03381"></a><span class="lineno"> 3381</span>&#160;    <span class="comment">//================================================ Report progress</span></div>
<div class="line"><a name="l03382"></a><span class="lineno"> 3382</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a6aa8cdb600cad623409802cfaed494fa">ProSHADE_internal_messages::printProgressMessage</a>  ( verbose, 3, <span class="stringliteral">&quot;Detection of fifteen C2 axes successfull.&quot;</span> );</div>
<div class="line"><a name="l03383"></a><span class="lineno"> 3383</span>&#160;    </div>
<div class="line"><a name="l03384"></a><span class="lineno"> 3384</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l03385"></a><span class="lineno"> 3385</span>&#160;    return ;</div>
<div class="line"><a name="l03386"></a><span class="lineno"> 3386</span>&#160;    </div>
<div class="line"><a name="l03387"></a><span class="lineno"> 3387</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a65eb2dbdadc031e511734b5a48e31b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65eb2dbdadc031e511734b5a48e31b08">&#9670;&nbsp;</a></span>findIcos6C5s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::findIcos6C5s </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes the list of C symmetries and finds the six C5 symmetries with given angles required for full icosahedral symmetry. </p>
<p>This function searches the list of all detected C symmetries for the presence of six C5 symmetries, which have the angle of acos (0.5) to each other; this ability is specifically required for detection of icosahedral symmetry. This function allows for multiple groups of C5 symmetries, doing the missing symmetry axis checks and returning the group with highest average peak height. If successfull, the ret vector will have 6 entries, otherwise it will be empty.</p>
<p>This function is specific to detecting the octahedral symmetry. It should be called once octahedral symmetry is suspected (by detecting its dihedral angles) and it needs to be fully described. This function specifically searches for the three C4 symmetries which must all be detected in order to fully describe octahedral symmetry. If all three are found, the ret vector will contain these as its only four entries, while it will be empty if some of the C4 symmetries are not found. The missing symmetry axis detection is implemented as part of this function as well.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>The vector . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum average peak height for axis to be considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verobse</td><td>How loud the announcments should be? </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l02823">2823</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02824"></a><span class="lineno"> 2824</span>&#160;{</div>
<div class="line"><a name="l02825"></a><span class="lineno"> 2825</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l02826"></a><span class="lineno"> 2826</span>&#160;    std::vector&lt; proshade_unsign &gt; C5PossibilitiesHlp;</div>
<div class="line"><a name="l02827"></a><span class="lineno"> 2827</span>&#160;    std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; C5Possibilities;</div>
<div class="line"><a name="l02828"></a><span class="lineno"> 2828</span>&#160;    <span class="keywordtype">bool</span> groupMatched;</div>
<div class="line"><a name="l02829"></a><span class="lineno"> 2829</span>&#160;    </div>
<div class="line"><a name="l02830"></a><span class="lineno"> 2830</span>&#160;    <span class="comment">//================================================ Report progress</span></div>
<div class="line"><a name="l02831"></a><span class="lineno"> 2831</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a6aa8cdb600cad623409802cfaed494fa">ProSHADE_internal_messages::printProgressMessage</a>  ( verbose, 2, <span class="stringliteral">&quot;Starting detection of six C5 axes.&quot;</span> );</div>
<div class="line"><a name="l02832"></a><span class="lineno"> 2832</span>&#160; </div>
<div class="line"><a name="l02833"></a><span class="lineno"> 2833</span>&#160;    <span class="comment">//================================================ For all symmetries in the C symmetries list</span></div>
<div class="line"><a name="l02834"></a><span class="lineno"> 2834</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign cIt = 0; cIt &lt; static_cast&lt;proshade_unsign&gt; ( CSymList-&gt;size() ); cIt++ )</div>
<div class="line"><a name="l02835"></a><span class="lineno"> 2835</span>&#160;    {</div>
<div class="line"><a name="l02836"></a><span class="lineno"> 2836</span>&#160;        <span class="comment">//============================================ Search only using C5s and check peak height</span></div>
<div class="line"><a name="l02837"></a><span class="lineno"> 2837</span>&#160;        <span class="keywordflow">if</span> ( CSymList-&gt;at(cIt)[0] != 5.0 || CSymList-&gt;at(cIt)[5] &lt; minPeakHeight ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l02838"></a><span class="lineno"> 2838</span>&#160; </div>
<div class="line"><a name="l02839"></a><span class="lineno"> 2839</span>&#160;        <span class="comment">//============================================ If second or more C5, check if it has the correct angle to all other already found C5s for each group</span></div>
<div class="line"><a name="l02840"></a><span class="lineno"> 2840</span>&#160;        groupMatched                                  = <span class="keyword">false</span>;</div>
<div class="line"><a name="l02841"></a><span class="lineno"> 2841</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign gIt = 0; gIt &lt; static_cast&lt;proshade_unsign&gt; ( C5Possibilities.size() ); gIt++ )</div>
<div class="line"><a name="l02842"></a><span class="lineno"> 2842</span>&#160;        {</div>
<div class="line"><a name="l02843"></a><span class="lineno"> 2843</span>&#160;            <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad8c193e95c7069fafa78dccc1de1aaa4">ProSHADE_internal_symmetry::testGroupAgainstSymmetry</a> ( CSymList, &amp;C5Possibilities.at(gIt), CSymList-&gt;at(cIt), axErr, 1.0/2.0, <span class="keyword">true</span>, cIt ) ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C5Possibilities.at(gIt), cIt ); groupMatched = <span class="keyword">true</span>; <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l02844"></a><span class="lineno"> 2844</span>&#160;        }</div>
<div class="line"><a name="l02845"></a><span class="lineno"> 2845</span>&#160; </div>
<div class="line"><a name="l02846"></a><span class="lineno"> 2846</span>&#160;        <span class="comment">//============================================ If no group matched, create a new group</span></div>
<div class="line"><a name="l02847"></a><span class="lineno"> 2847</span>&#160;        <span class="keywordflow">if</span> ( !groupMatched ) { C5PossibilitiesHlp.clear(); <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C5PossibilitiesHlp, cIt ); <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a86e2bb172f766ab4a620df482d2fe481">ProSHADE_internal_misc::addToUnsignVectorVector</a> ( &amp;C5Possibilities, C5PossibilitiesHlp ); <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l02848"></a><span class="lineno"> 2848</span>&#160;    }</div>
<div class="line"><a name="l02849"></a><span class="lineno"> 2849</span>&#160;    </div>
<div class="line"><a name="l02850"></a><span class="lineno"> 2850</span>&#160;    <span class="comment">//================================================ Test for missing symmetry axes, if need be</span></div>
<div class="line"><a name="l02851"></a><span class="lineno"> 2851</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af6093da290ce7b73a33e8b55f2c83491">ProSHADE_internal_symmetry::findMissingAxes</a>       ( &amp;C5Possibilities, CSymList, 6, axErr, 1.0 / 2.0, 5, dataObj, minPeakHeight );</div>
<div class="line"><a name="l02852"></a><span class="lineno"> 2852</span>&#160; </div>
<div class="line"><a name="l02853"></a><span class="lineno"> 2853</span>&#160;    <span class="comment">//=================================================Any group has 6 entries? If more such groups, take the one with highest average height.</span></div>
<div class="line"><a name="l02854"></a><span class="lineno"> 2854</span>&#160;    proshade_double maxHeight = 0.0; proshade_unsign maxGrp = 0;</div>
<div class="line"><a name="l02855"></a><span class="lineno"> 2855</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; static_cast&lt;proshade_unsign&gt; ( C5Possibilities.size() ); iter++ ) { <span class="keywordflow">if</span> ( C5Possibilities.at(iter).size() == 6 ) { <span class="keywordflow">if</span> ( ( ( CSymList-&gt;at(C5Possibilities.at(iter).at(0))[5] + CSymList-&gt;at(C5Possibilities.at(iter).at(1))[5] + CSymList-&gt;at(C5Possibilities.at(iter).at(2))[5] + CSymList-&gt;at(C5Possibilities.at(iter).at(3))[5] + CSymList-&gt;at(C5Possibilities.at(iter).at(4))[5] + CSymList-&gt;at(C5Possibilities.at(iter).at(5))[5] ) / 6.0 ) &gt; maxHeight ) { maxHeight = ( ( CSymList-&gt;at(C5Possibilities.at(iter).at(0))[5] + CSymList-&gt;at(C5Possibilities.at(iter).at(1))[5] + CSymList-&gt;at(C5Possibilities.at(iter).at(2))[5] + CSymList-&gt;at(C5Possibilities.at(iter).at(3))[5] + CSymList-&gt;at(C5Possibilities.at(iter).at(4))[5] + CSymList-&gt;at(C5Possibilities.at(iter).at(5))[5] ) / 6.0 ); maxGrp = iter; } } }</div>
<div class="line"><a name="l02856"></a><span class="lineno"> 2856</span>&#160; </div>
<div class="line"><a name="l02857"></a><span class="lineno"> 2857</span>&#160;    <span class="keywordflow">if</span> ( C5Possibilities.at(maxGrp).size() == 6 )</div>
<div class="line"><a name="l02858"></a><span class="lineno"> 2858</span>&#160;    {</div>
<div class="line"><a name="l02859"></a><span class="lineno"> 2859</span>&#160;        <span class="comment">//============================================ Success! Save and exit</span></div>
<div class="line"><a name="l02860"></a><span class="lineno"> 2860</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign it = 0; it &lt; static_cast&lt;proshade_unsign&gt; ( C5Possibilities.at(maxGrp).size() ); it++ ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a> ( ret, CSymList-&gt;at(C5Possibilities.at(maxGrp).at(it)) ); }</div>
<div class="line"><a name="l02861"></a><span class="lineno"> 2861</span>&#160; </div>
<div class="line"><a name="l02862"></a><span class="lineno"> 2862</span>&#160;        <span class="comment">//============================================ Report progress</span></div>
<div class="line"><a name="l02863"></a><span class="lineno"> 2863</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a6aa8cdb600cad623409802cfaed494fa">ProSHADE_internal_messages::printProgressMessage</a> ( verbose, 3, <span class="stringliteral">&quot;Detection of six C5 axes successfull.&quot;</span> );</div>
<div class="line"><a name="l02864"></a><span class="lineno"> 2864</span>&#160; </div>
<div class="line"><a name="l02865"></a><span class="lineno"> 2865</span>&#160;        <span class="comment">//============================================ Done</span></div>
<div class="line"><a name="l02866"></a><span class="lineno"> 2866</span>&#160;        return ;</div>
<div class="line"><a name="l02867"></a><span class="lineno"> 2867</span>&#160;    }</div>
<div class="line"><a name="l02868"></a><span class="lineno"> 2868</span>&#160;    </div>
<div class="line"><a name="l02869"></a><span class="lineno"> 2869</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l02870"></a><span class="lineno"> 2870</span>&#160;    return ;</div>
<div class="line"><a name="l02871"></a><span class="lineno"> 2871</span>&#160;    </div>
<div class="line"><a name="l02872"></a><span class="lineno"> 2872</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af6093da290ce7b73a33e8b55f2c83491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6093da290ce7b73a33e8b55f2c83491">&#9670;&nbsp;</a></span>findMissingAxes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_symmetry::findMissingAxes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; *&#160;</td>
          <td class="paramname"><em>possibilities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>requiredNoAxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tries to find an axis which would complete a particular group of axes for polyhedral symmetry detection. </p>
<p>This function assumes that there is a set of already detected axes and that for a polyhedral symmetry, another axis with known fold and angle to some of the already detected axis needs to be found. It uses algebraic solution to try to find such an axis (or a given number of them) and also tests for these newly detected axes being unique and having at least minPeakHeight average peak height. If such axes are found, they are added to the CSymList vector and their indices are also added to the possibilities vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">possibilities</td><td>A vector of vectors of indices to the cyclic symmetries list with all the already determined axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">requiredNoAxes</td><td>Number of axes required for positive result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle</td><td>The angle that each group member is required to have against the symmetry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fold</td><td>The fold of the searched for axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataObj</td><td>The full data holding object pointer - this is to get access to self-rotation function values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum new axis average peak height in order for the axis to be added. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">atLeastOne</td><td>Boolean value speciying whether at least the minimum required number of axes was found. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01582">1582</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01583"></a><span class="lineno"> 1583</span>&#160;{</div>
<div class="line"><a name="l01584"></a><span class="lineno"> 1584</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l01585"></a><span class="lineno"> 1585</span>&#160;    std::vector&lt; proshade_double* &gt; hlpVec;</div>
<div class="line"><a name="l01586"></a><span class="lineno"> 1586</span>&#160;    <span class="keywordtype">bool</span> atLeastOne                                   = <span class="keyword">false</span>;</div>
<div class="line"><a name="l01587"></a><span class="lineno"> 1587</span>&#160;    </div>
<div class="line"><a name="l01588"></a><span class="lineno"> 1588</span>&#160;    <span class="comment">//================================================ Proceed only if need be</span></div>
<div class="line"><a name="l01589"></a><span class="lineno"> 1589</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign gIt = 0; gIt &lt; static_cast&lt;proshade_unsign&gt; ( possibilities-&gt;size() ); gIt++ )</div>
<div class="line"><a name="l01590"></a><span class="lineno"> 1590</span>&#160;    {</div>
<div class="line"><a name="l01591"></a><span class="lineno"> 1591</span>&#160;        <span class="keywordflow">if</span> ( <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( possibilities-&gt;at(gIt).size() ) == requiredNoAxes ) { atLeastOne = <span class="keyword">true</span>; <span class="keywordflow">return</span> ( atLeastOne ); }</div>
<div class="line"><a name="l01592"></a><span class="lineno"> 1592</span>&#160;    }</div>
<div class="line"><a name="l01593"></a><span class="lineno"> 1593</span>&#160;    </div>
<div class="line"><a name="l01594"></a><span class="lineno"> 1594</span>&#160;    <span class="comment">//================================================ For each possible group</span></div>
<div class="line"><a name="l01595"></a><span class="lineno"> 1595</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign gIt = 0; gIt &lt; static_cast&lt;proshade_unsign&gt; ( possibilities-&gt;size() ); gIt++ )</div>
<div class="line"><a name="l01596"></a><span class="lineno"> 1596</span>&#160;    {</div>
<div class="line"><a name="l01597"></a><span class="lineno"> 1597</span>&#160;        <span class="comment">//============================================ This will not work for less than two axes in group</span></div>
<div class="line"><a name="l01598"></a><span class="lineno"> 1598</span>&#160;        <span class="keywordflow">if</span> ( possibilities-&gt;at(gIt).size() &lt; 2 ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l01599"></a><span class="lineno"> 1599</span>&#160;        </div>
<div class="line"><a name="l01600"></a><span class="lineno"> 1600</span>&#160;        <span class="comment">//============================================ Prepare iteration</span></div>
<div class="line"><a name="l01601"></a><span class="lineno"> 1601</span>&#160;        hlpVec.clear                                  ( );</div>
<div class="line"><a name="l01602"></a><span class="lineno"> 1602</span>&#160;        </div>
<div class="line"><a name="l01603"></a><span class="lineno"> 1603</span>&#160;        <span class="comment">//============================================ Search for missing axes</span></div>
<div class="line"><a name="l01604"></a><span class="lineno"> 1604</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a1ada2416687dbb0bec93603770cb4c83">ProSHADE_internal_symmetry::searchMissingSymmetrySpace</a> ( dataObj, CSymList, &amp;possibilities-&gt;at(gIt), &amp;hlpVec, axErr, angle, fold, minPeakHeight );</div>
<div class="line"><a name="l01605"></a><span class="lineno"> 1605</span>&#160;        </div>
<div class="line"><a name="l01606"></a><span class="lineno"> 1606</span>&#160;        <span class="comment">//============================================ Add missing axes</span></div>
<div class="line"><a name="l01607"></a><span class="lineno"> 1607</span>&#160;        <span class="keywordflow">if</span> ( hlpVec.size() &gt; 0 )</div>
<div class="line"><a name="l01608"></a><span class="lineno"> 1608</span>&#160;        {</div>
<div class="line"><a name="l01609"></a><span class="lineno"> 1609</span>&#160;            <span class="comment">//======================================== Start adding by highest first</span></div>
<div class="line"><a name="l01610"></a><span class="lineno"> 1610</span>&#160;            std::sort                                 ( hlpVec.begin(), hlpVec.end(), <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a2e915d310892aea124046acd14db4a84">ProSHADE_internal_misc::sortSymHlpInv</a> );</div>
<div class="line"><a name="l01611"></a><span class="lineno"> 1611</span>&#160;            </div>
<div class="line"><a name="l01612"></a><span class="lineno"> 1612</span>&#160;            <span class="comment">//======================================== For each missing axis</span></div>
<div class="line"><a name="l01613"></a><span class="lineno"> 1613</span>&#160;            <span class="keywordflow">for</span> ( proshade_unsign axIt = 0; axIt &lt; static_cast&lt;proshade_unsign&gt; ( hlpVec.size() ); axIt++ )</div>
<div class="line"><a name="l01614"></a><span class="lineno"> 1614</span>&#160;            {</div>
<div class="line"><a name="l01615"></a><span class="lineno"> 1615</span>&#160;                <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad8c193e95c7069fafa78dccc1de1aaa4">ProSHADE_internal_symmetry::testGroupAgainstSymmetry</a> ( CSymList, &amp;possibilities-&gt;at(gIt), hlpVec.at(axIt), axErr, angle, <span class="keyword">false</span> ) )</div>
<div class="line"><a name="l01616"></a><span class="lineno"> 1616</span>&#160;                {</div>
<div class="line"><a name="l01617"></a><span class="lineno"> 1617</span>&#160;                    <span class="comment">//================================ Check for uniqueness</span></div>
<div class="line"><a name="l01618"></a><span class="lineno"> 1618</span>&#160;                    <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2380a3710f7dbe672519c3adda30f7cd">ProSHADE_internal_maths::isAxisUnique</a> ( CSymList, hlpVec.at(axIt), axErr ) )</div>
<div class="line"><a name="l01619"></a><span class="lineno"> 1619</span>&#160;                    {</div>
<div class="line"><a name="l01620"></a><span class="lineno"> 1620</span>&#160;                        <span class="comment">//============================ Add</span></div>
<div class="line"><a name="l01621"></a><span class="lineno"> 1621</span>&#160;                        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a> ( CSymList, hlpVec.at(axIt) );</div>
<div class="line"><a name="l01622"></a><span class="lineno"> 1622</span>&#160;                        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;possibilities-&gt;at(gIt), <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( CSymList-&gt;size()-1 ) );</div>
<div class="line"><a name="l01623"></a><span class="lineno"> 1623</span>&#160;                    }</div>
<div class="line"><a name="l01624"></a><span class="lineno"> 1624</span>&#160;                }</div>
<div class="line"><a name="l01625"></a><span class="lineno"> 1625</span>&#160;            }</div>
<div class="line"><a name="l01626"></a><span class="lineno"> 1626</span>&#160;        }</div>
<div class="line"><a name="l01627"></a><span class="lineno"> 1627</span>&#160;        </div>
<div class="line"><a name="l01628"></a><span class="lineno"> 1628</span>&#160;        <span class="keywordflow">if</span> ( possibilities-&gt;at(gIt).size() == requiredNoAxes ) { atLeastOne = <span class="keyword">true</span>; }</div>
<div class="line"><a name="l01629"></a><span class="lineno"> 1629</span>&#160;    }</div>
<div class="line"><a name="l01630"></a><span class="lineno"> 1630</span>&#160;    </div>
<div class="line"><a name="l01631"></a><span class="lineno"> 1631</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01632"></a><span class="lineno"> 1632</span>&#160;    <span class="keywordflow">return</span>                                            ( atLeastOne );</div>
<div class="line"><a name="l01633"></a><span class="lineno"> 1633</span>&#160;    </div>
<div class="line"><a name="l01634"></a><span class="lineno"> 1634</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6d9f533a789bd5c6031fa77b9649ed3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9f533a789bd5c6031fa77b9649ed3d">&#9670;&nbsp;</a></span>findMissingAxesDual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_symmetry::findMissingAxesDual </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>possibilities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>retGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>requiredNoAxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>noMatchesG1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>angle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>noMatchesG2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>angle2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tries to find a particular symmetry axes which would complete a group of symmetries with two different angle requirement to another group. </p>
<p>This function takes a list of axes to which a new axis should have two particular angles (to two different group members, that is). It then uses algebraic solution finding approach to compute possible solutions which would satisfy this condition, testing whether such solutions comply with the appropriate number of angles to number of members and for the new solutions being unique. If the required number of solutions is found, it will add the newly detected solutions to the CSymList vector and update the possibilities indices list, otherwise it will leave both alone.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">possibilities</td><td>A vector of already detected axis indices which should be extended. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>A list of already detected octahedral axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">retGroup</td><td>A vector of indices in the ret list which form the group to which new axes are compared to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">requiredNoAxes</td><td>Number of axes required for positive result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noMatchesG1</td><td>The number of axes from ret that need to be matched with angle1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle1</td><td>The angle with which noMatchesG1 axes need to be matched with the retGroup axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noMatchesG2</td><td>The number of axes from ret that need to be matched with angle2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle2</td><td>The angle with which noMatchesG2 axes need to be matched with the retGroup axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fold</td><td>The fold of the searched for axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataObj</td><td>The full data holding object pointer - this is to get access to self-rotation function values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">atLeastOne</td><td>Boolean value speciying whether at least the minimum required number of axes was found. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l02434">2434</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02435"></a><span class="lineno"> 2435</span>&#160;{</div>
<div class="line"><a name="l02436"></a><span class="lineno"> 2436</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l02437"></a><span class="lineno"> 2437</span>&#160;    <span class="keywordtype">bool</span> atLeastOne                                   = <span class="keyword">false</span>;</div>
<div class="line"><a name="l02438"></a><span class="lineno"> 2438</span>&#160;    std::vector&lt; proshade_double* &gt; prosp;</div>
<div class="line"><a name="l02439"></a><span class="lineno"> 2439</span>&#160;    std::vector&lt; proshade_double &gt; sol;</div>
<div class="line"><a name="l02440"></a><span class="lineno"> 2440</span>&#160;    </div>
<div class="line"><a name="l02441"></a><span class="lineno"> 2441</span>&#160;    <span class="comment">//================================================ Proceed only if need be</span></div>
<div class="line"><a name="l02442"></a><span class="lineno"> 2442</span>&#160;    <span class="keywordflow">if</span> ( <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( possibilities-&gt;size() ) == requiredNoAxes ) { atLeastOne = <span class="keyword">true</span>; <span class="keywordflow">return</span> ( atLeastOne ); }</div>
<div class="line"><a name="l02443"></a><span class="lineno"> 2443</span>&#160;    </div>
<div class="line"><a name="l02444"></a><span class="lineno"> 2444</span>&#160;    <span class="comment">//================================================ Copy already found to prospective</span></div>
<div class="line"><a name="l02445"></a><span class="lineno"> 2445</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign prIt = 0; prIt &lt; static_cast&lt;proshade_unsign&gt; ( possibilities-&gt;size() ); prIt++ )</div>
<div class="line"><a name="l02446"></a><span class="lineno"> 2446</span>&#160;    {</div>
<div class="line"><a name="l02447"></a><span class="lineno"> 2447</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad56b16f741c8701d43f8f74899c8ab2c">ProSHADE_internal_symmetry::addAxisUnlessSame</a> ( CSymList-&gt;at(possibilities-&gt;at(prIt))[0],</div>
<div class="line"><a name="l02448"></a><span class="lineno"> 2448</span>&#160;                                                        CSymList-&gt;at(possibilities-&gt;at(prIt))[1],</div>
<div class="line"><a name="l02449"></a><span class="lineno"> 2449</span>&#160;                                                        CSymList-&gt;at(possibilities-&gt;at(prIt))[2],</div>
<div class="line"><a name="l02450"></a><span class="lineno"> 2450</span>&#160;                                                        CSymList-&gt;at(possibilities-&gt;at(prIt))[3],</div>
<div class="line"><a name="l02451"></a><span class="lineno"> 2451</span>&#160;                                                        CSymList-&gt;at(possibilities-&gt;at(prIt))[5], &amp;prosp, axErr );</div>
<div class="line"><a name="l02452"></a><span class="lineno"> 2452</span>&#160;    }</div>
<div class="line"><a name="l02453"></a><span class="lineno"> 2453</span>&#160;    </div>
<div class="line"><a name="l02454"></a><span class="lineno"> 2454</span>&#160;    <span class="comment">//================================================ Start generating possible solutions</span></div>
<div class="line"><a name="l02455"></a><span class="lineno"> 2455</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign rgIt1 = 0; rgIt1 &lt; static_cast&lt;proshade_unsign&gt; ( retGroup-&gt;size() ); rgIt1++ )</div>
<div class="line"><a name="l02456"></a><span class="lineno"> 2456</span>&#160;    {</div>
<div class="line"><a name="l02457"></a><span class="lineno"> 2457</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign rgIt2 = 0; rgIt2 &lt; static_cast&lt;proshade_unsign&gt; ( retGroup-&gt;size() ); rgIt2++ )</div>
<div class="line"><a name="l02458"></a><span class="lineno"> 2458</span>&#160;        {</div>
<div class="line"><a name="l02459"></a><span class="lineno"> 2459</span>&#160;            <span class="comment">//======================================== Use unique combinations (order matters here!)</span></div>
<div class="line"><a name="l02460"></a><span class="lineno"> 2460</span>&#160;            <span class="keywordflow">if</span> ( rgIt1 == rgIt2 ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l02461"></a><span class="lineno"> 2461</span>&#160;            </div>
<div class="line"><a name="l02462"></a><span class="lineno"> 2462</span>&#160;            <span class="comment">//======================================== Generate possible solution (1)</span></div>
<div class="line"><a name="l02463"></a><span class="lineno"> 2463</span>&#160;            sol                                       = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a45fbcfaeaabf9bae2fbd7d46a5fb4bc7">ProSHADE_internal_maths::findVectorFromTwoVAndTwoD</a> ( ret-&gt;at(rgIt1)[1], ret-&gt;at(rgIt1)[2], ret-&gt;at(rgIt1)[3],</div>
<div class="line"><a name="l02464"></a><span class="lineno"> 2464</span>&#160;                                                                                                             ret-&gt;at(rgIt2)[1], ret-&gt;at(rgIt2)[2], ret-&gt;at(rgIt2)[3], angle1, angle2 );</div>
<div class="line"><a name="l02465"></a><span class="lineno"> 2465</span>&#160;            </div>
<div class="line"><a name="l02466"></a><span class="lineno"> 2466</span>&#160;            <span class="comment">//======================================== Check if solution fits the group completely</span></div>
<div class="line"><a name="l02467"></a><span class="lineno"> 2467</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a210ee0af651d440b68168882ead71c66">ProSHADE_internal_symmetry::checkFittingAxisDualAndSave</a> ( retGroup, ret, fold, sol.at(0), sol.at(1), sol.at(2), &amp;prosp, axErr, noMatchesG1, angle1, noMatchesG2, angle2, dataObj );</div>
<div class="line"><a name="l02468"></a><span class="lineno"> 2468</span>&#160;            <span class="keywordflow">if</span> ( prosp.size() == requiredNoAxes ) { <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l02469"></a><span class="lineno"> 2469</span>&#160;            </div>
<div class="line"><a name="l02470"></a><span class="lineno"> 2470</span>&#160;            <span class="comment">//======================================== Generate possible solution (2)</span></div>
<div class="line"><a name="l02471"></a><span class="lineno"> 2471</span>&#160;            sol                                       = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a45fbcfaeaabf9bae2fbd7d46a5fb4bc7">ProSHADE_internal_maths::findVectorFromTwoVAndTwoD</a> ( ret-&gt;at(rgIt1)[1], ret-&gt;at(rgIt1)[2], ret-&gt;at(rgIt1)[3],</div>
<div class="line"><a name="l02472"></a><span class="lineno"> 2472</span>&#160;                                                                                                             ret-&gt;at(rgIt2)[1], ret-&gt;at(rgIt2)[2], ret-&gt;at(rgIt2)[3], -angle1, -angle2 );</div>
<div class="line"><a name="l02473"></a><span class="lineno"> 2473</span>&#160;            </div>
<div class="line"><a name="l02474"></a><span class="lineno"> 2474</span>&#160;            <span class="comment">//======================================== Check if solution fits the group completely</span></div>
<div class="line"><a name="l02475"></a><span class="lineno"> 2475</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a210ee0af651d440b68168882ead71c66">ProSHADE_internal_symmetry::checkFittingAxisDualAndSave</a> ( retGroup, ret, fold, sol.at(0), sol.at(1), sol.at(2), &amp;prosp, axErr, noMatchesG1, angle1, noMatchesG2, angle2, dataObj );</div>
<div class="line"><a name="l02476"></a><span class="lineno"> 2476</span>&#160;            <span class="keywordflow">if</span> ( prosp.size() == requiredNoAxes ) { <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l02477"></a><span class="lineno"> 2477</span>&#160;        }</div>
<div class="line"><a name="l02478"></a><span class="lineno"> 2478</span>&#160;        </div>
<div class="line"><a name="l02479"></a><span class="lineno"> 2479</span>&#160;        <span class="keywordflow">if</span> ( prosp.size() == requiredNoAxes ) { <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l02480"></a><span class="lineno"> 2480</span>&#160;    }</div>
<div class="line"><a name="l02481"></a><span class="lineno"> 2481</span>&#160; </div>
<div class="line"><a name="l02482"></a><span class="lineno"> 2482</span>&#160;    <span class="comment">//================================================ Found all required axes!</span></div>
<div class="line"><a name="l02483"></a><span class="lineno"> 2483</span>&#160;    <span class="keywordflow">if</span> ( <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( prosp.size() ) == requiredNoAxes )</div>
<div class="line"><a name="l02484"></a><span class="lineno"> 2484</span>&#160;    {</div>
<div class="line"><a name="l02485"></a><span class="lineno"> 2485</span>&#160;        <span class="comment">//============================================ Copy the detected axes</span></div>
<div class="line"><a name="l02486"></a><span class="lineno"> 2486</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign iter = <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( possibilities-&gt;size() ); iter &lt; <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( prosp.size() ); iter++ )</div>
<div class="line"><a name="l02487"></a><span class="lineno"> 2487</span>&#160;        {</div>
<div class="line"><a name="l02488"></a><span class="lineno"> 2488</span>&#160;            <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2380a3710f7dbe672519c3adda30f7cd">ProSHADE_internal_maths::isAxisUnique</a> ( CSymList, prosp.at(iter), axErr ) )</div>
<div class="line"><a name="l02489"></a><span class="lineno"> 2489</span>&#160;            {</div>
<div class="line"><a name="l02490"></a><span class="lineno"> 2490</span>&#160;                <span class="comment">//==================================== Add</span></div>
<div class="line"><a name="l02491"></a><span class="lineno"> 2491</span>&#160;                <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( possibilities, CSymList-&gt;size() );</div>
<div class="line"><a name="l02492"></a><span class="lineno"> 2492</span>&#160;                <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a> ( CSymList, prosp.at(iter) );</div>
<div class="line"><a name="l02493"></a><span class="lineno"> 2493</span>&#160;            }</div>
<div class="line"><a name="l02494"></a><span class="lineno"> 2494</span>&#160;        }</div>
<div class="line"><a name="l02495"></a><span class="lineno"> 2495</span>&#160;        </div>
<div class="line"><a name="l02496"></a><span class="lineno"> 2496</span>&#160;        <span class="comment">//============================================ Done</span></div>
<div class="line"><a name="l02497"></a><span class="lineno"> 2497</span>&#160;        atLeastOne                                    = <span class="keyword">true</span>;</div>
<div class="line"><a name="l02498"></a><span class="lineno"> 2498</span>&#160;        <span class="keywordflow">return</span>                                        ( atLeastOne );</div>
<div class="line"><a name="l02499"></a><span class="lineno"> 2499</span>&#160;    }</div>
<div class="line"><a name="l02500"></a><span class="lineno"> 2500</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l02501"></a><span class="lineno"> 2501</span>&#160;    {</div>
<div class="line"><a name="l02502"></a><span class="lineno"> 2502</span>&#160;        <span class="comment">//============================================ Delete the created, but not used axes</span></div>
<div class="line"><a name="l02503"></a><span class="lineno"> 2503</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign iter = <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( possibilities-&gt;size() ); iter &lt; <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( prosp.size() ); iter++ )</div>
<div class="line"><a name="l02504"></a><span class="lineno"> 2504</span>&#160;        {</div>
<div class="line"><a name="l02505"></a><span class="lineno"> 2505</span>&#160;            <span class="keyword">delete</span>[] prosp.at(iter);</div>
<div class="line"><a name="l02506"></a><span class="lineno"> 2506</span>&#160;        }</div>
<div class="line"><a name="l02507"></a><span class="lineno"> 2507</span>&#160;    }</div>
<div class="line"><a name="l02508"></a><span class="lineno"> 2508</span>&#160;    </div>
<div class="line"><a name="l02509"></a><span class="lineno"> 2509</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l02510"></a><span class="lineno"> 2510</span>&#160;    <span class="keywordflow">return</span>                                            ( atLeastOne );</div>
<div class="line"><a name="l02511"></a><span class="lineno"> 2511</span>&#160;    </div>
<div class="line"><a name="l02512"></a><span class="lineno"> 2512</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae266053664eb7cf916aa5e2d282e35dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae266053664eb7cf916aa5e2d282e35dd">&#9670;&nbsp;</a></span>findMissingAxesTriple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_symmetry::findMissingAxesTriple </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>possibilities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>retGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>requiredNoAxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>noMatchesG1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>angle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>noMatchesG2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>angle2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>noMatchesG3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>angle3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tries to find a particular symmetry axis which would complete a group of symmetries with three different angle requirement to another group. </p>
<p>Assuming there is a group of symmetry axis, which have particular number of particular angles to each other, but some are missing, this function tries to find any such missing axes. This is a solution for the group of axes having three different angles to the other group members. For all newly detected group members, the average peak height and the uniqueness are both tested for.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">possibilities</td><td>A vector of already detected axis indices which should be extended. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>A list of already detected octahedral axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">retGroup</td><td>A vector of indices in the ret list which form the group to which new axes are compared to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">requiredNoAxes</td><td>Number of axes required for positive result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noMatchesG1</td><td>The number of axes from ret that need to be matched with angle1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle1</td><td>The angle with which noMatchesG1 axes need to be matched with the retGroup axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noMatchesG2</td><td>The number of axes from ret that need to be matched with angle2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle2</td><td>The angle with which noMatchesG2 axes need to be matched with the retGroup axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noMatchesG3</td><td>The number of axes from ret that need to be matched with angle3. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle3</td><td>The angle with which noMatchesG3 axes need to be matched with the retGroup axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fold</td><td>The fold of the searched for axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataObj</td><td>The full data holding object pointer - this is to get access to self-rotation function values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">atLeastOne</td><td>Boolean value speciying whether at least the minimum required number of axes was found. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l03411">3411</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03412"></a><span class="lineno"> 3412</span>&#160;{</div>
<div class="line"><a name="l03413"></a><span class="lineno"> 3413</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l03414"></a><span class="lineno"> 3414</span>&#160;    <span class="keywordtype">bool</span> atLeastOne                                   = <span class="keyword">false</span>;</div>
<div class="line"><a name="l03415"></a><span class="lineno"> 3415</span>&#160;    std::vector&lt; proshade_double* &gt; prosp;</div>
<div class="line"><a name="l03416"></a><span class="lineno"> 3416</span>&#160;    std::vector&lt; proshade_double &gt; sol;</div>
<div class="line"><a name="l03417"></a><span class="lineno"> 3417</span>&#160;    </div>
<div class="line"><a name="l03418"></a><span class="lineno"> 3418</span>&#160;    <span class="comment">//================================================ Proceed only if need be</span></div>
<div class="line"><a name="l03419"></a><span class="lineno"> 3419</span>&#160;    <span class="keywordflow">if</span> ( <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( possibilities-&gt;size() ) == requiredNoAxes ) { atLeastOne = <span class="keyword">true</span>; <span class="keywordflow">return</span> ( atLeastOne ); }</div>
<div class="line"><a name="l03420"></a><span class="lineno"> 3420</span>&#160;    </div>
<div class="line"><a name="l03421"></a><span class="lineno"> 3421</span>&#160;    <span class="comment">//================================================ Copy already found to prospective</span></div>
<div class="line"><a name="l03422"></a><span class="lineno"> 3422</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign prIt = 0; prIt &lt; static_cast&lt;proshade_unsign&gt; ( possibilities-&gt;size() ); prIt++ )</div>
<div class="line"><a name="l03423"></a><span class="lineno"> 3423</span>&#160;    {</div>
<div class="line"><a name="l03424"></a><span class="lineno"> 3424</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad56b16f741c8701d43f8f74899c8ab2c">ProSHADE_internal_symmetry::addAxisUnlessSame</a> ( CSymList-&gt;at(possibilities-&gt;at(prIt))[0],</div>
<div class="line"><a name="l03425"></a><span class="lineno"> 3425</span>&#160;                                                        CSymList-&gt;at(possibilities-&gt;at(prIt))[1],</div>
<div class="line"><a name="l03426"></a><span class="lineno"> 3426</span>&#160;                                                        CSymList-&gt;at(possibilities-&gt;at(prIt))[2],</div>
<div class="line"><a name="l03427"></a><span class="lineno"> 3427</span>&#160;                                                        CSymList-&gt;at(possibilities-&gt;at(prIt))[3],</div>
<div class="line"><a name="l03428"></a><span class="lineno"> 3428</span>&#160;                                                        CSymList-&gt;at(possibilities-&gt;at(prIt))[5], &amp;prosp, axErr );</div>
<div class="line"><a name="l03429"></a><span class="lineno"> 3429</span>&#160;    }</div>
<div class="line"><a name="l03430"></a><span class="lineno"> 3430</span>&#160;    </div>
<div class="line"><a name="l03431"></a><span class="lineno"> 3431</span>&#160;    <span class="comment">//================================================ Start generating possible solutions</span></div>
<div class="line"><a name="l03432"></a><span class="lineno"> 3432</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign rgIt1 = 0; rgIt1 &lt; static_cast&lt;proshade_unsign&gt; ( retGroup-&gt;size() ); rgIt1++ )</div>
<div class="line"><a name="l03433"></a><span class="lineno"> 3433</span>&#160;    {</div>
<div class="line"><a name="l03434"></a><span class="lineno"> 3434</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign rgIt2 = 0; rgIt2 &lt; static_cast&lt;proshade_unsign&gt; ( retGroup-&gt;size() ); rgIt2++ )</div>
<div class="line"><a name="l03435"></a><span class="lineno"> 3435</span>&#160;        {</div>
<div class="line"><a name="l03436"></a><span class="lineno"> 3436</span>&#160;            <span class="comment">//======================================== Use unique combinations (order matters here!)</span></div>
<div class="line"><a name="l03437"></a><span class="lineno"> 3437</span>&#160;            <span class="keywordflow">if</span> ( rgIt1 == rgIt2 ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l03438"></a><span class="lineno"> 3438</span>&#160;            </div>
<div class="line"><a name="l03439"></a><span class="lineno"> 3439</span>&#160;            <span class="keywordflow">for</span> ( proshade_unsign rgIt3 = 0; rgIt3 &lt; static_cast&lt;proshade_unsign&gt; ( retGroup-&gt;size() ); rgIt3++ )</div>
<div class="line"><a name="l03440"></a><span class="lineno"> 3440</span>&#160;            {</div>
<div class="line"><a name="l03441"></a><span class="lineno"> 3441</span>&#160;                <span class="comment">//==================================== Use unique combinations (order matters here!)</span></div>
<div class="line"><a name="l03442"></a><span class="lineno"> 3442</span>&#160;                <span class="keywordflow">if</span> ( ( rgIt1 == rgIt3 ) || ( rgIt2 == rgIt3 ) ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l03443"></a><span class="lineno"> 3443</span>&#160;                </div>
<div class="line"><a name="l03444"></a><span class="lineno"> 3444</span>&#160;                <span class="comment">//==================================== Generate possible solution (1)</span></div>
<div class="line"><a name="l03445"></a><span class="lineno"> 3445</span>&#160;                sol                                   = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#ae9f376bb341b192fff008b9b4ef5c603">ProSHADE_internal_maths::findVectorFromThreeVAndThreeD</a> ( ret-&gt;at(rgIt1)[1], ret-&gt;at(rgIt1)[2], ret-&gt;at(rgIt1)[3],</div>
<div class="line"><a name="l03446"></a><span class="lineno"> 3446</span>&#160;                                                                                                                 ret-&gt;at(rgIt2)[1], ret-&gt;at(rgIt2)[2], ret-&gt;at(rgIt2)[3],</div>
<div class="line"><a name="l03447"></a><span class="lineno"> 3447</span>&#160;                                                                                                                 ret-&gt;at(rgIt3)[1], ret-&gt;at(rgIt3)[2], ret-&gt;at(rgIt3)[3], angle1, angle2, angle3 );</div>
<div class="line"><a name="l03448"></a><span class="lineno"> 3448</span>&#160;                </div>
<div class="line"><a name="l03449"></a><span class="lineno"> 3449</span>&#160;                <span class="comment">//==================================== Check if solution fits the group completely</span></div>
<div class="line"><a name="l03450"></a><span class="lineno"> 3450</span>&#160;                <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a194944b48a4b6b523ef251a2a03eab17">ProSHADE_internal_symmetry::checkFittingAxisTripleAndSave</a> ( retGroup, ret, fold, sol.at(0), sol.at(1), sol.at(2), &amp;prosp, axErr, noMatchesG1, angle1, noMatchesG2, angle2, noMatchesG3, angle3, dataObj );</div>
<div class="line"><a name="l03451"></a><span class="lineno"> 3451</span>&#160;                <span class="keywordflow">if</span> ( prosp.size() == requiredNoAxes ) { <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l03452"></a><span class="lineno"> 3452</span>&#160;                </div>
<div class="line"><a name="l03453"></a><span class="lineno"> 3453</span>&#160;                <span class="comment">//==================================== Generate possible solution (2)</span></div>
<div class="line"><a name="l03454"></a><span class="lineno"> 3454</span>&#160;                sol                                   = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#ae9f376bb341b192fff008b9b4ef5c603">ProSHADE_internal_maths::findVectorFromThreeVAndThreeD</a> ( ret-&gt;at(rgIt1)[1], ret-&gt;at(rgIt1)[2], ret-&gt;at(rgIt1)[3],</div>
<div class="line"><a name="l03455"></a><span class="lineno"> 3455</span>&#160;                                                                                                                 ret-&gt;at(rgIt2)[1], ret-&gt;at(rgIt2)[2], ret-&gt;at(rgIt2)[3],</div>
<div class="line"><a name="l03456"></a><span class="lineno"> 3456</span>&#160;                                                                                                                 ret-&gt;at(rgIt3)[1], ret-&gt;at(rgIt3)[2], ret-&gt;at(rgIt3)[3], -angle1, -angle2, -angle3 );</div>
<div class="line"><a name="l03457"></a><span class="lineno"> 3457</span>&#160;                </div>
<div class="line"><a name="l03458"></a><span class="lineno"> 3458</span>&#160;                <span class="comment">//==================================== Check if solution fits the group completely</span></div>
<div class="line"><a name="l03459"></a><span class="lineno"> 3459</span>&#160;                <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a194944b48a4b6b523ef251a2a03eab17">ProSHADE_internal_symmetry::checkFittingAxisTripleAndSave</a> ( retGroup, ret, fold, sol.at(0), sol.at(1), sol.at(2), &amp;prosp, axErr, noMatchesG1, angle1, noMatchesG2, angle2, noMatchesG3, angle3, dataObj );</div>
<div class="line"><a name="l03460"></a><span class="lineno"> 3460</span>&#160;                <span class="keywordflow">if</span> ( prosp.size() == requiredNoAxes ) { <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l03461"></a><span class="lineno"> 3461</span>&#160;            }</div>
<div class="line"><a name="l03462"></a><span class="lineno"> 3462</span>&#160;            </div>
<div class="line"><a name="l03463"></a><span class="lineno"> 3463</span>&#160;            <span class="keywordflow">if</span> ( prosp.size() == requiredNoAxes ) { <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l03464"></a><span class="lineno"> 3464</span>&#160;        }</div>
<div class="line"><a name="l03465"></a><span class="lineno"> 3465</span>&#160;        </div>
<div class="line"><a name="l03466"></a><span class="lineno"> 3466</span>&#160;        <span class="keywordflow">if</span> ( prosp.size() == requiredNoAxes ) { <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l03467"></a><span class="lineno"> 3467</span>&#160;    }</div>
<div class="line"><a name="l03468"></a><span class="lineno"> 3468</span>&#160;    </div>
<div class="line"><a name="l03469"></a><span class="lineno"> 3469</span>&#160;    <span class="comment">//================================================ Found all required axes</span></div>
<div class="line"><a name="l03470"></a><span class="lineno"> 3470</span>&#160;    <span class="keywordflow">if</span> ( prosp.size() == requiredNoAxes )</div>
<div class="line"><a name="l03471"></a><span class="lineno"> 3471</span>&#160;    {</div>
<div class="line"><a name="l03472"></a><span class="lineno"> 3472</span>&#160;        <span class="comment">//============================================ For each found missing axis</span></div>
<div class="line"><a name="l03473"></a><span class="lineno"> 3473</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign axIt = <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( possibilities-&gt;size() ); axIt &lt; <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( prosp.size() ); axIt++ )</div>
<div class="line"><a name="l03474"></a><span class="lineno"> 3474</span>&#160;        {</div>
<div class="line"><a name="l03475"></a><span class="lineno"> 3475</span>&#160;            <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2380a3710f7dbe672519c3adda30f7cd">ProSHADE_internal_maths::isAxisUnique</a> ( CSymList, prosp.at(axIt), axErr ) )</div>
<div class="line"><a name="l03476"></a><span class="lineno"> 3476</span>&#160;            {</div>
<div class="line"><a name="l03477"></a><span class="lineno"> 3477</span>&#160;                <span class="comment">//======================================== Add</span></div>
<div class="line"><a name="l03478"></a><span class="lineno"> 3478</span>&#160;                <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a> ( CSymList, prosp.at(axIt) );</div>
<div class="line"><a name="l03479"></a><span class="lineno"> 3479</span>&#160;                <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( possibilities, <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( CSymList-&gt;size()-1 ) );</div>
<div class="line"><a name="l03480"></a><span class="lineno"> 3480</span>&#160;            }</div>
<div class="line"><a name="l03481"></a><span class="lineno"> 3481</span>&#160;        }</div>
<div class="line"><a name="l03482"></a><span class="lineno"> 3482</span>&#160;        </div>
<div class="line"><a name="l03483"></a><span class="lineno"> 3483</span>&#160;        atLeastOne                                    = <span class="keyword">true</span>;</div>
<div class="line"><a name="l03484"></a><span class="lineno"> 3484</span>&#160;        <span class="keywordflow">return</span>                                        ( atLeastOne );</div>
<div class="line"><a name="l03485"></a><span class="lineno"> 3485</span>&#160;    }</div>
<div class="line"><a name="l03486"></a><span class="lineno"> 3486</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l03487"></a><span class="lineno"> 3487</span>&#160;    {</div>
<div class="line"><a name="l03488"></a><span class="lineno"> 3488</span>&#160;        <span class="comment">//============================================ Delete all found, but unnecessary axes</span></div>
<div class="line"><a name="l03489"></a><span class="lineno"> 3489</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign axIt = <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( possibilities-&gt;size() ); axIt &lt; <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( prosp.size() ); axIt++ )</div>
<div class="line"><a name="l03490"></a><span class="lineno"> 3490</span>&#160;        {</div>
<div class="line"><a name="l03491"></a><span class="lineno"> 3491</span>&#160;            <span class="keyword">delete</span>[] prosp.at(axIt);</div>
<div class="line"><a name="l03492"></a><span class="lineno"> 3492</span>&#160;        }</div>
<div class="line"><a name="l03493"></a><span class="lineno"> 3493</span>&#160;    }</div>
<div class="line"><a name="l03494"></a><span class="lineno"> 3494</span>&#160;    </div>
<div class="line"><a name="l03495"></a><span class="lineno"> 3495</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l03496"></a><span class="lineno"> 3496</span>&#160;    <span class="keywordflow">return</span>                                            ( atLeastOne );</div>
<div class="line"><a name="l03497"></a><span class="lineno"> 3497</span>&#160;    </div>
<div class="line"><a name="l03498"></a><span class="lineno"> 3498</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a465606e58df7d6a2238d40c6919b2e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a465606e58df7d6a2238d40c6919b2e58">&#9670;&nbsp;</a></span>findMissingAxisPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; proshade_double * &gt; ProSHADE_internal_symmetry::findMissingAxisPoints </td>
          <td>(</td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>xVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>yVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>zVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function searches for all the self-rotation map points conforming to the axis, returning their angles and heights. </p>
<p>This helper function searches the self-rotation map point by point for all points which represent the same rotation axis as required by the input parameters. For all such points, it records the angle they represent and the map height associated with them. Finally, it returns a vector of all detected points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xVal</td><td>The x-axis element of the axis to have the height detected. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yVal</td><td>The y-axis element of the axis to have the height detected. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zVal</td><td>The z-axis element of the axis to have the height detected. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataObj</td><td>The full data holding object pointer - this is to get access to self-rotation function values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">angVec</td><td>Vector containing all map points which conform to the required axis along with their heights. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01725">1725</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01726"></a><span class="lineno"> 1726</span>&#160;{</div>
<div class="line"><a name="l01727"></a><span class="lineno"> 1727</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l01728"></a><span class="lineno"> 1728</span>&#160;    proshade_double euA, euB, euG, xPk, yPk, zPk, anglPk;</div>
<div class="line"><a name="l01729"></a><span class="lineno"> 1729</span>&#160;    proshade_double* rotMat                           = <span class="keyword">new</span> proshade_double [9];</div>
<div class="line"><a name="l01730"></a><span class="lineno"> 1730</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( rotMat, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l01731"></a><span class="lineno"> 1731</span>&#160;    proshade_unsign arrIndex;</div>
<div class="line"><a name="l01732"></a><span class="lineno"> 1732</span>&#160;    std::vector&lt; proshade_double* &gt; angVec;</div>
<div class="line"><a name="l01733"></a><span class="lineno"> 1733</span>&#160;    </div>
<div class="line"><a name="l01734"></a><span class="lineno"> 1734</span>&#160;    <span class="comment">//================================================ Search the self-rotation map</span></div>
<div class="line"><a name="l01735"></a><span class="lineno"> 1735</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign xIt = 0; xIt &lt; ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a152b43815a3d3debd4b60751d9c8afdd">getMaxBand</a>() * 2 ); xIt++ )</div>
<div class="line"><a name="l01736"></a><span class="lineno"> 1736</span>&#160;    {</div>
<div class="line"><a name="l01737"></a><span class="lineno"> 1737</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign yIt = 0; yIt &lt; ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a152b43815a3d3debd4b60751d9c8afdd">getMaxBand</a>() * 2 ); yIt++ )</div>
<div class="line"><a name="l01738"></a><span class="lineno"> 1738</span>&#160;        {</div>
<div class="line"><a name="l01739"></a><span class="lineno"> 1739</span>&#160;            <span class="keywordflow">for</span> ( proshade_unsign zIt = 0; zIt &lt; ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a152b43815a3d3debd4b60751d9c8afdd">getMaxBand</a>() * 2 ); zIt++ )</div>
<div class="line"><a name="l01740"></a><span class="lineno"> 1740</span>&#160;            {</div>
<div class="line"><a name="l01741"></a><span class="lineno"> 1741</span>&#160;                <span class="comment">//==================================== Get height and check against threshold</span></div>
<div class="line"><a name="l01742"></a><span class="lineno"> 1742</span>&#160;                arrIndex                              = zIt  + ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a152b43815a3d3debd4b60751d9c8afdd">getMaxBand</a>() * 2 ) * ( yIt  + ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a152b43815a3d3debd4b60751d9c8afdd">getMaxBand</a>() * 2 ) * xIt );</div>
<div class="line"><a name="l01743"></a><span class="lineno"> 1743</span>&#160;                </div>
<div class="line"><a name="l01744"></a><span class="lineno"> 1744</span>&#160;                <span class="comment">//==================================== Get angle-axis values</span></div>
<div class="line"><a name="l01745"></a><span class="lineno"> 1745</span>&#160;                <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#acf6c5376edac98e54ef0e418cd05d706">ProSHADE_internal_maths::getEulerZXZFromSOFTPosition</a> ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a152b43815a3d3debd4b60751d9c8afdd">getMaxBand</a>(), <span class="keyword">static_cast&lt;</span>proshade_signed<span class="keyword">&gt;</span> ( xIt ),</div>
<div class="line"><a name="l01746"></a><span class="lineno"> 1746</span>&#160;                                                                       <span class="keyword">static_cast&lt;</span>proshade_signed<span class="keyword">&gt;</span> ( yIt ), <span class="keyword">static_cast&lt;</span>proshade_signed<span class="keyword">&gt;</span> ( zIt ),</div>
<div class="line"><a name="l01747"></a><span class="lineno"> 1747</span>&#160;                                                                       &amp;euA, &amp;euB, &amp;euG );</div>
<div class="line"><a name="l01748"></a><span class="lineno"> 1748</span>&#160;                <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#abd9fe573a48f499dd7d1df4f779222f1">ProSHADE_internal_maths::getRotationMatrixFromEulerZXZAngles</a> ( euA, euB, euG, rotMat );</div>
<div class="line"><a name="l01749"></a><span class="lineno"> 1749</span>&#160;                <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#aafc6f1626c7463de53c9f4f6fa11db22">ProSHADE_internal_maths::getAxisAngleFromRotationMatrix</a> ( rotMat, &amp;xPk, &amp;yPk, &amp;zPk, &amp;anglPk );</div>
<div class="line"><a name="l01750"></a><span class="lineno"> 1750</span>&#160;                </div>
<div class="line"><a name="l01751"></a><span class="lineno"> 1751</span>&#160;                <span class="comment">//==================================== Set largest axis element to positive</span></div>
<div class="line"><a name="l01752"></a><span class="lineno"> 1752</span>&#160;                <span class="keywordflow">if</span> ( ( ( std::max ( std::abs ( xPk ), std::max( std::abs ( yPk ), std::abs ( zPk ) ) ) == std::abs ( xPk ) ) &amp;&amp; ( xPk &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l01753"></a><span class="lineno"> 1753</span>&#160;                     ( ( std::max ( std::abs ( xPk ), std::max( std::abs ( yPk ), std::abs ( zPk ) ) ) == std::abs ( yPk ) ) &amp;&amp; ( yPk &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l01754"></a><span class="lineno"> 1754</span>&#160;                     ( ( std::max ( std::abs ( xPk ), std::max( std::abs ( yPk ), std::abs ( zPk ) ) ) == std::abs ( zPk ) ) &amp;&amp; ( zPk &lt; 0.0 ) ) )</div>
<div class="line"><a name="l01755"></a><span class="lineno"> 1755</span>&#160;                {</div>
<div class="line"><a name="l01756"></a><span class="lineno"> 1756</span>&#160;                    xPk                              *= -1.0;</div>
<div class="line"><a name="l01757"></a><span class="lineno"> 1757</span>&#160;                    yPk                              *= -1.0;</div>
<div class="line"><a name="l01758"></a><span class="lineno"> 1758</span>&#160;                    zPk                              *= -1.0;</div>
<div class="line"><a name="l01759"></a><span class="lineno"> 1759</span>&#160;                    anglPk                           *= -1.0;</div>
<div class="line"><a name="l01760"></a><span class="lineno"> 1760</span>&#160;                }</div>
<div class="line"><a name="l01761"></a><span class="lineno"> 1761</span>&#160;                </div>
<div class="line"><a name="l01762"></a><span class="lineno"> 1762</span>&#160;                <span class="comment">//==================================== Does the peak match the required axis?</span></div>
<div class="line"><a name="l01763"></a><span class="lineno"> 1763</span>&#160;                <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2b2f67cba1eea57f19fdaf062db74fde">ProSHADE_internal_maths::vectorOrientationSimilarity</a> ( xPk, yPk, zPk, xVal, yVal, zVal, axErr ) )</div>
<div class="line"><a name="l01764"></a><span class="lineno"> 1764</span>&#160;                {</div>
<div class="line"><a name="l01765"></a><span class="lineno"> 1765</span>&#160;                    <span class="comment">//================================ Matching map point - save it</span></div>
<div class="line"><a name="l01766"></a><span class="lineno"> 1766</span>&#160;                    proshade_double* hlpArr           = <span class="keyword">new</span> proshade_double [2];</div>
<div class="line"><a name="l01767"></a><span class="lineno"> 1767</span>&#160;                    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a> ( hlpArr, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l01768"></a><span class="lineno"> 1768</span>&#160;                    hlpArr[0]                         = anglPk + M_PI;</div>
<div class="line"><a name="l01769"></a><span class="lineno"> 1769</span>&#160;                    hlpArr[1]                         = pow( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a2eb10989a2f8d46b849cdaf8410b68be">getInvSO3Coeffs</a>()[arrIndex][0], 2.0 ) +</div>
<div class="line"><a name="l01770"></a><span class="lineno"> 1770</span>&#160;                                                        pow( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a2eb10989a2f8d46b849cdaf8410b68be">getInvSO3Coeffs</a>()[arrIndex][1], 2.0 );</div>
<div class="line"><a name="l01771"></a><span class="lineno"> 1771</span>&#160;                    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a> ( &amp;angVec, hlpArr );</div>
<div class="line"><a name="l01772"></a><span class="lineno"> 1772</span>&#160;                }</div>
<div class="line"><a name="l01773"></a><span class="lineno"> 1773</span>&#160;            }</div>
<div class="line"><a name="l01774"></a><span class="lineno"> 1774</span>&#160;        }</div>
<div class="line"><a name="l01775"></a><span class="lineno"> 1775</span>&#160;    }</div>
<div class="line"><a name="l01776"></a><span class="lineno"> 1776</span>&#160;    </div>
<div class="line"><a name="l01777"></a><span class="lineno"> 1777</span>&#160;    <span class="comment">//================================================ Release memory</span></div>
<div class="line"><a name="l01778"></a><span class="lineno"> 1778</span>&#160;    <span class="keyword">delete</span>[] rotMat;</div>
<div class="line"><a name="l01779"></a><span class="lineno"> 1779</span>&#160;    </div>
<div class="line"><a name="l01780"></a><span class="lineno"> 1780</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01781"></a><span class="lineno"> 1781</span>&#160;    <span class="keywordflow">return</span>                                            ( angVec );</div>
<div class="line"><a name="l01782"></a><span class="lineno"> 1782</span>&#160;    </div>
<div class="line"><a name="l01783"></a><span class="lineno"> 1783</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aaa63ba6643fd35a6fa67a969ef5e92d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa63ba6643fd35a6fa67a969ef5e92d9">&#9670;&nbsp;</a></span>findOcta3C4s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::findOcta3C4s </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes the list of C symmetries and finds the 3 C4 symmetries with perpendicular angles required for full octahedral symmetry. </p>
<p>This function is specific to detecting the octahedral symmetry. It should be called once octahedral symmetry is suspected (by detecting its dihedral angles) and it needs to be fully described. This function specifically searches for the three C4 symmetries which must all be detected in order to fully describe octahedral symmetry. If all three are found, the ret vector will contain these as its only four entries, while it will be empty if some of the C4 symmetries are not found. The missing symmetry axis detection is implemented as part of this function as well.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>The vector containing all axes required for the octahedral symmetry detected so far. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum average peak height for axis to be considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verobse</td><td>How loud the announcments should be? </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l02206">2206</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02207"></a><span class="lineno"> 2207</span>&#160;{</div>
<div class="line"><a name="l02208"></a><span class="lineno"> 2208</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l02209"></a><span class="lineno"> 2209</span>&#160;    std::vector&lt; proshade_unsign &gt; C4PossibilitiesHlp;</div>
<div class="line"><a name="l02210"></a><span class="lineno"> 2210</span>&#160;    std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; C4Possibilities;</div>
<div class="line"><a name="l02211"></a><span class="lineno"> 2211</span>&#160;    <span class="keywordtype">bool</span> groupMatched;</div>
<div class="line"><a name="l02212"></a><span class="lineno"> 2212</span>&#160;    </div>
<div class="line"><a name="l02213"></a><span class="lineno"> 2213</span>&#160;    <span class="comment">//================================================ Report progress</span></div>
<div class="line"><a name="l02214"></a><span class="lineno"> 2214</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a6aa8cdb600cad623409802cfaed494fa">ProSHADE_internal_messages::printProgressMessage</a>  ( verbose, 2, <span class="stringliteral">&quot;Starting detection of three C4 axes.&quot;</span> );</div>
<div class="line"><a name="l02215"></a><span class="lineno"> 2215</span>&#160;    </div>
<div class="line"><a name="l02216"></a><span class="lineno"> 2216</span>&#160;    <span class="comment">//================================================ For all symmetries in the C symmetries list</span></div>
<div class="line"><a name="l02217"></a><span class="lineno"> 2217</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign cIt = 0; cIt &lt; static_cast&lt;proshade_unsign&gt; ( CSymList-&gt;size() ); cIt++ )</div>
<div class="line"><a name="l02218"></a><span class="lineno"> 2218</span>&#160;    {</div>
<div class="line"><a name="l02219"></a><span class="lineno"> 2219</span>&#160;        <span class="comment">//============================================ Search only using C4s</span></div>
<div class="line"><a name="l02220"></a><span class="lineno"> 2220</span>&#160;        <span class="keywordflow">if</span> ( CSymList-&gt;at(cIt)[0] != 4.0 || CSymList-&gt;at(cIt)[5] &lt; minPeakHeight ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l02221"></a><span class="lineno"> 2221</span>&#160; </div>
<div class="line"><a name="l02222"></a><span class="lineno"> 2222</span>&#160;        <span class="comment">//============================================ If second or more C4, check if it has the correct angle to all other already found C4s for each group</span></div>
<div class="line"><a name="l02223"></a><span class="lineno"> 2223</span>&#160;        groupMatched                                  = <span class="keyword">false</span>;</div>
<div class="line"><a name="l02224"></a><span class="lineno"> 2224</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign gIt = 0; gIt &lt; static_cast&lt;proshade_unsign&gt; ( C4Possibilities.size() ); gIt++ )</div>
<div class="line"><a name="l02225"></a><span class="lineno"> 2225</span>&#160;        {</div>
<div class="line"><a name="l02226"></a><span class="lineno"> 2226</span>&#160;            <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad8c193e95c7069fafa78dccc1de1aaa4">ProSHADE_internal_symmetry::testGroupAgainstSymmetry</a> ( CSymList, &amp;C4Possibilities.at(gIt), CSymList-&gt;at(cIt), axErr, 0.0, <span class="keyword">true</span>, cIt ) ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C4Possibilities.at(gIt), cIt ); groupMatched = <span class="keyword">true</span>; <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l02227"></a><span class="lineno"> 2227</span>&#160;        }</div>
<div class="line"><a name="l02228"></a><span class="lineno"> 2228</span>&#160; </div>
<div class="line"><a name="l02229"></a><span class="lineno"> 2229</span>&#160;        <span class="comment">//=========================================== If no group matched, create a new group</span></div>
<div class="line"><a name="l02230"></a><span class="lineno"> 2230</span>&#160;        <span class="keywordflow">if</span> ( !groupMatched ) { C4PossibilitiesHlp.clear(); <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C4PossibilitiesHlp, cIt ); <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a86e2bb172f766ab4a620df482d2fe481">ProSHADE_internal_misc::addToUnsignVectorVector</a> ( &amp;C4Possibilities, C4PossibilitiesHlp ); <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l02231"></a><span class="lineno"> 2231</span>&#160;    }</div>
<div class="line"><a name="l02232"></a><span class="lineno"> 2232</span>&#160; </div>
<div class="line"><a name="l02233"></a><span class="lineno"> 2233</span>&#160;    <span class="comment">//================================================ Test for missing symmetry axes, if need be</span></div>
<div class="line"><a name="l02234"></a><span class="lineno"> 2234</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af6093da290ce7b73a33e8b55f2c83491">ProSHADE_internal_symmetry::findMissingAxes</a>       ( &amp;C4Possibilities, CSymList, 3, axErr, 0.0, 4, dataObj, minPeakHeight );</div>
<div class="line"><a name="l02235"></a><span class="lineno"> 2235</span>&#160; </div>
<div class="line"><a name="l02236"></a><span class="lineno"> 2236</span>&#160;    <span class="comment">//================================================ Any group has 3 entries? If more such groups, take the one with highest average height.</span></div>
<div class="line"><a name="l02237"></a><span class="lineno"> 2237</span>&#160;    proshade_double maxHeight = 0.0; proshade_unsign maxGrp = 0;</div>
<div class="line"><a name="l02238"></a><span class="lineno"> 2238</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; static_cast&lt;proshade_unsign&gt; ( C4Possibilities.size() ); iter++ ) { <span class="keywordflow">if</span> ( C4Possibilities.at(iter).size() == 3 ) { <span class="keywordflow">if</span> ( ( ( CSymList-&gt;at(C4Possibilities.at(iter).at(0))[5] + CSymList-&gt;at(C4Possibilities.at(iter).at(1))[5] + CSymList-&gt;at(C4Possibilities.at(iter).at(2))[5] ) / 3.0 ) &gt; maxHeight ) { maxHeight = ( ( CSymList-&gt;at(C4Possibilities.at(iter).at(0))[5] + CSymList-&gt;at(C4Possibilities.at(iter).at(1))[5] + CSymList-&gt;at(C4Possibilities.at(iter).at(2))[5] ) / 3.0 ); maxGrp = iter; } } }</div>
<div class="line"><a name="l02239"></a><span class="lineno"> 2239</span>&#160;    </div>
<div class="line"><a name="l02240"></a><span class="lineno"> 2240</span>&#160;    <span class="keywordflow">if</span> ( C4Possibilities.at(maxGrp).size() == 3 )</div>
<div class="line"><a name="l02241"></a><span class="lineno"> 2241</span>&#160;    {</div>
<div class="line"><a name="l02242"></a><span class="lineno"> 2242</span>&#160;        <span class="comment">//============================================ Success! Save and exit</span></div>
<div class="line"><a name="l02243"></a><span class="lineno"> 2243</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign it = 0; it &lt; static_cast&lt;proshade_unsign&gt; ( C4Possibilities.at(maxGrp).size() ); it++ ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a> ( ret, CSymList-&gt;at(C4Possibilities.at(maxGrp).at(it)) ); }</div>
<div class="line"><a name="l02244"></a><span class="lineno"> 2244</span>&#160;        </div>
<div class="line"><a name="l02245"></a><span class="lineno"> 2245</span>&#160;        <span class="comment">//============================================ Report progress</span></div>
<div class="line"><a name="l02246"></a><span class="lineno"> 2246</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a6aa8cdb600cad623409802cfaed494fa">ProSHADE_internal_messages::printProgressMessage</a> ( verbose, 3, <span class="stringliteral">&quot;Detection of three C4 axes successfull.&quot;</span> );</div>
<div class="line"><a name="l02247"></a><span class="lineno"> 2247</span>&#160;        </div>
<div class="line"><a name="l02248"></a><span class="lineno"> 2248</span>&#160;        <span class="comment">//============================================ Done</span></div>
<div class="line"><a name="l02249"></a><span class="lineno"> 2249</span>&#160;        return ;</div>
<div class="line"><a name="l02250"></a><span class="lineno"> 2250</span>&#160;    }</div>
<div class="line"><a name="l02251"></a><span class="lineno"> 2251</span>&#160;    </div>
<div class="line"><a name="l02252"></a><span class="lineno"> 2252</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l02253"></a><span class="lineno"> 2253</span>&#160;    return ;</div>
<div class="line"><a name="l02254"></a><span class="lineno"> 2254</span>&#160;    </div>
<div class="line"><a name="l02255"></a><span class="lineno"> 2255</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae003234a38a3abfff24115ee51d99141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae003234a38a3abfff24115ee51d99141">&#9670;&nbsp;</a></span>findOcta4C3s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::findOcta4C3s </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes the list of C symmetries and finds the four C3 symmetries with correct angles required for full octahedral symmetry. </p>
<p>This function is specific to detecting the tetrahedral symmetry. It should be called once tetrahedral symmetry is suspected (by detecting its dihedral angles) and it needs to be fully described. This function specifically searches for the four C3 symmetries which must all be detected in order to fully describe octahedral symmetry. If all four are found, the ret vector will have these four axes added to the already present three C4 axes; alternatively, the ret array size will not change. In order not to replicate computations, if tetrahedral symmetry has already been detected, the four axes sought here are the same as the first four axes detected there, so simple copying is used instead of re-computing the results anew.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>The vector . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verobse</td><td>How loud the announcments should be? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum average peak height for axis to be considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TetraSymList</td><td>A vector containing the already detected tetrahedral symmetries - this is to avoid the same search for four C3 symmetry axes. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l02272">2272</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02273"></a><span class="lineno"> 2273</span>&#160;{</div>
<div class="line"><a name="l02274"></a><span class="lineno"> 2274</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l02275"></a><span class="lineno"> 2275</span>&#160;    std::vector&lt; proshade_unsign &gt; C4s, prospectiveC3s, C3PossibilitiesHlp;</div>
<div class="line"><a name="l02276"></a><span class="lineno"> 2276</span>&#160;    std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; C3Possibilities;</div>
<div class="line"><a name="l02277"></a><span class="lineno"> 2277</span>&#160;    proshade_double dotProd;</div>
<div class="line"><a name="l02278"></a><span class="lineno"> 2278</span>&#160;    <span class="keywordtype">bool</span> groupMatched;</div>
<div class="line"><a name="l02279"></a><span class="lineno"> 2279</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; 3; iter++ ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C4s, iter ); }</div>
<div class="line"><a name="l02280"></a><span class="lineno"> 2280</span>&#160;    </div>
<div class="line"><a name="l02281"></a><span class="lineno"> 2281</span>&#160;    <span class="comment">//================================================ Report progress</span></div>
<div class="line"><a name="l02282"></a><span class="lineno"> 2282</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a6aa8cdb600cad623409802cfaed494fa">ProSHADE_internal_messages::printProgressMessage</a>  ( verbose, 2, <span class="stringliteral">&quot;Starting detection of four C3 axes.&quot;</span> );</div>
<div class="line"><a name="l02283"></a><span class="lineno"> 2283</span>&#160;    </div>
<div class="line"><a name="l02284"></a><span class="lineno"> 2284</span>&#160;    <span class="comment">//================================================ For each C4</span></div>
<div class="line"><a name="l02285"></a><span class="lineno"> 2285</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign rIt = 0; rIt &lt; static_cast&lt;proshade_unsign&gt; ( ret-&gt;size() ); rIt++ )</div>
<div class="line"><a name="l02286"></a><span class="lineno"> 2286</span>&#160;    {</div>
<div class="line"><a name="l02287"></a><span class="lineno"> 2287</span>&#160;        <span class="comment">//============================================ For each C3, check it has angle ( acos( 1/sqrt(3) ) ) to the tested C4</span></div>
<div class="line"><a name="l02288"></a><span class="lineno"> 2288</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign cIt = 0; cIt &lt; static_cast&lt;proshade_unsign&gt; ( CSymList-&gt;size() ); cIt++ )</div>
<div class="line"><a name="l02289"></a><span class="lineno"> 2289</span>&#160;        {</div>
<div class="line"><a name="l02290"></a><span class="lineno"> 2290</span>&#160;            <span class="comment">//======================================== Search only using C3s</span></div>
<div class="line"><a name="l02291"></a><span class="lineno"> 2291</span>&#160;            <span class="keywordflow">if</span> ( CSymList-&gt;at(cIt)[0] != 3.0 || CSymList-&gt;at(cIt)[5] &lt; minPeakHeight ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l02292"></a><span class="lineno"> 2292</span>&#160;            </div>
<div class="line"><a name="l02293"></a><span class="lineno"> 2293</span>&#160;            <span class="comment">//======================================== Check the C3 axis to the C4 ( acos ( 1/sqrt(3) ) )</span></div>
<div class="line"><a name="l02294"></a><span class="lineno"> 2294</span>&#160;            dotProd = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> ( &amp;ret-&gt;at(rIt)[1], &amp;ret-&gt;at(rIt)[2], &amp;ret-&gt;at(rIt)[3], &amp;CSymList-&gt;at(cIt)[1], &amp;CSymList-&gt;at(cIt)[2], &amp;CSymList-&gt;at(cIt)[3] );</div>
<div class="line"><a name="l02295"></a><span class="lineno"> 2295</span>&#160;            </div>
<div class="line"><a name="l02296"></a><span class="lineno"> 2296</span>&#160;            <span class="keywordflow">if</span> ( ( std::abs ( dotProd ) &gt; ( ( 1.0 / sqrt(3.0) ) - axErr ) ) &amp;&amp; ( std::abs ( dotProd ) &lt; ( ( 1.0 / sqrt(3.0) ) + axErr ) ) ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;prospectiveC3s, cIt ); }</div>
<div class="line"><a name="l02297"></a><span class="lineno"> 2297</span>&#160;        }</div>
<div class="line"><a name="l02298"></a><span class="lineno"> 2298</span>&#160;    }</div>
<div class="line"><a name="l02299"></a><span class="lineno"> 2299</span>&#160;    </div>
<div class="line"><a name="l02300"></a><span class="lineno"> 2300</span>&#160;    <span class="comment">//================================================ Group the prospective C3s</span></div>
<div class="line"><a name="l02301"></a><span class="lineno"> 2301</span>&#160;    C3Possibilities.clear(); C3PossibilitiesHlp.clear();</div>
<div class="line"><a name="l02302"></a><span class="lineno"> 2302</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign cIt = 0; cIt &lt; static_cast&lt;proshade_unsign&gt; ( prospectiveC3s.size() ); cIt++ )</div>
<div class="line"><a name="l02303"></a><span class="lineno"> 2303</span>&#160;    {</div>
<div class="line"><a name="l02304"></a><span class="lineno"> 2304</span>&#160;        <span class="comment">//============================================ If second or more C3, check if it can be placed in any group with having acos (1/3) to all its members</span></div>
<div class="line"><a name="l02305"></a><span class="lineno"> 2305</span>&#160;        groupMatched                                  = <span class="keyword">false</span>;</div>
<div class="line"><a name="l02306"></a><span class="lineno"> 2306</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign gIt = 0; gIt &lt; static_cast&lt;proshade_unsign&gt; ( C3Possibilities.size() ); gIt++ )</div>
<div class="line"><a name="l02307"></a><span class="lineno"> 2307</span>&#160;        {</div>
<div class="line"><a name="l02308"></a><span class="lineno"> 2308</span>&#160;            <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad8c193e95c7069fafa78dccc1de1aaa4">ProSHADE_internal_symmetry::testGroupAgainstSymmetry</a> ( CSymList, &amp;C3Possibilities.at(gIt), CSymList-&gt;at(prospectiveC3s.at(cIt)), axErr, 1.0/3.0, <span class="keyword">true</span>, prospectiveC3s.at(cIt) ) ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C3Possibilities.at(gIt), prospectiveC3s.at(cIt) ); groupMatched = <span class="keyword">true</span>; <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l02309"></a><span class="lineno"> 2309</span>&#160;        }</div>
<div class="line"><a name="l02310"></a><span class="lineno"> 2310</span>&#160; </div>
<div class="line"><a name="l02311"></a><span class="lineno"> 2311</span>&#160;        <span class="comment">//============================================ If no group matched, create a new group</span></div>
<div class="line"><a name="l02312"></a><span class="lineno"> 2312</span>&#160;        <span class="keywordflow">if</span> ( !groupMatched ) { C3PossibilitiesHlp.clear(); <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C3PossibilitiesHlp, prospectiveC3s.at(cIt) ); <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a86e2bb172f766ab4a620df482d2fe481">ProSHADE_internal_misc::addToUnsignVectorVector</a> ( &amp;C3Possibilities, C3PossibilitiesHlp ); <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l02313"></a><span class="lineno"> 2313</span>&#160;    }</div>
<div class="line"><a name="l02314"></a><span class="lineno"> 2314</span>&#160; </div>
<div class="line"><a name="l02315"></a><span class="lineno"> 2315</span>&#160;    <span class="comment">//================================================ Find the best group or return empty</span></div>
<div class="line"><a name="l02316"></a><span class="lineno"> 2316</span>&#160;    <span class="keywordflow">while</span> ( C3Possibilities.size() != 0 )</div>
<div class="line"><a name="l02317"></a><span class="lineno"> 2317</span>&#160;    {</div>
<div class="line"><a name="l02318"></a><span class="lineno"> 2318</span>&#160;        <span class="comment">//============================================ Test for missing symmetry axes, if need be</span></div>
<div class="line"><a name="l02319"></a><span class="lineno"> 2319</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af6093da290ce7b73a33e8b55f2c83491">ProSHADE_internal_symmetry::findMissingAxes</a> ( &amp;C3Possibilities, CSymList, 4, axErr, 1.0/3.0, 3, dataObj, minPeakHeight );</div>
<div class="line"><a name="l02320"></a><span class="lineno"> 2320</span>&#160; </div>
<div class="line"><a name="l02321"></a><span class="lineno"> 2321</span>&#160;        <span class="comment">//============================================ Found four C3s?</span></div>
<div class="line"><a name="l02322"></a><span class="lineno"> 2322</span>&#160;        <span class="keywordflow">if</span> ( C3Possibilities.at(0).size() == 4 )</div>
<div class="line"><a name="l02323"></a><span class="lineno"> 2323</span>&#160;        {</div>
<div class="line"><a name="l02324"></a><span class="lineno"> 2324</span>&#160;            <span class="comment">//======================================== Success! Save and exit</span></div>
<div class="line"><a name="l02325"></a><span class="lineno"> 2325</span>&#160;            <span class="keywordflow">for</span> ( proshade_unsign it = 0; it &lt; 4; it++ ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a> ( ret, CSymList-&gt;at(C3Possibilities.at(0).at(it)) ); }</div>
<div class="line"><a name="l02326"></a><span class="lineno"> 2326</span>&#160; </div>
<div class="line"><a name="l02327"></a><span class="lineno"> 2327</span>&#160;            <span class="comment">//======================================== Report progress</span></div>
<div class="line"><a name="l02328"></a><span class="lineno"> 2328</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a6aa8cdb600cad623409802cfaed494fa">ProSHADE_internal_messages::printProgressMessage</a> ( verbose, 3, <span class="stringliteral">&quot;Detection of four C3 axes successfull.&quot;</span> );</div>
<div class="line"><a name="l02329"></a><span class="lineno"> 2329</span>&#160; </div>
<div class="line"><a name="l02330"></a><span class="lineno"> 2330</span>&#160;            <span class="comment">//======================================== Done</span></div>
<div class="line"><a name="l02331"></a><span class="lineno"> 2331</span>&#160;            return ;</div>
<div class="line"><a name="l02332"></a><span class="lineno"> 2332</span>&#160;        }</div>
<div class="line"><a name="l02333"></a><span class="lineno"> 2333</span>&#160;        <span class="keywordflow">else</span> { C3Possibilities.erase                  ( C3Possibilities.begin() ); }</div>
<div class="line"><a name="l02334"></a><span class="lineno"> 2334</span>&#160;    }</div>
<div class="line"><a name="l02335"></a><span class="lineno"> 2335</span>&#160; </div>
<div class="line"><a name="l02336"></a><span class="lineno"> 2336</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l02337"></a><span class="lineno"> 2337</span>&#160;    return ;</div>
<div class="line"><a name="l02338"></a><span class="lineno"> 2338</span>&#160;    </div>
<div class="line"><a name="l02339"></a><span class="lineno"> 2339</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae47108b33b0fed84b73fc2d9769d93d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47108b33b0fed84b73fc2d9769d93d1">&#9670;&nbsp;</a></span>findOcta6C2s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::findOcta6C2s </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes the list of C symmetries and finds the six C2 symmetries with correct angles required for full octahedral symmetry. </p>
<p>This function is specific to detecting the octahedral symmetry. It should be called once octahedral symmetry is suspected (by detecting its dihedral angles) and it needs to be fully described. This function specifically searches for the six C2 symmetries which must all be detected in order to fully describe octahedral symmetry. If all six are found, the ret vector will have these six axes added to the already present three C4 axes and the four C3 axes; alternatively, the ret array size will not change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>The vector containing the already detected axes to which newly detected axes (if any) will be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verobse</td><td>How loud the announcments should be? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum average peak height for axis to be considered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l02354">2354</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02355"></a><span class="lineno"> 2355</span>&#160;{</div>
<div class="line"><a name="l02356"></a><span class="lineno"> 2356</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l02357"></a><span class="lineno"> 2357</span>&#160;    std::vector&lt; proshade_unsign &gt; prospectiveC2s, retGrp;</div>
<div class="line"><a name="l02358"></a><span class="lineno"> 2358</span>&#160;    proshade_double dotProd;</div>
<div class="line"><a name="l02359"></a><span class="lineno"> 2359</span>&#160;    proshade_unsign noPerpendicular, noSqrtTwo;</div>
<div class="line"><a name="l02360"></a><span class="lineno"> 2360</span>&#160;    </div>
<div class="line"><a name="l02361"></a><span class="lineno"> 2361</span>&#160;    <span class="comment">//================================================ Report progress</span></div>
<div class="line"><a name="l02362"></a><span class="lineno"> 2362</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a6aa8cdb600cad623409802cfaed494fa">ProSHADE_internal_messages::printProgressMessage</a>  ( verbose, 2, <span class="stringliteral">&quot;Starting detection of six C2 axes.&quot;</span> );</div>
<div class="line"><a name="l02363"></a><span class="lineno"> 2363</span>&#160;    </div>
<div class="line"><a name="l02364"></a><span class="lineno"> 2364</span>&#160;    <span class="comment">//================================================ For each C2</span></div>
<div class="line"><a name="l02365"></a><span class="lineno"> 2365</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign cIt = 0; cIt &lt; static_cast&lt;proshade_unsign&gt; ( CSymList-&gt;size() ); cIt++ )</div>
<div class="line"><a name="l02366"></a><span class="lineno"> 2366</span>&#160;    {</div>
<div class="line"><a name="l02367"></a><span class="lineno"> 2367</span>&#160;        <span class="comment">//============================================ Use only C2s</span></div>
<div class="line"><a name="l02368"></a><span class="lineno"> 2368</span>&#160;        <span class="keywordflow">if</span> ( CSymList-&gt;at(cIt)[0] != 2.0 || CSymList-&gt;at(cIt)[5] &lt; minPeakHeight ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l02369"></a><span class="lineno"> 2369</span>&#160;        </div>
<div class="line"><a name="l02370"></a><span class="lineno"> 2370</span>&#160;        <span class="comment">//============================================ Check the C2 has acos ( 1/sqrt(2) ) to 2 C4s and acos ( 0.0 ) to the third C4</span></div>
<div class="line"><a name="l02371"></a><span class="lineno"> 2371</span>&#160;        noPerpendicular = 0; noSqrtTwo = 0;</div>
<div class="line"><a name="l02372"></a><span class="lineno"> 2372</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign rIt = 0; rIt &lt; 3; rIt++ )</div>
<div class="line"><a name="l02373"></a><span class="lineno"> 2373</span>&#160;        {</div>
<div class="line"><a name="l02374"></a><span class="lineno"> 2374</span>&#160;            dotProd                                   = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> ( &amp;ret-&gt;at(rIt)[1],</div>
<div class="line"><a name="l02375"></a><span class="lineno"> 2375</span>&#160;                                                                                                     &amp;ret-&gt;at(rIt)[2],</div>
<div class="line"><a name="l02376"></a><span class="lineno"> 2376</span>&#160;                                                                                                     &amp;ret-&gt;at(rIt)[3],</div>
<div class="line"><a name="l02377"></a><span class="lineno"> 2377</span>&#160;                                                                                                     &amp;CSymList-&gt;at(cIt)[1],</div>
<div class="line"><a name="l02378"></a><span class="lineno"> 2378</span>&#160;                                                                                                     &amp;CSymList-&gt;at(cIt)[2],</div>
<div class="line"><a name="l02379"></a><span class="lineno"> 2379</span>&#160;                                                                                                     &amp;CSymList-&gt;at(cIt)[3] );</div>
<div class="line"><a name="l02380"></a><span class="lineno"> 2380</span>&#160;            </div>
<div class="line"><a name="l02381"></a><span class="lineno"> 2381</span>&#160;            <span class="keywordflow">if</span> ( ( std::abs ( dotProd ) &gt; ( ( 1.0 / sqrt(2.0) ) - axErr ) ) &amp;&amp; ( std::abs ( dotProd ) &lt; ( ( 1.0 / sqrt(2.0) ) + axErr ) ) ) { noSqrtTwo       += 1; <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l02382"></a><span class="lineno"> 2382</span>&#160;            <span class="keywordflow">if</span> ( ( std::abs ( dotProd ) &gt; (   0.0               - axErr ) ) &amp;&amp; ( std::abs ( dotProd ) &lt; (   0.0               + axErr ) ) ) { noPerpendicular += 1; <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l02383"></a><span class="lineno"> 2383</span>&#160;        }</div>
<div class="line"><a name="l02384"></a><span class="lineno"> 2384</span>&#160;        </div>
<div class="line"><a name="l02385"></a><span class="lineno"> 2385</span>&#160;        <span class="comment">//============================================ If correct angles distribution is found, save the axis</span></div>
<div class="line"><a name="l02386"></a><span class="lineno"> 2386</span>&#160;        <span class="keywordflow">if</span> ( ( noSqrtTwo == 2 ) &amp;&amp; ( noPerpendicular == 1 ) )</div>
<div class="line"><a name="l02387"></a><span class="lineno"> 2387</span>&#160;        {</div>
<div class="line"><a name="l02388"></a><span class="lineno"> 2388</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;prospectiveC2s, cIt );</div>
<div class="line"><a name="l02389"></a><span class="lineno"> 2389</span>&#160;        }</div>
<div class="line"><a name="l02390"></a><span class="lineno"> 2390</span>&#160;    }</div>
<div class="line"><a name="l02391"></a><span class="lineno"> 2391</span>&#160;    </div>
<div class="line"><a name="l02392"></a><span class="lineno"> 2392</span>&#160;    <span class="comment">//================================================ Search for missing axes</span></div>
<div class="line"><a name="l02393"></a><span class="lineno"> 2393</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; 3; iter++ ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;retGrp, iter ); }</div>
<div class="line"><a name="l02394"></a><span class="lineno"> 2394</span>&#160;    <span class="keywordflow">if</span> ( !<a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a6d9f533a789bd5c6031fa77b9649ed3d">ProSHADE_internal_symmetry::findMissingAxesDual</a> ( &amp;prospectiveC2s, CSymList, ret, &amp;retGrp, 6, axErr, 1, 0.0, 2, 1/sqrt(2.0), 2, dataObj ) )</div>
<div class="line"><a name="l02395"></a><span class="lineno"> 2395</span>&#160;    {</div>
<div class="line"><a name="l02396"></a><span class="lineno"> 2396</span>&#160;        return ;</div>
<div class="line"><a name="l02397"></a><span class="lineno"> 2397</span>&#160;    }</div>
<div class="line"><a name="l02398"></a><span class="lineno"> 2398</span>&#160;    </div>
<div class="line"><a name="l02399"></a><span class="lineno"> 2399</span>&#160;    <span class="comment">//================================================ Found correct number of axes! Now save the</span></div>
<div class="line"><a name="l02400"></a><span class="lineno"> 2400</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; static_cast&lt;proshade_unsign&gt; ( prospectiveC2s.size() ); iter++ )</div>
<div class="line"><a name="l02401"></a><span class="lineno"> 2401</span>&#160;    {</div>
<div class="line"><a name="l02402"></a><span class="lineno"> 2402</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a>     ( ret, CSymList-&gt;at(prospectiveC2s.at(iter)) );</div>
<div class="line"><a name="l02403"></a><span class="lineno"> 2403</span>&#160;    }</div>
<div class="line"><a name="l02404"></a><span class="lineno"> 2404</span>&#160;    </div>
<div class="line"><a name="l02405"></a><span class="lineno"> 2405</span>&#160;    <span class="comment">//================================================ Report progress</span></div>
<div class="line"><a name="l02406"></a><span class="lineno"> 2406</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a6aa8cdb600cad623409802cfaed494fa">ProSHADE_internal_messages::printProgressMessage</a>  ( verbose, 3, <span class="stringliteral">&quot;Detection of six C2 axes successfull.&quot;</span> );</div>
<div class="line"><a name="l02407"></a><span class="lineno"> 2407</span>&#160;    </div>
<div class="line"><a name="l02408"></a><span class="lineno"> 2408</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l02409"></a><span class="lineno"> 2409</span>&#160;    return ;</div>
<div class="line"><a name="l02410"></a><span class="lineno"> 2410</span>&#160;    </div>
<div class="line"><a name="l02411"></a><span class="lineno"> 2411</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2137fa16a69fc7a8365439e322b67dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2137fa16a69fc7a8365439e322b67dc8">&#9670;&nbsp;</a></span>findPeaksByHeightBoundaries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; proshade_double &gt; ProSHADE_internal_symmetry::findPeaksByHeightBoundaries </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt;&#160;</td>
          <td class="paramname"><em>allPeaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>smoothing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function groups the peaks by height and returns the boundaries between such groups. </p>
<p>This function allows for a list of peaks to be divided into multiple groups based on the peak heights, so that only the most confident values would be used for symmetry detection first.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allPeaks</td><td>A vector of pointers where angle-axis representations of the peaks is saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">smoothing</td><td>Value determining how smooth the distribution of peaks should be made. Larger number means more groups. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>The boundaries for peak groups by height as determined by 1D grouping. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00310">310</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;{</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;    std::vector&lt; proshade_double &gt; boundaries;</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a>         ( &amp;boundaries, 0.0 );</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;    proshade_double peakContribution                  = 0.0;</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;    </div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;    <span class="comment">//================================================ Generate Probability Density function (PDF)</span></div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    std::vector&lt; proshade_double &gt; pdf;</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;    <span class="keywordflow">for</span> ( proshade_double iter = 0.0; iter &lt;= 1.0; iter += 0.01 )</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;    {</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;        <span class="comment">//============================================ Initialise point</span></div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;        peakContribution                              = 0.0;</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;        </div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;        <span class="comment">//============================================ Sum peak contributions</span></div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign it = 0; it &lt; static_cast&lt;proshade_unsign&gt; ( allPeaks.size() ); it++ )</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;        {</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;            peakContribution                         += <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a01087ea3e0db56758d1771618e2e4a45">ProSHADE_internal_maths::normalDistributionValue</a> ( allPeaks.at(it)[4], smoothing, iter );</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;        }</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;        </div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;        <span class="comment">//============================================ Save result</span></div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a>     ( &amp;pdf, peakContribution );</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;    }</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    </div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    <span class="comment">//================================================ Find boundaries</span></div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    proshade_double prev                              = pdf.at(0);</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 1; iter &lt; static_cast&lt;proshade_unsign&gt; ( pdf.size() - 1 ); iter ++ )</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;    {</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;        <span class="comment">//============================================ Check for local minima</span></div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;        <span class="keywordflow">if</span> ( ( prev &gt; pdf.at(iter) ) &amp;&amp; ( pdf.at(iter+1) &gt; pdf.at(iter) ) )</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;        {</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a> ( &amp;boundaries, iter * 0.01 );</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;        }</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;        </div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;        <span class="comment">//============================================ Prepare next iteration</span></div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;        prev                                          = pdf.at(iter);</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;    }</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160; </div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;    <span class="keywordflow">return</span>                                            ( boundaries );</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;    </div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a648ddad98891a4d8a6af5187d994c5ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648ddad98891a4d8a6af5187d994c5ec">&#9670;&nbsp;</a></span>findPeaksCSymmetry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; ProSHADE_internal_symmetry::findPeaksCSymmetry </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>peaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>band</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>missPeakThres</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axisErrTolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>axisErrToleranceDef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function searches the list of peaks for presence of cyclic symmetry. </p>
<p>This function takes a set of peaks and a bunch of settings parameters and proceeds to search these peaks for containing any Cyclic (C) symmetries. It contains all the functionality including missing peaks searching and automatic possible fold detection including allowing for errors. It will finally save all the results in the vector of vectors it returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">peaks</td><td>A vector of pointers where angle-axis representations of the peaks is saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>How loud the standard output of this run should be? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">band</td><td>The bandwidth of these computations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">missPeakThres</td><td>Threshold for the percentage of missing peaks there can be to warrant a full search for missing peaks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axisErrTolerance</td><td>Tolerance for symmetry axis identity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axisErrToleranceDef</td><td>Should the automatic axis tolerance decrease be applied? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataObj</td><td>The data object for which symmetry is being searched. This is only needed for missing peaks search, but needed nonetheless. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>Vector of vectors with first number being the detected fold and all remaining numbers being the indices of peaks forming the symmetry. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00368">368</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;{</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;    <span class="comment">//======================================== Initialise variables</span></div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;    std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; ret;</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;    std::vector&lt; proshade_double &gt; triedAlready;</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;    std::vector&lt; proshade_unsign &gt; angsToTry, testedAlready;</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;    proshade_double angDist, angDivisionRemainder, angDivisionBasis, nextSymmetryError, nextPeakError = ( M_PI * 2.0 ) / ( <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( band ) * 2.0 );</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;    </div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;    <span class="comment">//================================================ Sanity check</span></div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;    <span class="keywordflow">if</span> ( peaks-&gt;size() &lt; 1 ) { <span class="keywordflow">return</span> ( ret ); }</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    </div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;    <span class="comment">//================================================ Group peaks by axes</span></div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;    std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; sameAxesGroups = <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a98538547e5bcc6192bbbea1d7b51c537">ProSHADE_internal_symmetry::groupSameAxes</a> ( *peaks, axisErrTolerance );</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;    </div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;    <span class="comment">//================================================ For each axis group</span></div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign grpIt = 0; grpIt &lt; static_cast&lt;proshade_unsign&gt; ( sameAxesGroups.size() ); grpIt++ )</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;    {</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;        <span class="comment">//============================================ Print axis group if need be</span></div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af9835b91e354e4615beb79b5c2a674e9">ProSHADE_internal_symmetry::printSymmetryPeaks</a> ( sameAxesGroups.at(grpIt), *peaks, verbose, grpIt );</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160; </div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;        <span class="comment">//============================================ While there are distances between rotation angles in the group</span></div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;        triedAlready.clear                            ( );</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;        testedAlready.clear                           ( );</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;        <span class="keywordflow">while</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a2b3fcf4dd97e677da27192cf63dbb678">ProSHADE_internal_symmetry::smallestDistanceBetweenAngles</a> ( sameAxesGroups.at(grpIt), *peaks, &amp;triedAlready, &amp;angDist ) )</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;        {</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;            <span class="comment">//======================================== Check if testable fold value exists, otherwise test other distances</span></div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;            angsToTry.clear                           ( );</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;            <span class="keywordflow">if</span> ( !<a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ac0a8dc71c37de02256521ebc9178c8d4">ProSHADE_internal_symmetry::determineFoldToTry</a> ( angDist, &amp;angDivisionBasis, &amp;angDivisionRemainder, nextPeakError, &amp;nextSymmetryError, &amp;angsToTry ) ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;            </div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;            <span class="comment">//======================================== If reasonable folds are found, test these for being complete symmetries</span></div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ac03088b2929641cd6fc3e2e4e20d874b">ProSHADE_internal_symmetry::findSymmetryUsingFold</a> ( dataObj, &amp;angsToTry, &amp;sameAxesGroups.at(grpIt), peaks, &amp;ret, &amp;testedAlready, axisErrTolerance, axisErrToleranceDef, missPeakThres, verbose );</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;        }</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;        </div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;    }</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;    </div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;    <span class="keywordflow">return</span>                                            ( ret );</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;    </div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac03088b2929641cd6fc3e2e4e20d874b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac03088b2929641cd6fc3e2e4e20d874b">&#9670;&nbsp;</a></span>findSymmetryUsingFold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::findSymmetryUsingFold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>angsToTry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>peaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>testedAlready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErrTolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>axErrToleranceDefault</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>missPeakThres</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tests all supplied folds for being supported by the peaks (i.e. and being complete present symmetry). </p>
<p>This function takes all the possible folds which could be in the set of peaks and checks if these are indeed full symmetries, or whether these were random.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataObj</td><td>The data object for which symmetry is being searched. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angsToTry</td><td>This vector contains all the folds that should be attempted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>Vector with the indices of members of this symmetry axis group. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">peaks</td><td>A vector of pointers where angle-axis representations of the peaks is saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>The final variable holding all results (i.e. detected symmetries). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">testedAlready</td><td>A vector in which the already tested folds for this symmetry axis are saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErrTolerance</td><td>The allowed error on matching axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErrToleranceDefault</td><td>Should the axErrTolerance be decreased with increasing fold? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">missPeakThres</td><td>Threshold for the percentage of missing peaks there can be to warrant a full search for missing peaks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>How loud the standard output of this run should be? </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00989">989</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;{</div>
<div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;    <span class="keywordtype">bool</span> skipFold                                     = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;    std::vector&lt; proshade_unsign &gt; matchedPeaks, missingPeaks;</div>
<div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;    std::vector&lt; proshade_double &gt; expectedAngles;</div>
<div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;    proshade_double angTolerance                      = std::acos ( 1.0 - axErrTolerance );</div>
<div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;    </div>
<div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;    <span class="comment">//================================================ Testing folds for being supported by peaks</span></div>
<div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign fIt = 0; fIt &lt; static_cast&lt;proshade_unsign&gt; ( angsToTry-&gt;size() ); fIt++ )</div>
<div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;    {</div>
<div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;        <span class="comment">//============================================ Was this fold already found?</span></div>
<div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;        skipFold                                      = <span class="keyword">false</span>;</div>
<div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign ftIt = 0; ftIt &lt; static_cast&lt;proshade_unsign&gt; ( testedAlready-&gt;size() ); ftIt++ ) { <span class="keywordflow">if</span> ( testedAlready-&gt;at(ftIt) == angsToTry-&gt;at(fIt) ) { skipFold = <span class="keyword">true</span>; } }</div>
<div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;        <span class="keywordflow">if</span> ( skipFold ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;        <span class="keywordflow">else</span> { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a>( testedAlready, angsToTry-&gt;at(fIt) ); }</div>
<div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;        </div>
<div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;        <span class="comment">//============================================ Set axis tolerance based on fold (if required)</span></div>
<div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;        <span class="keywordflow">if</span> ( axErrToleranceDefault )</div>
<div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;        {</div>
<div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;            angTolerance                              = std::max ( std::min ( angTolerance, ( ( (M_PI * 2.0) / <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span> ( angsToTry-&gt;at(fIt) ) ) -</div>
<div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;                                                                                              ( (M_PI * 2.0) / <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span> ( angsToTry-&gt;at(fIt) + 1 ) ) ) * 2.0 ), 0.02 );</div>
<div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;            axErrTolerance                            = std::max ( 1.0 - std::cos ( angTolerance ), 0.0008 );</div>
<div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;        }</div>
<div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;        </div>
<div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;        <span class="comment">//============================================ Find expected peak rotation angles</span></div>
<div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;        expectedAngles.clear                          ( );</div>
<div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af4f982fc282e8fca11b6a85f2d2069a5">ProSHADE_internal_symmetry::findExpectedPeakRotations</a> ( angsToTry-&gt;at(fIt), &amp;expectedAngles );</div>
<div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;        </div>
<div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;        <span class="comment">//============================================ Compare group to expected angles</span></div>
<div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;        matchedPeaks.clear                            ( );</div>
<div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;        missingPeaks.clear                            ( );</div>
<div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;        proshade_unsign consecMatches                 = <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a074d9c1d40d7491ea9f9f9639744e18d">ProSHADE_internal_symmetry::checkExpectedAgainstFound</a> ( *grp, *peaks, &amp;expectedAngles,</div>
<div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;                                                                                                                &amp;matchedPeaks, &amp;missingPeaks, angTolerance );</div>
<div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;    </div>
<div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;        <span class="comment">//============================================ If enough consecutive matches, symmetry was found. Save it</span></div>
<div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;        <span class="keywordflow">if</span> ( consecMatches &gt;= angsToTry-&gt;at(fIt) )</div>
<div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;        {</div>
<div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5dda335a87d6c26edfd3cf2a29ff7f1f">ProSHADE_internal_symmetry::saveDetectedCSymmetry</a> ( angsToTry-&gt;at(fIt), &amp;matchedPeaks, ret, verbose );</div>
<div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;        }</div>
<div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;        {</div>
<div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;            <span class="keywordflow">if</span> ( ( <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( matchedPeaks.size() ) / <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( angsToTry-&gt;at(fIt) ) ) &gt;= ( 1.0 - missPeakThres ) )</div>
<div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;            {</div>
<div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;                <span class="comment">//==================================== Attempt completing the symmetry  using missing peaks</span></div>
<div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;                <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a3008592c3ce58393395e03dac26c3626">ProSHADE_internal_symmetry::completeMissingCSymmetry</a> ( dataObj, angsToTry-&gt;at(fIt), grp, peaks, &amp;missingPeaks,</div>
<div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;                                                                           &amp;expectedAngles, &amp;matchedPeaks, axErrTolerance, verbose ) )</div>
<div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;                {</div>
<div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;                    <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5dda335a87d6c26edfd3cf2a29ff7f1f">ProSHADE_internal_symmetry::saveDetectedCSymmetry</a> ( angsToTry-&gt;at(fIt), &amp;matchedPeaks, ret, verbose );</div>
<div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;                }</div>
<div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;            }</div>
<div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;            {</div>
<div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;                <span class="comment">//=================================== Symmetry not detected</span></div>
<div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;                <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;            }</div>
<div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;        }</div>
<div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;    }</div>
<div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;    </div>
<div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;    <span class="comment">//=============================================== Done</span></div>
<div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;    return ;</div>
<div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160; </div>
<div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a193b0307e5bfe47bec26d3867d6750c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193b0307e5bfe47bec26d3867d6750c1">&#9670;&nbsp;</a></span>findTetra3C2s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::findTetra3C2s </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes the list of C symmetries and finds the 3 C2 symmetries with correct angles required for full tetrahedral symmetry. </p>
<p>This is a specific helper function for detecting three C2 symmetries perpendicular to each other hand having a specific angle ( acos(0.5) ) to one of the already detected C3 symmetries of the sought after tetrahedral symmetry. It firstly finds all C2s and tests these for having the acos(0.5) angle to the already found C3s. From this list of passing C2s, it then tries to find three mutually perpendicular axes, including searching for missing axes. If no such axes are found, the ret array will still have 4 entries, while if they are found, the ret array will have these added to the total of 7 entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>The vector . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verobse</td><td>How loud the announcments should be? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum average peak height for axis to be considered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01966">1966</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01967"></a><span class="lineno"> 1967</span>&#160;{</div>
<div class="line"><a name="l01968"></a><span class="lineno"> 1968</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l01969"></a><span class="lineno"> 1969</span>&#160;    std::vector&lt; proshade_unsign &gt; C3s, prospectiveC2s, C2PossibilitiesHlp;</div>
<div class="line"><a name="l01970"></a><span class="lineno"> 1970</span>&#160;    std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; C2Possibilities;</div>
<div class="line"><a name="l01971"></a><span class="lineno"> 1971</span>&#160;    proshade_double dotProd;</div>
<div class="line"><a name="l01972"></a><span class="lineno"> 1972</span>&#160;    <span class="keywordtype">bool</span> groupMatched;</div>
<div class="line"><a name="l01973"></a><span class="lineno"> 1973</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; 4; iter++ ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C3s, iter ); }</div>
<div class="line"><a name="l01974"></a><span class="lineno"> 1974</span>&#160;    </div>
<div class="line"><a name="l01975"></a><span class="lineno"> 1975</span>&#160;    <span class="comment">//================================================ Report progress</span></div>
<div class="line"><a name="l01976"></a><span class="lineno"> 1976</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a6aa8cdb600cad623409802cfaed494fa">ProSHADE_internal_messages::printProgressMessage</a>  ( verbose, 2, <span class="stringliteral">&quot;Starting detection of three C2 axes.&quot;</span> );</div>
<div class="line"><a name="l01977"></a><span class="lineno"> 1977</span>&#160;    </div>
<div class="line"><a name="l01978"></a><span class="lineno"> 1978</span>&#160;    <span class="comment">//================================================ For each C3</span></div>
<div class="line"><a name="l01979"></a><span class="lineno"> 1979</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign rIt = 0; rIt &lt; static_cast&lt;proshade_unsign&gt; ( ret-&gt;size() ); rIt++ )</div>
<div class="line"><a name="l01980"></a><span class="lineno"> 1980</span>&#160;    {</div>
<div class="line"><a name="l01981"></a><span class="lineno"> 1981</span>&#160;        <span class="comment">//============================================ For each C2, check it has angle ( acos(0.5) ) to the tested C3</span></div>
<div class="line"><a name="l01982"></a><span class="lineno"> 1982</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign cIt = 0; cIt &lt; static_cast&lt;proshade_unsign&gt; ( CSymList-&gt;size() ); cIt++ )</div>
<div class="line"><a name="l01983"></a><span class="lineno"> 1983</span>&#160;        {</div>
<div class="line"><a name="l01984"></a><span class="lineno"> 1984</span>&#160;            <span class="comment">//======================================== Search only using C2s</span></div>
<div class="line"><a name="l01985"></a><span class="lineno"> 1985</span>&#160;            <span class="keywordflow">if</span> ( CSymList-&gt;at(cIt)[0] != 2.0 || CSymList-&gt;at(cIt)[5] &lt; minPeakHeight ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l01986"></a><span class="lineno"> 1986</span>&#160;            </div>
<div class="line"><a name="l01987"></a><span class="lineno"> 1987</span>&#160;            <span class="comment">//======================================== Check the C2 axis to the C3 ( acos ( 0.5 ) )</span></div>
<div class="line"><a name="l01988"></a><span class="lineno"> 1988</span>&#160;            dotProd = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> ( &amp;ret-&gt;at(rIt)[1], &amp;ret-&gt;at(rIt)[2], &amp;ret-&gt;at(rIt)[3],</div>
<div class="line"><a name="l01989"></a><span class="lineno"> 1989</span>&#160;                                                                   &amp;CSymList-&gt;at(cIt)[1], &amp;CSymList-&gt;at(cIt)[2], &amp;CSymList-&gt;at(cIt)[3] );</div>
<div class="line"><a name="l01990"></a><span class="lineno"> 1990</span>&#160;            </div>
<div class="line"><a name="l01991"></a><span class="lineno"> 1991</span>&#160;            <span class="keywordflow">if</span> ( ( std::abs ( dotProd ) &gt; ( 0.5 - axErr ) ) &amp;&amp; ( std::abs ( dotProd ) &lt; ( 0.5 + axErr ) ) ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;prospectiveC2s, cIt ); }</div>
<div class="line"><a name="l01992"></a><span class="lineno"> 1992</span>&#160;        }</div>
<div class="line"><a name="l01993"></a><span class="lineno"> 1993</span>&#160;    }</div>
<div class="line"><a name="l01994"></a><span class="lineno"> 1994</span>&#160;        </div>
<div class="line"><a name="l01995"></a><span class="lineno"> 1995</span>&#160;    <span class="comment">//================================================ Group the prospective C2s</span></div>
<div class="line"><a name="l01996"></a><span class="lineno"> 1996</span>&#160;    C2Possibilities.clear(); C2PossibilitiesHlp.clear();</div>
<div class="line"><a name="l01997"></a><span class="lineno"> 1997</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign cIt = 0; cIt &lt; static_cast&lt;proshade_unsign&gt; ( prospectiveC2s.size() ); cIt++ )</div>
<div class="line"><a name="l01998"></a><span class="lineno"> 1998</span>&#160;    {</div>
<div class="line"><a name="l01999"></a><span class="lineno"> 1999</span>&#160;        <span class="comment">//============================================ If second or more C2, check if it can be placed in any group with being perpendicular to all its members</span></div>
<div class="line"><a name="l02000"></a><span class="lineno"> 2000</span>&#160;        groupMatched                                  = <span class="keyword">false</span>;</div>
<div class="line"><a name="l02001"></a><span class="lineno"> 2001</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign gIt = 0; gIt &lt; static_cast&lt;proshade_unsign&gt; ( C2Possibilities.size() ); gIt++ )</div>
<div class="line"><a name="l02002"></a><span class="lineno"> 2002</span>&#160;        {</div>
<div class="line"><a name="l02003"></a><span class="lineno"> 2003</span>&#160;            <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad8c193e95c7069fafa78dccc1de1aaa4">ProSHADE_internal_symmetry::testGroupAgainstSymmetry</a> ( CSymList, &amp;C2Possibilities.at(gIt), CSymList-&gt;at(prospectiveC2s.at(cIt)), axErr, 0.0, <span class="keyword">true</span>, prospectiveC2s.at(cIt) ) ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C2Possibilities.at(gIt), prospectiveC2s.at(cIt) ); groupMatched = <span class="keyword">true</span>; <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l02004"></a><span class="lineno"> 2004</span>&#160;        }</div>
<div class="line"><a name="l02005"></a><span class="lineno"> 2005</span>&#160;        </div>
<div class="line"><a name="l02006"></a><span class="lineno"> 2006</span>&#160;        <span class="comment">//============================================ If no group matched, create a new group</span></div>
<div class="line"><a name="l02007"></a><span class="lineno"> 2007</span>&#160;        <span class="keywordflow">if</span> ( !groupMatched ) { C2PossibilitiesHlp.clear(); <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C2PossibilitiesHlp, prospectiveC2s.at(cIt) ); <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a86e2bb172f766ab4a620df482d2fe481">ProSHADE_internal_misc::addToUnsignVectorVector</a> ( &amp;C2Possibilities, C2PossibilitiesHlp ); <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l02008"></a><span class="lineno"> 2008</span>&#160;    }</div>
<div class="line"><a name="l02009"></a><span class="lineno"> 2009</span>&#160;    </div>
<div class="line"><a name="l02010"></a><span class="lineno"> 2010</span>&#160;    <span class="comment">//================================================ Find the best group or return empty</span></div>
<div class="line"><a name="l02011"></a><span class="lineno"> 2011</span>&#160;    <span class="keywordflow">while</span> ( C2Possibilities.size() != 0 )</div>
<div class="line"><a name="l02012"></a><span class="lineno"> 2012</span>&#160;    {</div>
<div class="line"><a name="l02013"></a><span class="lineno"> 2013</span>&#160;        <span class="comment">//============================================ Test for missing symmetry axes, if need be</span></div>
<div class="line"><a name="l02014"></a><span class="lineno"> 2014</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af6093da290ce7b73a33e8b55f2c83491">ProSHADE_internal_symmetry::findMissingAxes</a>   ( &amp;C2Possibilities, CSymList, 3, axErr, 0.0, 2, dataObj, minPeakHeight );</div>
<div class="line"><a name="l02015"></a><span class="lineno"> 2015</span>&#160;        </div>
<div class="line"><a name="l02016"></a><span class="lineno"> 2016</span>&#160;        <span class="comment">//============================================ Found 3 C2s?</span></div>
<div class="line"><a name="l02017"></a><span class="lineno"> 2017</span>&#160;        <span class="keywordflow">if</span> ( C2Possibilities.at(0).size() == 3 )</div>
<div class="line"><a name="l02018"></a><span class="lineno"> 2018</span>&#160;        {</div>
<div class="line"><a name="l02019"></a><span class="lineno"> 2019</span>&#160;            <span class="comment">//======================================== Success! Save and exit</span></div>
<div class="line"><a name="l02020"></a><span class="lineno"> 2020</span>&#160;            <span class="keywordflow">for</span> ( proshade_unsign it = 0; it &lt; 3; it++ ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a> ( ret, CSymList-&gt;at(C2Possibilities.at(0).at(it)) ); }</div>
<div class="line"><a name="l02021"></a><span class="lineno"> 2021</span>&#160;            </div>
<div class="line"><a name="l02022"></a><span class="lineno"> 2022</span>&#160;            <span class="comment">//======================================== Report progress</span></div>
<div class="line"><a name="l02023"></a><span class="lineno"> 2023</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a6aa8cdb600cad623409802cfaed494fa">ProSHADE_internal_messages::printProgressMessage</a> ( verbose, 3, <span class="stringliteral">&quot;Detection of three C2 axes successfull.&quot;</span> );</div>
<div class="line"><a name="l02024"></a><span class="lineno"> 2024</span>&#160;            </div>
<div class="line"><a name="l02025"></a><span class="lineno"> 2025</span>&#160;            <span class="comment">//======================================== Done</span></div>
<div class="line"><a name="l02026"></a><span class="lineno"> 2026</span>&#160;            return ;</div>
<div class="line"><a name="l02027"></a><span class="lineno"> 2027</span>&#160;        }</div>
<div class="line"><a name="l02028"></a><span class="lineno"> 2028</span>&#160;        <span class="keywordflow">else</span> { C2Possibilities.erase ( C2Possibilities.begin() ); }</div>
<div class="line"><a name="l02029"></a><span class="lineno"> 2029</span>&#160;    }</div>
<div class="line"><a name="l02030"></a><span class="lineno"> 2030</span>&#160;  </div>
<div class="line"><a name="l02031"></a><span class="lineno"> 2031</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l02032"></a><span class="lineno"> 2032</span>&#160;    return ;</div>
<div class="line"><a name="l02033"></a><span class="lineno"> 2033</span>&#160;    </div>
<div class="line"><a name="l02034"></a><span class="lineno"> 2034</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab702e9ca347642df5f49f937000b4184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab702e9ca347642df5f49f937000b4184">&#9670;&nbsp;</a></span>findTetra4C3s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::findTetra4C3s </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes the list of C symmetries and finds the 4 C3 symmetries with correct angles required for full tetrahedral symmetry. </p>
<p>This function is specific to detecting the tetrahedral symmetry. It should be called once tetrahedral symmetry is suspected (by detecting its dihedral angles) and it needs to be fully described. This function specifically searches for the four C3 symmetries which must all be detected in order to fully describe tetrahedral symmetry. If all four are found, the ret vector will contain these as its only four entries, while it will be empty if some of the C3 symmetries are not found. The missing symmetry axis detection is implemented as part of this function as well.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>The vector . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verobse</td><td>How loud the announcments should be? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum average peak height for axis to be considered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01445">1445</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01446"></a><span class="lineno"> 1446</span>&#160;{</div>
<div class="line"><a name="l01447"></a><span class="lineno"> 1447</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l01448"></a><span class="lineno"> 1448</span>&#160;    std::vector&lt; proshade_unsign &gt; C3PossibilitiesHlp;</div>
<div class="line"><a name="l01449"></a><span class="lineno"> 1449</span>&#160;    std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; C3Possibilities;</div>
<div class="line"><a name="l01450"></a><span class="lineno"> 1450</span>&#160;    <span class="keywordtype">bool</span> groupMatched;</div>
<div class="line"><a name="l01451"></a><span class="lineno"> 1451</span>&#160;    </div>
<div class="line"><a name="l01452"></a><span class="lineno"> 1452</span>&#160;    <span class="comment">//================================================ Report progress</span></div>
<div class="line"><a name="l01453"></a><span class="lineno"> 1453</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a6aa8cdb600cad623409802cfaed494fa">ProSHADE_internal_messages::printProgressMessage</a> ( verbose, 2, <span class="stringliteral">&quot;Starting detection of four C3 axes.&quot;</span> );</div>
<div class="line"><a name="l01454"></a><span class="lineno"> 1454</span>&#160;    </div>
<div class="line"><a name="l01455"></a><span class="lineno"> 1455</span>&#160;    <span class="comment">//================================================ For all symmetries in the C symmetries list</span></div>
<div class="line"><a name="l01456"></a><span class="lineno"> 1456</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign cIt = 0; cIt &lt; static_cast&lt;proshade_unsign&gt; ( CSymList-&gt;size() ); cIt++ )</div>
<div class="line"><a name="l01457"></a><span class="lineno"> 1457</span>&#160;    {</div>
<div class="line"><a name="l01458"></a><span class="lineno"> 1458</span>&#160;        <span class="comment">//============================================ Search only using C3s</span></div>
<div class="line"><a name="l01459"></a><span class="lineno"> 1459</span>&#160;        <span class="keywordflow">if</span> ( CSymList-&gt;at(cIt)[0] != 3.0 || CSymList-&gt;at(cIt)[0] &lt; minPeakHeight ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l01460"></a><span class="lineno"> 1460</span>&#160;        </div>
<div class="line"><a name="l01461"></a><span class="lineno"> 1461</span>&#160;        <span class="comment">//============================================ If this is the first C3, then just save it to the first group of the temporary holder</span></div>
<div class="line"><a name="l01462"></a><span class="lineno"> 1462</span>&#160;        <span class="keywordflow">if</span> ( C3Possibilities.size() == 0 ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C3PossibilitiesHlp, cIt ); <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a86e2bb172f766ab4a620df482d2fe481">ProSHADE_internal_misc::addToUnsignVectorVector</a> ( &amp;C3Possibilities, C3PossibilitiesHlp ); <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l01463"></a><span class="lineno"> 1463</span>&#160;        </div>
<div class="line"><a name="l01464"></a><span class="lineno"> 1464</span>&#160;        <span class="comment">//============================================ If second or more C3, check if it has the correct angle to all other already found C3s for each group</span></div>
<div class="line"><a name="l01465"></a><span class="lineno"> 1465</span>&#160;        groupMatched                                  = <span class="keyword">false</span>;</div>
<div class="line"><a name="l01466"></a><span class="lineno"> 1466</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign gIt = 0; gIt &lt; static_cast&lt;proshade_unsign&gt; ( C3Possibilities.size() ); gIt++ )</div>
<div class="line"><a name="l01467"></a><span class="lineno"> 1467</span>&#160;        {</div>
<div class="line"><a name="l01468"></a><span class="lineno"> 1468</span>&#160;            <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad8c193e95c7069fafa78dccc1de1aaa4">ProSHADE_internal_symmetry::testGroupAgainstSymmetry</a> ( CSymList, &amp;C3Possibilities.at(gIt), CSymList-&gt;at(cIt), axErr, 1.0/3.0, <span class="keyword">true</span>, cIt ) ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C3Possibilities.at(gIt), cIt ); groupMatched = <span class="keyword">true</span>; <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l01469"></a><span class="lineno"> 1469</span>&#160;        }</div>
<div class="line"><a name="l01470"></a><span class="lineno"> 1470</span>&#160;        </div>
<div class="line"><a name="l01471"></a><span class="lineno"> 1471</span>&#160;        <span class="comment">//============================================ If no group matched, create a new group</span></div>
<div class="line"><a name="l01472"></a><span class="lineno"> 1472</span>&#160;        <span class="keywordflow">if</span> ( !groupMatched ) { C3PossibilitiesHlp.clear(); <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C3PossibilitiesHlp, cIt ); <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a86e2bb172f766ab4a620df482d2fe481">ProSHADE_internal_misc::addToUnsignVectorVector</a> ( &amp;C3Possibilities, C3PossibilitiesHlp ); <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l01473"></a><span class="lineno"> 1473</span>&#160;    }</div>
<div class="line"><a name="l01474"></a><span class="lineno"> 1474</span>&#160;    </div>
<div class="line"><a name="l01475"></a><span class="lineno"> 1475</span>&#160;    <span class="comment">//================================================ Test for missing symmetry axes, if need be</span></div>
<div class="line"><a name="l01476"></a><span class="lineno"> 1476</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af6093da290ce7b73a33e8b55f2c83491">ProSHADE_internal_symmetry::findMissingAxes</a>       ( &amp;C3Possibilities, CSymList, 4, axErr, 1.0/3.0, 3, dataObj, minPeakHeight );</div>
<div class="line"><a name="l01477"></a><span class="lineno"> 1477</span>&#160;    </div>
<div class="line"><a name="l01478"></a><span class="lineno"> 1478</span>&#160;    <span class="comment">//================================================ Any group has 4 entries? If more such groups, take the one with highest average height.</span></div>
<div class="line"><a name="l01479"></a><span class="lineno"> 1479</span>&#160;    proshade_double maxHeight = 0.0; proshade_unsign maxGrp = 0;</div>
<div class="line"><a name="l01480"></a><span class="lineno"> 1480</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; static_cast&lt;proshade_unsign&gt; ( C3Possibilities.size() ); iter++ ) { <span class="keywordflow">if</span> ( C3Possibilities.at(iter).size() == 4 ) { <span class="keywordflow">if</span> ( ( ( CSymList-&gt;at(C3Possibilities.at(iter).at(0))[5] + CSymList-&gt;at(C3Possibilities.at(iter).at(1))[5] + CSymList-&gt;at(C3Possibilities.at(iter).at(2))[5] + CSymList-&gt;at(C3Possibilities.at(iter).at(3))[5] ) / 4.0 ) &gt; maxHeight ) { maxHeight = ( ( CSymList-&gt;at(C3Possibilities.at(iter).at(0))[5] + CSymList-&gt;at(C3Possibilities.at(iter).at(1))[5] + CSymList-&gt;at(C3Possibilities.at(iter).at(2))[5] + CSymList-&gt;at(C3Possibilities.at(iter).at(3))[5] ) / 4.0 ); maxGrp = iter; } } }</div>
<div class="line"><a name="l01481"></a><span class="lineno"> 1481</span>&#160;    </div>
<div class="line"><a name="l01482"></a><span class="lineno"> 1482</span>&#160;    <span class="keywordflow">if</span> ( C3Possibilities.at(maxGrp).size() == 4 )</div>
<div class="line"><a name="l01483"></a><span class="lineno"> 1483</span>&#160;    {</div>
<div class="line"><a name="l01484"></a><span class="lineno"> 1484</span>&#160;        <span class="comment">//============================================ Success! Save and exit</span></div>
<div class="line"><a name="l01485"></a><span class="lineno"> 1485</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign it = 0; it &lt; static_cast&lt;proshade_unsign&gt; ( C3Possibilities.at(maxGrp).size() ); it++ ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a> ( ret, CSymList-&gt;at(C3Possibilities.at(maxGrp).at(it)) ); }</div>
<div class="line"><a name="l01486"></a><span class="lineno"> 1486</span>&#160;        </div>
<div class="line"><a name="l01487"></a><span class="lineno"> 1487</span>&#160;        <span class="comment">//============================================ Report progress</span></div>
<div class="line"><a name="l01488"></a><span class="lineno"> 1488</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a6aa8cdb600cad623409802cfaed494fa">ProSHADE_internal_messages::printProgressMessage</a> ( verbose, 3, <span class="stringliteral">&quot;Detection of four C3 axes successfull.&quot;</span> );</div>
<div class="line"><a name="l01489"></a><span class="lineno"> 1489</span>&#160;        </div>
<div class="line"><a name="l01490"></a><span class="lineno"> 1490</span>&#160;        <span class="comment">//============================================ Done</span></div>
<div class="line"><a name="l01491"></a><span class="lineno"> 1491</span>&#160;        return ;</div>
<div class="line"><a name="l01492"></a><span class="lineno"> 1492</span>&#160;    }</div>
<div class="line"><a name="l01493"></a><span class="lineno"> 1493</span>&#160;    </div>
<div class="line"><a name="l01494"></a><span class="lineno"> 1494</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01495"></a><span class="lineno"> 1495</span>&#160;    return ;</div>
<div class="line"><a name="l01496"></a><span class="lineno"> 1496</span>&#160;    </div>
<div class="line"><a name="l01497"></a><span class="lineno"> 1497</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a66b286b7617c645b6543b28c1cd789af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b286b7617c645b6543b28c1cd789af">&#9670;&nbsp;</a></span>getPeaksAngleAxisPositions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; proshade_double * &gt; ProSHADE_internal_symmetry::getPeaksAngleAxisPositions </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt;&#160;</td>
          <td class="paramname"><em>allPeaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts peaks ZXZ Euler anles to angle-axis representation for further processing. </p>
<p>The only functionality here is taking a vector of Euler ZXZ angles and converting these though the rotation matrices to a vector of angle-axis representation of the same angles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allPeaks</td><td>A vector of pointers where Euler ZXZ representations of the peaks are saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>How loud the standard output of this run should be? </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>A vector of pointers where angle-axis representations of the peaks will be saved. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00256">256</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;{</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;    std::vector&lt; proshade_double* &gt; ret;</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;    proshade_double* hlpP                             = NULL;</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;    proshade_double* rotMat                           = <span class="keyword">new</span> proshade_double [9];</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( rotMat, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;    </div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;    <span class="comment">//================================================ For each peak</span></div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign peakIter = 0; peakIter &lt; static_cast&lt;proshade_unsign&gt; ( allPeaks.size() ); peakIter++ )</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;    {</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;        <span class="comment">//============================================ Convert Euler ZXZ angles to rotation matrix</span></div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#abd9fe573a48f499dd7d1df4f779222f1">ProSHADE_internal_maths::getRotationMatrixFromEulerZXZAngles</a> ( allPeaks.at(peakIter)[0], allPeaks.at(peakIter)[1], allPeaks.at(peakIter)[2], rotMat );</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;        </div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;        <span class="comment">//============================================ Allocate pointer to results</span></div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;        hlpP                                          = <span class="keyword">new</span> proshade_double [5];</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a> ( hlpP, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;        </div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;        <span class="comment">//============================================ Convert rotation matrix to Angle-axis reporesentation</span></div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#aafc6f1626c7463de53c9f4f6fa11db22">ProSHADE_internal_maths::getAxisAngleFromRotationMatrix</a> ( rotMat, &amp;hlpP[0], &amp;hlpP[1], &amp;hlpP[2], &amp;hlpP[3] );</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;        hlpP[4]                                       = allPeaks.at(peakIter)[3];</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;        </div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;        <span class="comment">//============================================ Save results</span></div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a>     ( &amp;ret, hlpP );</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;    }</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;    </div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;    <span class="comment">//================================================ Release memory</span></div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    <span class="keyword">delete</span>[] rotMat;</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;    </div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;    <span class="comment">//================================================ Report progress</span></div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;    std::stringstream hlpSSP;</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    hlpSSP &lt;&lt; <span class="stringliteral">&quot;Found &quot;</span> &lt;&lt; ret.size() &lt;&lt; <span class="stringliteral">&quot; possible peaks.&quot;</span>;</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a6aa8cdb600cad623409802cfaed494fa">ProSHADE_internal_messages::printProgressMessage</a>  ( verbose, 3, hlpSSP.str() );</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;    </div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;    <span class="comment">//================================================ Warning if no peaks!</span></div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;    <span class="keywordflow">if</span> ( ret.size() &lt; 1 )</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;    {</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#addbb90f2b4199441f60e241ac850daa2">ProSHADE_internal_messages::printWarningMessage</a> ( verbose, <span class="stringliteral">&quot;!!! ProSHADE WARNING !!! Failed to detect any symmetries. There are no reasonable peaks in the self-rotation map. If you believe there should be some symmetry, you can try decreasing the resolution or changing the peak IQR threshold.&quot;</span>, <span class="stringliteral">&quot;WS00029&quot;</span> );</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;    }</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;    </div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    <span class="keywordflow">return</span>                                            ( ret );</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;    </div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a41150b2f8995b2ac1f144143fc83b6ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41150b2f8995b2ac1f144143fc83b6ee">&#9670;&nbsp;</a></span>giveOppositeAxesSameDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::giveOppositeAxesSameDirection </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt;&#160;</td>
          <td class="paramname"><em>peaks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function modifiest the axes so that the highest vector element is always positive. </p>
<p>This function modifies the angle-axis representation of the peak positions so that the leargest dimmension of the rotation axis would be positive. This is important in order to make sure that the AA representations [0,0,1;3.14] and [0,0,-1;-3.14] are equal and not considered as completely different.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">peaks</td><td>A vector of pointers where angle-axis representations of the peaks is saved. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00491">491</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;{</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;    <span class="comment">//================================================ Apply to all peaks</span></div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign i = 0; i &lt; static_cast&lt;proshade_unsign&gt; ( peaks.size() ); i++ )</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;    {</div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;        <span class="keywordflow">if</span> ( ( ( std::max ( std::abs ( peaks.at(i)[0] ), std::max( std::abs ( peaks.at(i)[1] ), std::abs ( peaks.at(i)[2] ) ) ) == std::abs ( peaks.at(i)[0] ) ) &amp;&amp; ( peaks.at(i)[0] &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;             ( ( std::max ( std::abs ( peaks.at(i)[0] ), std::max( std::abs ( peaks.at(i)[1] ), std::abs ( peaks.at(i)[2] ) ) ) == std::abs ( peaks.at(i)[1] ) ) &amp;&amp; ( peaks.at(i)[1] &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;             ( ( std::max ( std::abs ( peaks.at(i)[0] ), std::max( std::abs ( peaks.at(i)[1] ), std::abs ( peaks.at(i)[2] ) ) ) == std::abs ( peaks.at(i)[2] ) ) &amp;&amp; ( peaks.at(i)[2] &lt; 0.0 ) ) )</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;        {</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;            peaks.at(i)[0]                           *= -1.0;</div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;            peaks.at(i)[1]                           *= -1.0;</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;            peaks.at(i)[2]                           *= -1.0;</div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;            peaks.at(i)[3]                           *= -1.0;</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;        }</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;    }</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;    </div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;    return ;</div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;    </div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a98538547e5bcc6192bbbea1d7b51c537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98538547e5bcc6192bbbea1d7b51c537">&#9670;&nbsp;</a></span>groupSameAxes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; ProSHADE_internal_symmetry::groupSameAxes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; &amp;&#160;</td>
          <td class="paramname"><em>peaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>errTolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function groups the peaks by their axes of rotation. </p>
<p>This function takes the list of peaks so far detected and groups these by their axis or rotation, ignoring peaks with zero rotation angle. The return value is a vector of vectors of the groups and their members, but not re-organised list of peaks. This function also adds a zero angle peak to all peak groups (so that the zero angle peak has the same axis as all other group members for all groups).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">peaks</td><td>A vector of pointers where angle-axis representations of the peaks is saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">errTolerance</td><td>A value within which two axes are considered equal. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>A vector of peak groups with each group entry being a vector of groups member indices in the peaks vector. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00419">419</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;{</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;    std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; ret;</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;    <span class="keywordtype">bool</span> sameAxisFound                                = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;    proshade_double angTolerance                      = std::acos ( 1.0 - errTolerance );</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160; </div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;    <span class="comment">//================================================ Set all largest axis value to positive (this will make the 0,0,1 and 0,0,-1 axes the same)</span></div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a41150b2f8995b2ac1f144143fc83b6ee">ProSHADE_internal_symmetry::giveOppositeAxesSameDirection</a> ( peaks );</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;    </div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;    <span class="comment">//================================================ For each axis</span></div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign peakIter = 0; peakIter &lt; static_cast&lt;proshade_unsign&gt; ( peaks.size() ); peakIter++ )</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;    {</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;        <span class="comment">//============================================ Initialise variables for next peak</span></div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;        sameAxisFound                                 = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;        </div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;        <span class="comment">//============================================ Ignore zero angle peaks</span></div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;        <span class="keywordflow">if</span> ( ( peaks.at(peakIter)[3] - angTolerance &lt;= 0.0 ) &amp;&amp; ( peaks.at(peakIter)[3] + angTolerance &gt; 0.0 ) ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;        </div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;        <span class="comment">//============================================ Ignore very small axis peaks - the axis may be wrong here.</span></div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;        <span class="comment">// !! The value of 0.1 is hardcoded, but arbitrary</span></div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;        <span class="keywordflow">if</span> ( ( ( peaks.at(peakIter)[0] - 0.1 &lt;= 0.0 ) &amp;&amp; ( peaks.at(peakIter)[0] + 0.1 &gt; 0.0 ) ) &amp;&amp;</div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;             ( ( peaks.at(peakIter)[1] - 0.1 &lt;= 0.0 ) &amp;&amp; ( peaks.at(peakIter)[1] + 0.1 &gt; 0.0 ) ) &amp;&amp;</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;             ( ( peaks.at(peakIter)[2] - 0.1 &lt;= 0.0 ) &amp;&amp; ( peaks.at(peakIter)[2] + 0.1 &gt; 0.0 ) ) ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;        </div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;        <span class="comment">//============================================ Compare to all already detected axes groups</span></div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign sameAxisGrp = 0; sameAxisGrp &lt; static_cast&lt;proshade_unsign&gt; ( ret.size() ); sameAxisGrp++ )</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;        {</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;            <span class="comment">//======================================== and all their members</span></div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;            <span class="keywordflow">for</span> ( proshade_unsign sameAxis = 0; sameAxis &lt; static_cast&lt;proshade_unsign&gt; ( ret.at(sameAxisGrp).size() ); sameAxis++ )</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;            {</div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;                <span class="comment">//==================================== Is this identical axis to the tested one?</span></div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;                <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2b2f67cba1eea57f19fdaf062db74fde">ProSHADE_internal_maths::vectorOrientationSimilarity</a> ( peaks.at(ret.at(sameAxisGrp).at(sameAxis))[0],</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;                                                                            peaks.at(ret.at(sameAxisGrp).at(sameAxis))[1],</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;                                                                            peaks.at(ret.at(sameAxisGrp).at(sameAxis))[2],</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;                                                                            peaks.at(peakIter)[0],</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;                                                                            peaks.at(peakIter)[1],</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;                                                                            peaks.at(peakIter)[2],</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;                                                                            errTolerance ) )</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;                {</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;                    sameAxisFound                     = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;                    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;ret.at(sameAxisGrp), peakIter );</div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;                    <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;                }</div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;            }</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;        }</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;        </div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;        <span class="comment">//============================================ If same axis was found, do nothing</span></div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;        <span class="keywordflow">if</span> ( sameAxisFound ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;        </div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;        <span class="comment">//============================================ No similar axis was found</span></div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;        std::vector&lt;proshade_unsign&gt; hlpVec;</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a>     ( &amp;hlpVec, peakIter );</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a86e2bb172f766ab4a620df482d2fe481">ProSHADE_internal_misc::addToUnsignVectorVector</a> ( &amp;ret, hlpVec );</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;    }</div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;    </div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;    <span class="comment">//================================================ Add zero peak to all axes</span></div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ade9b717260e86c8f24bcbe6d17fe4e06">ProSHADE_internal_symmetry::addZeroPeakToGroups</a>   ( ret, peaks );</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;    </div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;    <span class="keywordflow">return</span>                                            ( ret );</div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;    </div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="abb4d85e82d1c55d0aa18795fea449adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb4d85e82d1c55d0aa18795fea449adf">&#9670;&nbsp;</a></span>isSymmetrySame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_symmetry::isSymmetrySame </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>simThres</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if a very similar symmetry is not already saved. </p>
<p>This is a simple function comparing a single double array of 6 to a vector of these, returning whether the vector already contains a very similar entry to the rested one. If the new has better height, replacement will take place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>This is the variable where the tested array will be saved if passed. It is a vector of double[6] arrays with the following meaning: [0] = fold, [1] = x-axis, [2] = y-axis, [3] = z-axis, [4] = angle, [5] = average peak height. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sym</td><td>This is a double array of 6 which is to be compared to all the vector entries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">simThres</td><td>The threshold for dot product comparison similarity. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>Boolean value stating whether a similar entry has been found (true = it was, false = it was not). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01177">1177</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;{</div>
<div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;    proshade_double dotProduct                        = 0.0;</div>
<div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;    </div>
<div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;    <span class="comment">//================================================ Check</span></div>
<div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign symIt = 0; symIt &lt; static_cast&lt;proshade_unsign&gt; ( ret-&gt;size() ); symIt++ )</div>
<div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;    {</div>
<div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;        <span class="comment">//============================================ Minor speed-up =&gt; only test for same folds</span></div>
<div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;        <span class="keywordflow">if</span> ( ret-&gt;at(symIt)[0] == sym[0] )</div>
<div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;        {</div>
<div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;            <span class="comment">//======================================== Is axis the same?</span></div>
<div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;            dotProduct                                = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> ( &amp;ret-&gt;at(symIt)[1], &amp;ret-&gt;at(symIt)[2],</div>
<div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;                                                                                                     &amp;ret-&gt;at(symIt)[3], &amp;sym[1], &amp;sym[2], &amp;sym[3] );</div>
<div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;            <span class="keywordflow">if</span> ( ( ( 1.0 &gt; ( dotProduct - simThres ) ) &amp;&amp; ( 1.0 &lt; ( dotProduct + simThres ) ) ) || ( ( -1.0 &gt; ( dotProduct - simThres ) ) &amp;&amp; ( -1.0 &lt; ( dotProduct + simThres ) ) ) )</div>
<div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;            {</div>
<div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;                <span class="comment">//==================================== Does the already saved have higher height?</span></div>
<div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;                <span class="keywordflow">if</span> ( ret-&gt;at(symIt)[5] &gt;= sym[5] ) { <span class="keywordflow">return</span> ( <span class="keyword">true</span> ); }</div>
<div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;                </div>
<div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;                <span class="comment">//==================================== In this case, new is better than old - sort it out</span></div>
<div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;                ret-&gt;at(symIt)[1]                     = sym[1];</div>
<div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;                ret-&gt;at(symIt)[2]                     = sym[2];</div>
<div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;                ret-&gt;at(symIt)[3]                     = sym[3];</div>
<div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;                ret-&gt;at(symIt)[5]                     = sym[5];</div>
<div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;                <span class="keywordflow">return</span>                                ( <span class="keyword">true</span> );</div>
<div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;            }</div>
<div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;        }</div>
<div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;    }</div>
<div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;    </div>
<div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;    <span class="comment">//================================================ Done - no matches found</span></div>
<div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;    <span class="keywordflow">return</span>                                            ( <span class="keyword">false</span> );</div>
<div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;    </div>
<div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad44ed609e8a3d59674b2b2256aec41f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad44ed609e8a3d59674b2b2256aec41f8">&#9670;&nbsp;</a></span>missingAxisHeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">proshade_double ProSHADE_internal_symmetry::missingAxisHeight </td>
          <td>(</td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>xVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>yVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>zVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function searches for the highest peaks average that would produce the required axis and fold. </p>
<p>This function starts by finding all self-rotation map points with corresponding axis and recording the angle and map heights of these points. It then sorts these and searches for a combination of fold points separated by the 2pi/fold distance with the highest average map height. In this way, the highest average symmetry height is determined for any axis. This does not, however, check if such symmetry does indeed exist!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xVal</td><td>The x-axis element of the axis to have the height detected. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yVal</td><td>The y-axis element of the axis to have the height detected. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zVal</td><td>The z-axis element of the axis to have the height detected. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataObj</td><td>The full data holding object pointer - this is to get access to self-rotation function values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fold</td><td>The fold of the searched for axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>The highest height value found for the axis with the given fold. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01663">1663</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01664"></a><span class="lineno"> 1664</span>&#160;{</div>
<div class="line"><a name="l01665"></a><span class="lineno"> 1665</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l01666"></a><span class="lineno"> 1666</span>&#160;    proshade_double ret                               = 0.0;</div>
<div class="line"><a name="l01667"></a><span class="lineno"> 1667</span>&#160;    proshade_double curSum                            = 0.0;</div>
<div class="line"><a name="l01668"></a><span class="lineno"> 1668</span>&#160;    proshade_double maxVal                            = 0.0;</div>
<div class="line"><a name="l01669"></a><span class="lineno"> 1669</span>&#160;    proshade_double angStep                           = std::acos ( 1.0 - axErr ) / 2;</div>
<div class="line"><a name="l01670"></a><span class="lineno"> 1670</span>&#160;    std::vector&lt; proshade_double* &gt; angVec;</div>
<div class="line"><a name="l01671"></a><span class="lineno"> 1671</span>&#160;    </div>
<div class="line"><a name="l01672"></a><span class="lineno"> 1672</span>&#160;    <span class="comment">//================================================ Find map points conforming to the axis</span></div>
<div class="line"><a name="l01673"></a><span class="lineno"> 1673</span>&#160;    angVec                                            = <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a465606e58df7d6a2238d40c6919b2e58">ProSHADE_internal_symmetry::findMissingAxisPoints</a> ( xVal, yVal, zVal, dataObj, axErr );</div>
<div class="line"><a name="l01674"></a><span class="lineno"> 1674</span>&#160;    </div>
<div class="line"><a name="l01675"></a><span class="lineno"> 1675</span>&#160;    <span class="comment">//================================================ Sort points by angle</span></div>
<div class="line"><a name="l01676"></a><span class="lineno"> 1676</span>&#160;    std::sort                                         ( angVec.begin(), angVec.end(), <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a68d576f90449b7d3fcf5ae4d3114c268">ProSHADE_internal_symmetry::sortArrVecHlp</a> );</div>
<div class="line"><a name="l01677"></a><span class="lineno"> 1677</span>&#160;    </div>
<div class="line"><a name="l01678"></a><span class="lineno"> 1678</span>&#160;    <span class="comment">//================================================ Find the best X peaks with correct distances</span></div>
<div class="line"><a name="l01679"></a><span class="lineno"> 1679</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; static_cast&lt;proshade_unsign&gt; ( std::floor ( ( 2.0 * M_PI / angStep ) / fold ) ); iter++ )</div>
<div class="line"><a name="l01680"></a><span class="lineno"> 1680</span>&#160;    {</div>
<div class="line"><a name="l01681"></a><span class="lineno"> 1681</span>&#160;        <span class="comment">//============================================ Initialise new ang group iteration</span></div>
<div class="line"><a name="l01682"></a><span class="lineno"> 1682</span>&#160;        curSum                                        = 0.0;</div>
<div class="line"><a name="l01683"></a><span class="lineno"> 1683</span>&#160;        </div>
<div class="line"><a name="l01684"></a><span class="lineno"> 1684</span>&#160;        <span class="comment">//============================================ For each of the fold times</span></div>
<div class="line"><a name="l01685"></a><span class="lineno"> 1685</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign angCmb = 0; angCmb &lt; static_cast&lt;proshade_unsign&gt; ( fold ); angCmb++ )</div>
<div class="line"><a name="l01686"></a><span class="lineno"> 1686</span>&#160;        {</div>
<div class="line"><a name="l01687"></a><span class="lineno"> 1687</span>&#160;            <span class="comment">//======================================== Initialise</span></div>
<div class="line"><a name="l01688"></a><span class="lineno"> 1688</span>&#160;            maxVal                                    = 0.0;</div>
<div class="line"><a name="l01689"></a><span class="lineno"> 1689</span>&#160;            </div>
<div class="line"><a name="l01690"></a><span class="lineno"> 1690</span>&#160;            <span class="comment">//======================================== Search</span></div>
<div class="line"><a name="l01691"></a><span class="lineno"> 1691</span>&#160;            <span class="keywordflow">for</span> ( proshade_unsign angIt = 0; angIt &lt; static_cast&lt;proshade_unsign&gt; ( angVec.size() ); angIt++ )</div>
<div class="line"><a name="l01692"></a><span class="lineno"> 1692</span>&#160;            {</div>
<div class="line"><a name="l01693"></a><span class="lineno"> 1693</span>&#160;                <span class="keywordflow">if</span> ( angVec.at(angIt)[0] &lt; ( ( iter*angStep )     + ( ( 2.0 * M_PI / fold ) * angCmb ) ) ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l01694"></a><span class="lineno"> 1694</span>&#160;                <span class="keywordflow">if</span> ( angVec.at(angIt)[0] &gt; ( ( (iter+1)*angStep ) + ( ( 2.0 * M_PI / fold ) * angCmb ) ) ) { <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l01695"></a><span class="lineno"> 1695</span>&#160; </div>
<div class="line"><a name="l01696"></a><span class="lineno"> 1696</span>&#160;                <span class="keywordflow">if</span> ( angVec.at(angIt)[1] &gt; maxVal ) { maxVal = angVec.at(angIt)[1]; }</div>
<div class="line"><a name="l01697"></a><span class="lineno"> 1697</span>&#160;            }</div>
<div class="line"><a name="l01698"></a><span class="lineno"> 1698</span>&#160;            curSum                                   += maxVal;</div>
<div class="line"><a name="l01699"></a><span class="lineno"> 1699</span>&#160;        }</div>
<div class="line"><a name="l01700"></a><span class="lineno"> 1700</span>&#160;        curSum                                      /= <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( fold );</div>
<div class="line"><a name="l01701"></a><span class="lineno"> 1701</span>&#160;        <span class="keywordflow">if</span> ( ret &lt; curSum ) { ret = curSum; }</div>
<div class="line"><a name="l01702"></a><span class="lineno"> 1702</span>&#160;    }</div>
<div class="line"><a name="l01703"></a><span class="lineno"> 1703</span>&#160;    </div>
<div class="line"><a name="l01704"></a><span class="lineno"> 1704</span>&#160;    <span class="comment">//================================================ Release memory</span></div>
<div class="line"><a name="l01705"></a><span class="lineno"> 1705</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; static_cast&lt;proshade_unsign&gt; ( angVec.size() ); iter++ ) { <span class="keyword">delete</span>[] angVec.at(iter); }</div>
<div class="line"><a name="l01706"></a><span class="lineno"> 1706</span>&#160;    </div>
<div class="line"><a name="l01707"></a><span class="lineno"> 1707</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01708"></a><span class="lineno"> 1708</span>&#160;    <span class="keywordflow">return</span>                                            ( ret );</div>
<div class="line"><a name="l01709"></a><span class="lineno"> 1709</span>&#160;    </div>
<div class="line"><a name="l01710"></a><span class="lineno"> 1710</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad5fcf9bf5ad27ac119d76312b4bcf90b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fcf9bf5ad27ac119d76312b4bcf90b">&#9670;&nbsp;</a></span>predictIcosAxes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::predictIcosAxes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__settings.html">ProSHADE_settings</a> *&#160;</td>
          <td class="paramname"><em>settings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>matrixTolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function predicts all icosahedral point group symmetry axes from the cyclic point groups list. </p>
<p>This function starts with finding the best detected cyclic symmetries of the right folds and having the closest angle to the icosahedron dihedral angle. It then proceeds to generate all the point group elements and their combinations. From these it then computes some of the missing axes and their associated angles. These steps can then be repeated until no more new elements are found (a group exists) or the process fails. The the detected axes (as obtained back from the point group elements) are then returned without checking for having the correct number of them.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function assumes that the <a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a4f09b90de1f15b345ee7998ff31327f3" title="This function takes the list of C symmetries and decides whether basic requirements for isosahedral s...">detectIcosahedralSymmetry()</a> function has successfully run (i.e. returned true).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>The vector . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum average peak height for axis to be considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verobse</td><td>How loud the announcments should be? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axisTolerance</td><td>The tolerance for two axes to be considered similar in terms of cosine distance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrixTolerance</td><td>The maximum allowed rotation matrix trace difference allowed for the matrices to be considered the same. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l02944">2944</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02945"></a><span class="lineno"> 2945</span>&#160;{</div>
<div class="line"><a name="l02946"></a><span class="lineno"> 2946</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l02947"></a><span class="lineno"> 2947</span>&#160;    std::vector&lt; proshade_double* &gt; newAxes;</div>
<div class="line"><a name="l02948"></a><span class="lineno"> 2948</span>&#160;    proshade_double axX, axY, axZ, axAng, foldTolerance = 0.1; <span class="comment">// dotProd</span></div>
<div class="line"><a name="l02949"></a><span class="lineno"> 2949</span>&#160;    proshade_unsign determinedFold, prevComboSize = 0; <span class="comment">// bestC5, bestC3</span></div>
<div class="line"><a name="l02950"></a><span class="lineno"> 2950</span>&#160;    std::vector&lt; proshade_unsign &gt; c5s, c3s, c2s;</div>
<div class="line"><a name="l02951"></a><span class="lineno"> 2951</span>&#160;<span class="comment">//    bool anglesPassed;</span></div>
<div class="line"><a name="l02952"></a><span class="lineno"> 2952</span>&#160;    </div>
<div class="line"><a name="l02953"></a><span class="lineno"> 2953</span>&#160;    <span class="comment">//================================================ Find the best axis combination with dihedral angle and correct folds</span></div>
<div class="line"><a name="l02954"></a><span class="lineno"> 2954</span>&#160;    std::pair&lt; proshade_unsign, proshade_unsign &gt; initAxes = <a class="code" href="_pro_s_h_a_d_e__symmetry_8cpp.html#a79ed59214fd3ab2bee9021cf1c7f3431">findBestIcosDihedralPair</a> ( CSymList, minPeakHeight, axErr );</div>
<div class="line"><a name="l02955"></a><span class="lineno"> 2955</span>&#160;    dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#aec8b3ae9e7ccaeaa8abeda92571a1d50">optimiseDihedralAngleFromAngleAxis</a> ( settings, - sqrt ( 5.0 ) / 3.0, CSymList-&gt;at(initAxes.first), CSymList-&gt;at(initAxes.second) );</div>
<div class="line"><a name="l02956"></a><span class="lineno"> 2956</span>&#160;    </div>
<div class="line"><a name="l02957"></a><span class="lineno"> 2957</span>&#160;    <span class="comment">//================================================ Save detected axes to ret</span></div>
<div class="line"><a name="l02958"></a><span class="lineno"> 2958</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aff0d8344fdd83482e5531eadedaac550">ProSHADE_internal_misc::deepCopyAxisToDblPtrVector</a> ( ret, CSymList-&gt;at(initAxes.first) );</div>
<div class="line"><a name="l02959"></a><span class="lineno"> 2959</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aff0d8344fdd83482e5531eadedaac550">ProSHADE_internal_misc::deepCopyAxisToDblPtrVector</a> ( ret, CSymList-&gt;at(initAxes.second) );</div>
<div class="line"><a name="l02960"></a><span class="lineno"> 2960</span>&#160; </div>
<div class="line"><a name="l02961"></a><span class="lineno"> 2961</span>&#160;    <span class="comment">//================================================ Generate initial group elements</span></div>
<div class="line"><a name="l02962"></a><span class="lineno"> 2962</span>&#160;    std::vector&lt;std::vector&lt; proshade_double &gt; &gt; elsC5 = dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a4f4bb25b05f273a41bce8205f9058717">computeGroupElementsForGroup</a> ( CSymList, initAxes.first );</div>
<div class="line"><a name="l02963"></a><span class="lineno"> 2963</span>&#160;    std::vector&lt;std::vector&lt; proshade_double &gt; &gt; elsC3 = dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a4f4bb25b05f273a41bce8205f9058717">computeGroupElementsForGroup</a> ( CSymList, initAxes.second );</div>
<div class="line"><a name="l02964"></a><span class="lineno"> 2964</span>&#160;    std::vector&lt;std::vector&lt; proshade_double &gt; &gt; combo = <a class="code" href="namespace_pro_s_h_a_d_e__internal__data.html#ac2cdde3bc58869b04f1aa39aee9b01bc">ProSHADE_internal_data::joinElementsFromDifferentGroups</a> ( &amp;elsC5, &amp;elsC3, matrixTolerance, <span class="keyword">true</span> );</div>
<div class="line"><a name="l02965"></a><span class="lineno"> 2965</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot; !@!@ Allowed axis error: &quot;</span> &lt;&lt; axErr &lt;&lt; std::endl;</div>
<div class="line"><a name="l02966"></a><span class="lineno"> 2966</span>&#160;    <span class="comment">//================================================ Iteratively find all remanining axes by multiplying the group elements</span></div>
<div class="line"><a name="l02967"></a><span class="lineno"> 2967</span>&#160;    <span class="keywordflow">while</span> ( prevComboSize &lt; combo.size() )</div>
<div class="line"><a name="l02968"></a><span class="lineno"> 2968</span>&#160;    {</div>
<div class="line"><a name="l02969"></a><span class="lineno"> 2969</span>&#160;        <span class="comment">//============================================ Sanity check</span></div>
<div class="line"><a name="l02970"></a><span class="lineno"> 2970</span>&#160;        <span class="keywordflow">if</span> ( prevComboSize &gt; 60 ) { <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l02971"></a><span class="lineno"> 2971</span>&#160;        </div>
<div class="line"><a name="l02972"></a><span class="lineno"> 2972</span>&#160;        <span class="comment">//============================================ Initialise iteration</span></div>
<div class="line"><a name="l02973"></a><span class="lineno"> 2973</span>&#160;        prevComboSize                                 = combo.size ( );</div>
<div class="line"><a name="l02974"></a><span class="lineno"> 2974</span>&#160;        newAxes.clear                                 ( );</div>
<div class="line"><a name="l02975"></a><span class="lineno"> 2975</span>&#160;        </div>
<div class="line"><a name="l02976"></a><span class="lineno"> 2976</span>&#160;        <span class="comment">//============================================ For each group element (this is a bit repetitive, but not slow enough to deal with right now)</span></div>
<div class="line"><a name="l02977"></a><span class="lineno"> 2977</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign cIt = 0; cIt &lt; static_cast&lt; proshade_unsign &gt; ( combo.size() ); cIt++ )</div>
<div class="line"><a name="l02978"></a><span class="lineno"> 2978</span>&#160;        {</div>
<div class="line"><a name="l02979"></a><span class="lineno"> 2979</span>&#160;            <span class="comment">//======================================== Find the axis of the element</span></div>
<div class="line"><a name="l02980"></a><span class="lineno"> 2980</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#aafc6f1626c7463de53c9f4f6fa11db22">ProSHADE_internal_maths::getAxisAngleFromRotationMatrix</a> ( &amp;combo.at(cIt), &amp;axX, &amp;axY, &amp;axZ, &amp;axAng );</div>
<div class="line"><a name="l02981"></a><span class="lineno"> 2981</span>&#160;            std::cout &lt;&lt; <span class="stringliteral">&quot;Combo &quot;</span> &lt;&lt; cIt &lt;&lt; <span class="stringliteral">&quot; has axis &quot;</span> &lt;&lt; axX &lt;&lt; <span class="stringliteral">&quot; ; &quot;</span> &lt;&lt; axY &lt;&lt; <span class="stringliteral">&quot; ; &quot;</span> &lt;&lt; axZ &lt;&lt; <span class="stringliteral">&quot; WITH ANGLE: &quot;</span> &lt;&lt; axAng &lt;&lt; std::endl;</div>
<div class="line"><a name="l02982"></a><span class="lineno"> 2982</span>&#160;            </div>
<div class="line"><a name="l02983"></a><span class="lineno"> 2983</span>&#160;            <span class="comment">//======================================== Determine the fold (in terms of icosahedral symmetry fold options)</span></div>
<div class="line"><a name="l02984"></a><span class="lineno"> 2984</span>&#160;            <span class="keywordflow">if</span>      ( ( (  axAng - foldTolerance ) &lt;          0.0           ) &amp;&amp; ( (  axAng + foldTolerance ) &gt;         0.0          ) ) { <span class="keywordflow">continue</span>;           }    <span class="comment">// Zero angle - identity element</span></div>
<div class="line"><a name="l02985"></a><span class="lineno"> 2985</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ( (  axAng - foldTolerance ) &lt;          M_PI          ) &amp;&amp; ( (  axAng + foldTolerance ) &gt;         M_PI         ) ) { determinedFold = 2; }    <span class="comment">// Fold 2 ( angle =  pi    )</span></div>
<div class="line"><a name="l02986"></a><span class="lineno"> 2986</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ( ( -axAng - foldTolerance ) &lt;         -M_PI          ) &amp;&amp; ( ( -axAng + foldTolerance ) &gt;        -M_PI         ) ) { determinedFold = 2; }    <span class="comment">// Fold 2 ( angle = -pi    )</span></div>
<div class="line"><a name="l02987"></a><span class="lineno"> 2987</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ( (  axAng - foldTolerance ) &lt; (  2.0 * M_PI / 3.0 ) ) &amp;&amp; ( (  axAng + foldTolerance ) &gt; (  2.0 * M_PI / 3.0 ) ) ) { determinedFold = 3; }    <span class="comment">// Fold 3 ( angle =  2pi/3 )</span></div>
<div class="line"><a name="l02988"></a><span class="lineno"> 2988</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ( ( -axAng - foldTolerance ) &lt; ( -2.0 * M_PI / 3.0 ) ) &amp;&amp; ( ( -axAng + foldTolerance ) &gt; ( -2.0 * M_PI / 3.0 ) ) ) { determinedFold = 3; }    <span class="comment">// Fold 3 ( angle = -2pi/3 )</span></div>
<div class="line"><a name="l02989"></a><span class="lineno"> 2989</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ( (  axAng - foldTolerance ) &lt; (  2.0 * M_PI / 5.0 ) ) &amp;&amp; ( (  axAng + foldTolerance ) &gt; (  2.0 * M_PI / 5.0 ) ) ) { determinedFold = 5; }    <span class="comment">// Fold 5 ( angle =  2pi/5 )</span></div>
<div class="line"><a name="l02990"></a><span class="lineno"> 2990</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ( (  axAng - foldTolerance ) &lt; (  4.0 * M_PI / 5.0 ) ) &amp;&amp; ( (  axAng + foldTolerance ) &gt; (  4.0 * M_PI / 5.0 ) ) ) { determinedFold = 5; }    <span class="comment">// Fold 5 ( angle =  4pi/5 )</span></div>
<div class="line"><a name="l02991"></a><span class="lineno"> 2991</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ( ( -axAng - foldTolerance ) &lt; ( -2.0 * M_PI / 5.0 ) ) &amp;&amp; ( ( -axAng + foldTolerance ) &gt; ( -2.0 * M_PI / 5.0 ) ) ) { determinedFold = 5; }    <span class="comment">// Fold 5 ( angle = -2pi/5 )</span></div>
<div class="line"><a name="l02992"></a><span class="lineno"> 2992</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ( ( -axAng - foldTolerance ) &lt; ( -4.0 * M_PI / 5.0 ) ) &amp;&amp; ( ( -axAng + foldTolerance ) &gt; ( -4.0 * M_PI / 5.0 ) ) ) { determinedFold = 5; }    <span class="comment">// Fold 5 ( angle = -4pi/5 )</span></div>
<div class="line"><a name="l02993"></a><span class="lineno"> 2993</span>&#160;            <span class="keywordflow">else</span>                                                                                                                         { <span class="keywordflow">continue</span>;           }    <span class="comment">// Failed to find matching fold.</span></div>
<div class="line"><a name="l02994"></a><span class="lineno"> 2994</span>&#160;            </div>
<div class="line"><a name="l02995"></a><span class="lineno"> 2995</span>&#160;            </div>
<div class="line"><a name="l02996"></a><span class="lineno"> 2996</span>&#160;            </div>
<div class="line"><a name="l02997"></a><span class="lineno"> 2997</span>&#160;            <span class="comment">//======================================== Is this a new axis?</span></div>
<div class="line"><a name="l02998"></a><span class="lineno"> 2998</span>&#160;            <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2380a3710f7dbe672519c3adda30f7cd">ProSHADE_internal_maths::isAxisUnique</a> ( ret, axX, axY, axZ, determinedFold, axErr ) )</div>
<div class="line"><a name="l02999"></a><span class="lineno"> 2999</span>&#160;            {</div>
<div class="line"><a name="l03000"></a><span class="lineno"> 3000</span>&#160;                <span class="comment">//==================================== Create the new axis array</span></div>
<div class="line"><a name="l03001"></a><span class="lineno"> 3001</span>&#160;<span class="comment">//                anglesPassed                          = true;</span></div>
<div class="line"><a name="l03002"></a><span class="lineno"> 3002</span>&#160;                proshade_double* newAx                = <span class="keyword">new</span> proshade_double[6];</div>
<div class="line"><a name="l03003"></a><span class="lineno"> 3003</span>&#160;                <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a> ( newAx, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l03004"></a><span class="lineno"> 3004</span>&#160;                </div>
<div class="line"><a name="l03005"></a><span class="lineno"> 3005</span>&#160;                newAx[0]                              = determinedFold;</div>
<div class="line"><a name="l03006"></a><span class="lineno"> 3006</span>&#160;                newAx[1]                              = axX;</div>
<div class="line"><a name="l03007"></a><span class="lineno"> 3007</span>&#160;                newAx[2]                              = axY;</div>
<div class="line"><a name="l03008"></a><span class="lineno"> 3008</span>&#160;                newAx[3]                              = axZ;</div>
<div class="line"><a name="l03009"></a><span class="lineno"> 3009</span>&#160;                newAx[4]                              = ( 2.0 * M_PI ) / determinedFold;</div>
<div class="line"><a name="l03010"></a><span class="lineno"> 3010</span>&#160;                newAx[5]                              = 0.0;</div>
<div class="line"><a name="l03011"></a><span class="lineno"> 3011</span>&#160;                </div>
<div class="line"><a name="l03012"></a><span class="lineno"> 3012</span>&#160;                <span class="comment">//==================================== Check for it having the correct angles to other detected axes</span></div>
<div class="line"><a name="l03013"></a><span class="lineno"> 3013</span>&#160;<span class="comment">//                if ( determinedFold == 5 )</span></div>
<div class="line"><a name="l03014"></a><span class="lineno"> 3014</span>&#160;<span class="comment">//                {</span></div>
<div class="line"><a name="l03015"></a><span class="lineno"> 3015</span>&#160;<span class="comment">//                    for ( proshade_unsign c5It = 0; c5It &lt; static_cast&lt; proshade_unsign &gt; ( c5s.size() ); c5It++ )</span></div>
<div class="line"><a name="l03016"></a><span class="lineno"> 3016</span>&#160;<span class="comment">//                    {</span></div>
<div class="line"><a name="l03017"></a><span class="lineno"> 3017</span>&#160;<span class="comment">//                        dotProd                       = ProSHADE_internal_maths::computeDotProduct ( &amp;ret-&gt;at(c5s.at(c5It))[1], &amp;ret-&gt;at(c5s.at(c5It))[2], &amp;ret-&gt;at(c5s.at(c5It))[3], &amp;newAx[1], &amp;newAx[2], &amp;newAx[3] );</span></div>
<div class="line"><a name="l03018"></a><span class="lineno"> 3018</span>&#160;<span class="comment">//                        std::cout &lt;&lt; &quot;C5 to C5 dot prod: &quot; &lt;&lt; dotProd &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l03019"></a><span class="lineno"> 3019</span>&#160;<span class="comment">//                        if ( ( ( std::abs ( dotProd ) - axErr ) &lt; 0.5 ) &amp;&amp; ( ( std::abs ( dotProd ) + axErr ) &gt; 0.5 ) ) { continue; }</span></div>
<div class="line"><a name="l03020"></a><span class="lineno"> 3020</span>&#160;<span class="comment">//                        else { anglesPassed = false; break; }</span></div>
<div class="line"><a name="l03021"></a><span class="lineno"> 3021</span>&#160;<span class="comment">//                    }</span></div>
<div class="line"><a name="l03022"></a><span class="lineno"> 3022</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l03023"></a><span class="lineno"> 3023</span>&#160;<span class="comment">//                    if ( anglesPassed ) { ProSHADE_internal_misc::addToUnsignVector ( &amp;c5s, static_cast&lt;proshade_unsign&gt; ( ret-&gt;size() ) ); }</span></div>
<div class="line"><a name="l03024"></a><span class="lineno"> 3024</span>&#160;<span class="comment">//                }</span></div>
<div class="line"><a name="l03025"></a><span class="lineno"> 3025</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l03026"></a><span class="lineno"> 3026</span>&#160;<span class="comment">//                if ( determinedFold == 3 )</span></div>
<div class="line"><a name="l03027"></a><span class="lineno"> 3027</span>&#160;<span class="comment">//                {</span></div>
<div class="line"><a name="l03028"></a><span class="lineno"> 3028</span>&#160;<span class="comment">//                    for ( proshade_unsign c3It = 0; c3It &lt; static_cast&lt; proshade_unsign &gt; ( c3s.size() ); c3It++ )</span></div>
<div class="line"><a name="l03029"></a><span class="lineno"> 3029</span>&#160;<span class="comment">//                    {</span></div>
<div class="line"><a name="l03030"></a><span class="lineno"> 3030</span>&#160;<span class="comment">//                        dotProd                       = ProSHADE_internal_maths::computeDotProduct ( &amp;ret-&gt;at(c3s.at(c3It))[1], &amp;ret-&gt;at(c3s.at(c3It))[2], &amp;ret-&gt;at(c3s.at(c3It))[3], &amp;newAx[1], &amp;newAx[2], &amp;newAx[3] );</span></div>
<div class="line"><a name="l03031"></a><span class="lineno"> 3031</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l03035"></a><span class="lineno"> 3035</span>&#160;<span class="comment"></span><span class="comment">//                    }</span></div>
<div class="line"><a name="l03036"></a><span class="lineno"> 3036</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l03037"></a><span class="lineno"> 3037</span>&#160;<span class="comment">//                    if ( anglesPassed ) { ProSHADE_internal_misc::addToUnsignVector ( &amp;c3s, static_cast&lt;proshade_unsign&gt; ( ret-&gt;size() ) ); }</span></div>
<div class="line"><a name="l03038"></a><span class="lineno"> 3038</span>&#160;<span class="comment">//                }</span></div>
<div class="line"><a name="l03039"></a><span class="lineno"> 3039</span>&#160;<span class="comment">//                if ( determinedFold == 2 )</span></div>
<div class="line"><a name="l03040"></a><span class="lineno"> 3040</span>&#160;<span class="comment">//                {</span></div>
<div class="line"><a name="l03041"></a><span class="lineno"> 3041</span>&#160;<span class="comment">//                    if ( anglesPassed ) { ProSHADE_internal_misc::addToUnsignVector ( &amp;c2s, static_cast&lt;proshade_unsign&gt; ( ret-&gt;size() ) ); }</span></div>
<div class="line"><a name="l03042"></a><span class="lineno"> 3042</span>&#160;<span class="comment">//                }</span></div>
<div class="line"><a name="l03043"></a><span class="lineno"> 3043</span>&#160;                </div>
<div class="line"><a name="l03044"></a><span class="lineno"> 3044</span>&#160;                <span class="comment">//==================================== If all good, save</span></div>
<div class="line"><a name="l03045"></a><span class="lineno"> 3045</span>&#160;<span class="comment">//                if ( anglesPassed )</span></div>
<div class="line"><a name="l03046"></a><span class="lineno"> 3046</span>&#160;                {</div>
<div class="line"><a name="l03047"></a><span class="lineno"> 3047</span>&#160;                    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a> ( &amp;newAxes, newAx );</div>
<div class="line"><a name="l03048"></a><span class="lineno"> 3048</span>&#160;                    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aff0d8344fdd83482e5531eadedaac550">ProSHADE_internal_misc::deepCopyAxisToDblPtrVector</a> ( ret, newAx );</div>
<div class="line"><a name="l03049"></a><span class="lineno"> 3049</span>&#160;                }</div>
<div class="line"><a name="l03050"></a><span class="lineno"> 3050</span>&#160;            }</div>
<div class="line"><a name="l03051"></a><span class="lineno"> 3051</span>&#160;        }</div>
<div class="line"><a name="l03052"></a><span class="lineno"> 3052</span>&#160;        </div>
<div class="line"><a name="l03053"></a><span class="lineno"> 3053</span>&#160;<span class="comment">//        for ( int i = 0; i &lt; combo.size(); i++ )</span></div>
<div class="line"><a name="l03054"></a><span class="lineno"> 3054</span>&#160;<span class="comment">//        {</span></div>
<div class="line"><a name="l03055"></a><span class="lineno"> 3055</span>&#160;<span class="comment">//            for ( int j = 0; j &lt; combo.at(i).size(); j++ )</span></div>
<div class="line"><a name="l03056"></a><span class="lineno"> 3056</span>&#160;<span class="comment">//            {</span></div>
<div class="line"><a name="l03057"></a><span class="lineno"> 3057</span>&#160;<span class="comment">//                if ( j % 3 == 0 ) { std::cout &lt;&lt; std::endl; }</span></div>
<div class="line"><a name="l03058"></a><span class="lineno"> 3058</span>&#160;<span class="comment">//                std::cout &lt;&lt; combo.at(i).at(j) &lt;&lt; &quot;\t&quot;;</span></div>
<div class="line"><a name="l03059"></a><span class="lineno"> 3059</span>&#160;<span class="comment">//            }</span></div>
<div class="line"><a name="l03060"></a><span class="lineno"> 3060</span>&#160;<span class="comment">//            std::cout &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l03061"></a><span class="lineno"> 3061</span>&#160;<span class="comment">//        }</span></div>
<div class="line"><a name="l03062"></a><span class="lineno"> 3062</span>&#160;        </div>
<div class="line"><a name="l03063"></a><span class="lineno"> 3063</span>&#160;        <span class="comment">//============================================ Generate new group elements from the new axes and folds</span></div>
<div class="line"><a name="l03064"></a><span class="lineno"> 3064</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign aIt = 0; aIt &lt; static_cast&lt; proshade_unsign &gt; ( newAxes.size() ); aIt++ )</div>
<div class="line"><a name="l03065"></a><span class="lineno"> 3065</span>&#160;        {</div>
<div class="line"><a name="l03066"></a><span class="lineno"> 3066</span>&#160;            std::vector&lt; std::vector&lt; proshade_double &gt; &gt; newEls = dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a4f4bb25b05f273a41bce8205f9058717">computeGroupElementsForGroup</a> ( &amp;newAxes, aIt );</div>
<div class="line"><a name="l03067"></a><span class="lineno"> 3067</span>&#160;            combo                                     = <a class="code" href="namespace_pro_s_h_a_d_e__internal__data.html#ac2cdde3bc58869b04f1aa39aee9b01bc">ProSHADE_internal_data::joinElementsFromDifferentGroups</a> ( &amp;newEls, &amp;combo, matrixTolerance, <span class="keyword">true</span> );</div>
<div class="line"><a name="l03068"></a><span class="lineno"> 3068</span>&#160;            <span class="keyword">delete</span>[] newAxes.at(aIt);</div>
<div class="line"><a name="l03069"></a><span class="lineno"> 3069</span>&#160;        }</div>
<div class="line"><a name="l03070"></a><span class="lineno"> 3070</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l03071"></a><span class="lineno"> 3071</span>&#160;<span class="comment">//        for ( int i = 0; i &lt; ret-&gt;size(); i++ )</span></div>
<div class="line"><a name="l03072"></a><span class="lineno"> 3072</span>&#160;<span class="comment">//        {</span></div>
<div class="line"><a name="l03073"></a><span class="lineno"> 3073</span>&#160;<span class="comment">//            std::cout &lt;&lt; i &lt;&lt; &quot; || &quot; &lt;&lt; ret-&gt;at(i)[1] &lt;&lt; &quot; ; &quot; &lt;&lt; ret-&gt;at(i)[2] &lt;&lt; &quot; ; &quot; &lt;&lt; ret-&gt;at(i)[3] &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l03074"></a><span class="lineno"> 3074</span>&#160;<span class="comment">//        }</span></div>
<div class="line"><a name="l03075"></a><span class="lineno"> 3075</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l03076"></a><span class="lineno"> 3076</span>&#160;<span class="comment">//        exit(0);</span></div>
<div class="line"><a name="l03077"></a><span class="lineno"> 3077</span>&#160;    }</div>
<div class="line"><a name="l03078"></a><span class="lineno"> 3078</span>&#160;    </div>
<div class="line"><a name="l03079"></a><span class="lineno"> 3079</span>&#160;    <span class="comment">//================================================ Sort the axes by fold</span></div>
<div class="line"><a name="l03080"></a><span class="lineno"> 3080</span>&#160;    std::sort                                         ( ret-&gt;begin(), ret-&gt;end(), <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#ad14d6427df4269728627fcd880abaf31">ProSHADE_internal_misc::sortSymInvFoldHlp</a> );</div>
<div class="line"><a name="l03081"></a><span class="lineno"> 3081</span>&#160;    </div>
<div class="line"><a name="l03082"></a><span class="lineno"> 3082</span>&#160;<span class="comment">//    bool thr = true, two = true;</span></div>
<div class="line"><a name="l03083"></a><span class="lineno"> 3083</span>&#160;<span class="comment">//    for ( int i = 0; i &lt; ret-&gt;size(); i++ ) { if ( ret-&gt;at(i)[0] == 3 &amp;&amp; thr ) { std::cout &lt;&lt; std::endl; thr = false; } if ( ret-&gt;at(i)[0] == 2 &amp;&amp; two ) { std::cout &lt;&lt; std::endl; two = false; } std::cout &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; ret-&gt;at(i)[0] &lt;&lt; &quot;  |  &quot; &lt;&lt; ret-&gt;at(i)[1] &lt;&lt; &quot; ; &quot; &lt;&lt; ret-&gt;at(i)[2] &lt;&lt; &quot; ; &quot; &lt;&lt; ret-&gt;at(i)[3] &lt;&lt; std::endl; }</span></div>
<div class="line"><a name="l03084"></a><span class="lineno"> 3084</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l03085"></a><span class="lineno"> 3085</span>&#160;<span class="comment">//    std::cout &lt;&lt; &quot;Found &quot; &lt;&lt; ret-&gt;size() &lt;&lt; &quot; icos syms and &quot; &lt;&lt; combo.size ( ) &lt;&lt; &quot; group elements.&quot; &lt;&lt; std::endl; exit(0);</span></div>
<div class="line"><a name="l03086"></a><span class="lineno"> 3086</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l03087"></a><span class="lineno"> 3087</span>&#160;    return ;</div>
<div class="line"><a name="l03088"></a><span class="lineno"> 3088</span>&#160;    </div>
<div class="line"><a name="l03089"></a><span class="lineno"> 3089</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a377aa42d9199d427d93efca48e3cd878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a377aa42d9199d427d93efca48e3cd878">&#9670;&nbsp;</a></span>predictOctaAxes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::predictOctaAxes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>matrixTolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function predicts all octahedral point group symmetry axes from the cyclic point groups list. </p>
<p>This function starts with finding the best detected cyclic symmetries of the right folds and having the closest angle to the octahedron dihedral angle. It then proceeds to generate all the point group elements and their combinations. From these it then computes some of the missing axes and their associated angles. These steps can then be repeated until no more new elements are found (a group exists) or the process fails. The the detected axes (as obtained back from the point group elements) are then returned without checking for having the correct number of them.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function assumes that the <a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a4f09b90de1f15b345ee7998ff31327f3" title="This function takes the list of C symmetries and decides whether basic requirements for isosahedral s...">detectIcosahedralSymmetry()</a> function has successfully run (i.e. returned true).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>The vector . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum average peak height for axis to be considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verobse</td><td>How loud the announcments should be? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axisTolerance</td><td>The tolerance for two axes to be considered similar in terms of cosine distance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrixTolerance</td><td>The maximum allowed rotation matrix trace difference allowed for the matrices to be considered the same. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l03161">3161</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03162"></a><span class="lineno"> 3162</span>&#160;{</div>
<div class="line"><a name="l03163"></a><span class="lineno"> 3163</span>&#160;<span class="comment">//    //================================================ Initialise variables</span></div>
<div class="line"><a name="l03164"></a><span class="lineno"> 3164</span>&#160;<span class="comment">//    std::vector&lt; proshade_double* &gt; newAxes;</span></div>
<div class="line"><a name="l03165"></a><span class="lineno"> 3165</span>&#160;<span class="comment">//    proshade_double axX, axY, axZ, axAng, foldTolerance = 0.1;</span></div>
<div class="line"><a name="l03166"></a><span class="lineno"> 3166</span>&#160;<span class="comment">//    proshade_unsign bestC5, bestC3, determinedFold, prevComboSize = 0;</span></div>
<div class="line"><a name="l03167"></a><span class="lineno"> 3167</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l03168"></a><span class="lineno"> 3168</span>&#160;<span class="comment">//    //================================================ Find the best axis combination with dihedral angle and correct folds</span></div>
<div class="line"><a name="l03169"></a><span class="lineno"> 3169</span>&#160;<span class="comment">//    std::pair&lt; proshade_unsign, proshade_unsign &gt; initAxes = findBestOctaDihedralPair ( CSymList, minPeakHeight, axErr );</span></div>
<div class="line"><a name="l03170"></a><span class="lineno"> 3170</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l03171"></a><span class="lineno"> 3171</span>&#160;<span class="comment">//    //================================================ Save detected axes to ret</span></div>
<div class="line"><a name="l03172"></a><span class="lineno"> 3172</span>&#160;<span class="comment">//    ProSHADE_internal_misc::deepCopyAxisToDblPtrVector ( ret, CSymList-&gt;at(initAxes.first) );</span></div>
<div class="line"><a name="l03173"></a><span class="lineno"> 3173</span>&#160;<span class="comment">//    ProSHADE_internal_misc::deepCopyAxisToDblPtrVector ( ret, CSymList-&gt;at(initAxes.second) );</span></div>
<div class="line"><a name="l03174"></a><span class="lineno"> 3174</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l03175"></a><span class="lineno"> 3175</span>&#160;<span class="comment">//    //================================================ Generate initial group elements</span></div>
<div class="line"><a name="l03176"></a><span class="lineno"> 3176</span>&#160;<span class="comment">//    std::vector&lt;std::vector&lt; proshade_double &gt; &gt; elsC4 = dataObj-&gt;computeGroupElementsForGroup ( CSymList, initAxes.first );</span></div>
<div class="line"><a name="l03177"></a><span class="lineno"> 3177</span>&#160;<span class="comment">//    std::vector&lt;std::vector&lt; proshade_double &gt; &gt; elsC3 = dataObj-&gt;computeGroupElementsForGroup ( CSymList, initAxes.second );</span></div>
<div class="line"><a name="l03178"></a><span class="lineno"> 3178</span>&#160;<span class="comment">//    std::vector&lt;std::vector&lt; proshade_double &gt; &gt; combo = ProSHADE_internal_data::joinElementsFromDifferentGroups ( &amp;elsC4, &amp;elsC3, matrixTolerance, true );</span></div>
<div class="line"><a name="l03179"></a><span class="lineno"> 3179</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l03180"></a><span class="lineno"> 3180</span>&#160;<span class="comment">//    //================================================ Iteratively find all remanining axes by multiplying the group elements</span></div>
<div class="line"><a name="l03181"></a><span class="lineno"> 3181</span>&#160;<span class="comment">//    while ( prevComboSize &lt; combo.size() )</span></div>
<div class="line"><a name="l03182"></a><span class="lineno"> 3182</span>&#160;<span class="comment">//    {</span></div>
<div class="line"><a name="l03183"></a><span class="lineno"> 3183</span>&#160;<span class="comment">//        //============================================ Sanity check</span></div>
<div class="line"><a name="l03184"></a><span class="lineno"> 3184</span>&#160;<span class="comment">//        if ( prevComboSize &gt; 24 ) { break; }</span></div>
<div class="line"><a name="l03185"></a><span class="lineno"> 3185</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l03186"></a><span class="lineno"> 3186</span>&#160;<span class="comment">//        //============================================ Initialise iteration</span></div>
<div class="line"><a name="l03187"></a><span class="lineno"> 3187</span>&#160;<span class="comment">//        prevComboSize                                 = combo.size ( );</span></div>
<div class="line"><a name="l03188"></a><span class="lineno"> 3188</span>&#160;<span class="comment">//        newAxes.clear                                 ( );</span></div>
<div class="line"><a name="l03189"></a><span class="lineno"> 3189</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l03190"></a><span class="lineno"> 3190</span>&#160;<span class="comment">//        //============================================ For each group element (this is a bit repetitive, but not slow enough to deal with right now)</span></div>
<div class="line"><a name="l03191"></a><span class="lineno"> 3191</span>&#160;<span class="comment">//        for ( proshade_unsign cIt = 0; cIt &lt; static_cast&lt; proshade_unsign &gt; ( combo.size() ); cIt++ )</span></div>
<div class="line"><a name="l03192"></a><span class="lineno"> 3192</span>&#160;<span class="comment">//        {</span></div>
<div class="line"><a name="l03193"></a><span class="lineno"> 3193</span>&#160;<span class="comment">//            //======================================== Find the axis of the element</span></div>
<div class="line"><a name="l03194"></a><span class="lineno"> 3194</span>&#160;<span class="comment">//            ProSHADE_internal_maths::getAxisAngleFromRotationMatrix ( &amp;combo.at(cIt), &amp;axX, &amp;axY, &amp;axZ, &amp;axAng );</span></div>
<div class="line"><a name="l03195"></a><span class="lineno"> 3195</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l03196"></a><span class="lineno"> 3196</span>&#160;<span class="comment">//            //======================================== Determine the fold (in terms of icosahedral symmetry fold options)</span></div>
<div class="line"><a name="l03197"></a><span class="lineno"> 3197</span>&#160;<span class="comment">//            if      ( ( ( axAng - foldTolerance ) &lt;         0.0          ) &amp;&amp; ( ( axAng + foldTolerance ) &gt;         0.0          ) ) { continue;           }    // Zero angle - identity element</span></div>
<div class="line"><a name="l03198"></a><span class="lineno"> 3198</span>&#160;<span class="comment">//            else if ( ( ( axAng - foldTolerance ) &lt;         M_PI         ) &amp;&amp; ( ( axAng + foldTolerance ) &gt;         M_PI         ) ) { determinedFold = 2; }    // Fold 2 ( angle = pi    )</span></div>
<div class="line"><a name="l03199"></a><span class="lineno"> 3199</span>&#160;<span class="comment">//            else if ( ( ( axAng - foldTolerance ) &lt; ( 2.0 * M_PI / 3.0 ) ) &amp;&amp; ( ( axAng + foldTolerance ) &gt; ( 2.0 * M_PI / 3.0 ) ) ) { determinedFold = 3; }    // Fold 3 ( angle = 2pi/3 )</span></div>
<div class="line"><a name="l03200"></a><span class="lineno"> 3200</span>&#160;<span class="comment">//            else if ( ( ( axAng - foldTolerance ) &lt; ( 2.0 * M_PI / 1.5 ) ) &amp;&amp; ( ( axAng + foldTolerance ) &gt; ( 2.0 * M_PI / 1.5 ) ) ) { determinedFold = 3; }    // Fold 3 ( angle = 4pi/3 )</span></div>
<div class="line"><a name="l03201"></a><span class="lineno"> 3201</span>&#160;<span class="comment">//            else if ( ( ( axAng - foldTolerance ) &lt; ( 2.0 * M_PI / 5.0 ) ) &amp;&amp; ( ( axAng + foldTolerance ) &gt; ( 2.0 * M_PI / 5.0 ) ) ) { determinedFold = 5; }    // Fold 5 ( angle = 2pi/5 )</span></div>
<div class="line"><a name="l03202"></a><span class="lineno"> 3202</span>&#160;<span class="comment">//            else if ( ( ( axAng - foldTolerance ) &lt; ( 4.0 * M_PI / 5.0 ) ) &amp;&amp; ( ( axAng + foldTolerance ) &gt; ( 4.0 * M_PI / 5.0 ) ) ) { determinedFold = 5; }    // Fold 5 ( angle = 4pi/5 )</span></div>
<div class="line"><a name="l03203"></a><span class="lineno"> 3203</span>&#160;<span class="comment">//            else if ( ( ( axAng - foldTolerance ) &lt; ( 6.0 * M_PI / 5.0 ) ) &amp;&amp; ( ( axAng + foldTolerance ) &gt; ( 6.0 * M_PI / 5.0 ) ) ) { determinedFold = 5; }    // Fold 5 ( angle = 6pi/5 )</span></div>
<div class="line"><a name="l03204"></a><span class="lineno"> 3204</span>&#160;<span class="comment">//            else if ( ( ( axAng - foldTolerance ) &lt; ( 8.0 * M_PI / 5.0 ) ) &amp;&amp; ( ( axAng + foldTolerance ) &gt; ( 8.0 * M_PI / 5.0 ) ) ) { determinedFold = 5; }    // Fold 5 ( angle = 8pi/5 )</span></div>
<div class="line"><a name="l03205"></a><span class="lineno"> 3205</span>&#160;<span class="comment">//            else                                                                                                                     { continue;           }    // Failed to find matching fold.</span></div>
<div class="line"><a name="l03206"></a><span class="lineno"> 3206</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l03207"></a><span class="lineno"> 3207</span>&#160;<span class="comment">//            //======================================== Is this a new axis?</span></div>
<div class="line"><a name="l03208"></a><span class="lineno"> 3208</span>&#160;<span class="comment">//            if ( ProSHADE_internal_maths::isAxisUnique ( ret, axX, axY, axZ, determinedFold, axErr ) )</span></div>
<div class="line"><a name="l03209"></a><span class="lineno"> 3209</span>&#160;<span class="comment">//            {</span></div>
<div class="line"><a name="l03210"></a><span class="lineno"> 3210</span>&#160;<span class="comment">//                proshade_double* newAx                = new proshade_double[6];</span></div>
<div class="line"><a name="l03211"></a><span class="lineno"> 3211</span>&#160;<span class="comment">//                ProSHADE_internal_misc::checkMemoryAllocation ( newAx, __FILE__, __LINE__, __func__ );</span></div>
<div class="line"><a name="l03212"></a><span class="lineno"> 3212</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l03213"></a><span class="lineno"> 3213</span>&#160;<span class="comment">//                newAx[0]                              = determinedFold;</span></div>
<div class="line"><a name="l03214"></a><span class="lineno"> 3214</span>&#160;<span class="comment">//                newAx[1]                              = axX;</span></div>
<div class="line"><a name="l03215"></a><span class="lineno"> 3215</span>&#160;<span class="comment">//                newAx[2]                              = axY;</span></div>
<div class="line"><a name="l03216"></a><span class="lineno"> 3216</span>&#160;<span class="comment">//                newAx[3]                              = axZ;</span></div>
<div class="line"><a name="l03217"></a><span class="lineno"> 3217</span>&#160;<span class="comment">//                newAx[4]                              = ( 2.0 * M_PI ) / determinedFold;</span></div>
<div class="line"><a name="l03218"></a><span class="lineno"> 3218</span>&#160;<span class="comment">//                newAx[5]                              = 0.0;</span></div>
<div class="line"><a name="l03219"></a><span class="lineno"> 3219</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l03220"></a><span class="lineno"> 3220</span>&#160;<span class="comment">//                ProSHADE_internal_misc::addToDblPtrVector ( &amp;newAxes, newAx );</span></div>
<div class="line"><a name="l03221"></a><span class="lineno"> 3221</span>&#160;<span class="comment">//                ProSHADE_internal_misc::deepCopyAxisToDblPtrVector ( ret, newAx );</span></div>
<div class="line"><a name="l03222"></a><span class="lineno"> 3222</span>&#160;<span class="comment">//            }</span></div>
<div class="line"><a name="l03223"></a><span class="lineno"> 3223</span>&#160;<span class="comment">//        }</span></div>
<div class="line"><a name="l03224"></a><span class="lineno"> 3224</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l03225"></a><span class="lineno"> 3225</span>&#160;<span class="comment">//        //============================================ Generate new group elements from the new axes and folds</span></div>
<div class="line"><a name="l03226"></a><span class="lineno"> 3226</span>&#160;<span class="comment">//        for ( proshade_unsign aIt = 0; aIt &lt; static_cast&lt; proshade_unsign &gt; ( newAxes.size() ); aIt++ )</span></div>
<div class="line"><a name="l03227"></a><span class="lineno"> 3227</span>&#160;<span class="comment">//        {</span></div>
<div class="line"><a name="l03228"></a><span class="lineno"> 3228</span>&#160;<span class="comment">//            std::vector&lt; std::vector&lt; proshade_double &gt; &gt; newEls = dataObj-&gt;computeGroupElementsForGroup ( &amp;newAxes, aIt );</span></div>
<div class="line"><a name="l03229"></a><span class="lineno"> 3229</span>&#160;<span class="comment">//            combo                                     = ProSHADE_internal_data::joinElementsFromDifferentGroups ( &amp;newEls, &amp;combo, matrixTolerance, true );</span></div>
<div class="line"><a name="l03230"></a><span class="lineno"> 3230</span>&#160;<span class="comment">//            delete[] newAxes.at(aIt);</span></div>
<div class="line"><a name="l03231"></a><span class="lineno"> 3231</span>&#160;<span class="comment">//        }</span></div>
<div class="line"><a name="l03232"></a><span class="lineno"> 3232</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l03233"></a><span class="lineno"> 3233</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l03234"></a><span class="lineno"> 3234</span>&#160;<span class="comment">//    //================================================ Sort the axes by fold</span></div>
<div class="line"><a name="l03235"></a><span class="lineno"> 3235</span>&#160;<span class="comment">//    std::sort                                         ( ret-&gt;begin(), ret-&gt;end(), ProSHADE_internal_misc::sortSymInvFoldHlp );</span></div>
<div class="line"><a name="l03236"></a><span class="lineno"> 3236</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l03237"></a><span class="lineno"> 3237</span>&#160;<span class="comment">//    std::cout &lt;&lt; &quot;Found &quot; &lt;&lt; ret-&gt;size() &lt;&lt; &quot; octa syms and &quot; &lt;&lt; combo.size ( ) &lt;&lt; &quot; group elements.&quot; &lt;&lt; std::endl; exit(0);</span></div>
<div class="line"><a name="l03238"></a><span class="lineno"> 3238</span>&#160;    </div>
<div class="line"><a name="l03239"></a><span class="lineno"> 3239</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l03240"></a><span class="lineno"> 3240</span>&#160;    return ;</div>
<div class="line"><a name="l03241"></a><span class="lineno"> 3241</span>&#160;    </div>
<div class="line"><a name="l03242"></a><span class="lineno"> 3242</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9293eec4e7edf274155ed6a07dad8b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9293eec4e7edf274155ed6a07dad8b16">&#9670;&nbsp;</a></span>printSymmetryCompletion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::printSymmetryCompletion </td>
          <td>(</td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>noSyms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function simply prints the summary and warnings for cyclic symmetries detection completion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">noSyms</td><td>The number of symmetries that were detected. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>How loud the run should be and therefore if anything should be printed at all. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01085">1085</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;{</div>
<div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;    <span class="comment">//================================================ Report completion of symmetry detection</span></div>
<div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;    std::stringstream ss;</div>
<div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;    ss &lt;&lt; <span class="stringliteral">&quot;Detected &quot;</span> &lt;&lt; noSyms &lt;&lt; <span class="stringliteral">&quot; Cyclic symmetries.&quot;</span>;</div>
<div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a6aa8cdb600cad623409802cfaed494fa">ProSHADE_internal_messages::printProgressMessage</a>  ( verbose, 2, ss.str() );</div>
<div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;    </div>
<div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;    <span class="comment">//================================================ If no symmetries were found, print warning</span></div>
<div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;    <span class="keywordflow">if</span> ( noSyms &lt; 1 )</div>
<div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;    {</div>
<div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#addbb90f2b4199441f60e241ac850daa2">ProSHADE_internal_messages::printWarningMessage</a> ( verbose, <span class="stringliteral">&quot;!!! ProSHADE WARNING !!! Failed to detect any symmetries. If you believe there should be one, you can try decreasing the resolution or checking that the map is centred on the centry of symmetry (or use map centering option in ProSHADE).&quot;</span>, <span class="stringliteral">&quot;WS00030&quot;</span> );</div>
<div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;    }</div>
<div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;    </div>
<div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;    return ;</div>
<div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;    </div>
<div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af4b044752fe0a780a3f09743e9d8d58e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b044752fe0a780a3f09743e9d8d58e">&#9670;&nbsp;</a></span>printSymmetryGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::printSymmetryGroup </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt;&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt;&#160;</td>
          <td class="paramname"><em>peaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function simply prints the detected symmetry and all its supporting peaks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>A single symmetry axis group indices to be printed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">peaks</td><td>The vector of all peaks from which the indices are drawn. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>How loud the run should be and therefore if anything should be printed at all. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01059">1059</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;{</div>
<div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;    <span class="comment">//================================================ Detected symmetry table header</span></div>
<div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;    std::stringstream ss;</div>
<div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;    ss &lt;&lt; <span class="stringliteral">&quot;Detected C&quot;</span> &lt;&lt; grp.at(0) &lt;&lt; <span class="stringliteral">&quot; symmetry with following peaks:&quot;</span>;</div>
<div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a6aa8cdb600cad623409802cfaed494fa">ProSHADE_internal_messages::printProgressMessage</a> ( verbose, 5, ss.str() );</div>
<div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a6aa8cdb600cad623409802cfaed494fa">ProSHADE_internal_messages::printProgressMessage</a> ( verbose, 5, <span class="stringliteral">&quot;\tx\t y\t z\tAngle\tPeak height&quot;</span> );</div>
<div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;    </div>
<div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;    <span class="comment">//================================================ Now print all supporting peaks</span></div>
<div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign pkIt = 1; pkIt &lt; static_cast&lt;proshade_unsign&gt; ( grp.size() ); pkIt++ )</div>
<div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;    {</div>
<div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;        std::stringstream SS;</div>
<div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;        SS &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>( peaks.at(grp.at(pkIt))[0] * 100.0 ) / 100.0 &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>( peaks.at(grp.at(pkIt))[1] * 100.0 ) / 100.0 &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>( peaks.at(grp.at(pkIt))[2] * 100.0 ) / 100.0 &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>( peaks.at(grp.at(pkIt))[3] * 100.0 ) / 100.0 &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>( peaks.at(grp.at(pkIt))[4] * 100.0 ) / 100.0;</div>
<div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a6aa8cdb600cad623409802cfaed494fa">ProSHADE_internal_messages::printProgressMessage</a> ( verbose, 5, SS.str() );</div>
<div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;    }</div>
<div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;    </div>
<div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;    return ;</div>
<div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;    </div>
<div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af9835b91e354e4615beb79b5c2a674e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9835b91e354e4615beb79b5c2a674e9">&#9670;&nbsp;</a></span>printSymmetryPeaks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::printSymmetryPeaks </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt;&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt;&#160;</td>
          <td class="paramname"><em>peaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>groupNo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function simply prints the symmetry axis group supplied in the first parameter from the second parameter values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>A single symmetry axis group indices to be printed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">peaks</td><td>The vector of all peaks from which the indices are drawn. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>How loud the run should be and therefore if anything should be printed at all. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00518">518</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;{</div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;    <span class="comment">//================================================ Symmetry group output header</span></div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;    std::stringstream hlpSS;</div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;    hlpSS &lt;&lt; <span class="stringliteral">&quot;Symmetry axis group &quot;</span> &lt;&lt; groupNo;</div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a6aa8cdb600cad623409802cfaed494fa">ProSHADE_internal_messages::printProgressMessage</a>  ( verbose, 6, hlpSS.str() );</div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a6aa8cdb600cad623409802cfaed494fa">ProSHADE_internal_messages::printProgressMessage</a>  ( verbose, 6, <span class="stringliteral">&quot;Peak index\t\tx\t y\t z\tAngle\tPeak heiht&quot;</span> );</div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;    </div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;    <span class="comment">//================================================ Print the symmetry group</span></div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign axIt = 0; axIt &lt; static_cast&lt;proshade_unsign&gt; ( grp.size() ); axIt++ )</div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;    {</div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;        std::stringstream SS;</div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;        SS &lt;&lt; <span class="stringliteral">&quot;    &quot;</span> &lt;&lt; axIt &lt;&lt; <span class="stringliteral">&quot;\t      &quot;</span> &lt;&lt; <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>( peaks.at(grp.at(axIt))[0] * 100.0 ) / 100.0 &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>( peaks.at(grp.at(axIt))[1] * 100.0 ) / 100.0 &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>( peaks.at(grp.at(axIt))[2] * 100.0 ) / 100.0 &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>( peaks.at(grp.at(axIt))[3] * 100.0 ) / 100.0 &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>( peaks.at(grp.at(axIt))[4] * 100.0 ) / 100.0;</div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a6aa8cdb600cad623409802cfaed494fa">ProSHADE_internal_messages::printProgressMessage</a> ( verbose, 6, SS.str() );</div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;    }</div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;    </div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;    return ;</div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160; </div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a870711ceabba16c8fc79bd93d26b11a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a870711ceabba16c8fc79bd93d26b11a8">&#9670;&nbsp;</a></span>saveAllCSymmetries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::saveAllCSymmetries </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt;&#160;</td>
          <td class="paramname"><em>detected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt;&#160;</td>
          <td class="paramname"><em>peaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes the detected symmetries indices and peaks and saves these in the main cyclic symmetries detection output format. </p>
<p>This function uses the indices of peaks forming a detected symmetry along with the peak values corresponding to these indices in order to compute the symmetry description - that is the fold, average x, y and z-axis elements, angle (2pi/fold) and the average peak height. With all this computed for each detected symmetry, it saves these as double arrays to the output vector of double arrays for further processing. The function also does not save redundant symmetries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">detected</td><td>This is a vector of vectors with the indices of detected symmetry peaks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">peaks</td><td>These are the peaks and their values which come together to form the detected symmetry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>This is the variable where the results will be saved. It is a vector of double[6] arrays with the following meaning: [0] = fold, [1] = x-axis, [2] = y-axis, [3] = z-axis, [4] = angle, [5] = average peak height. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The tolerance on axis matching. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01115">1115</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;{</div>
<div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;    proshade_double sumX, sumY, sumZ, sumH;</div>
<div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;    </div>
<div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;    <span class="comment">//================================================ Start saving</span></div>
<div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign symIt = 0; symIt &lt; static_cast&lt;proshade_unsign&gt; ( detected.size() ); symIt++ )</div>
<div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;    {</div>
<div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;        <span class="comment">//============================================ Allocate the memory</span></div>
<div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;        proshade_double* hlpP                         = <span class="keyword">new</span> proshade_double [6];</div>
<div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a> ( hlpP, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;        </div>
<div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;        <span class="comment">//============================================ Set obvious values</span></div>
<div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;        hlpP[0]                                       = <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( detected.at(symIt).at(0) );</div>
<div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;        hlpP[4]                                       = <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( ( 2.0 * M_PI ) / hlpP[0] );</div>
<div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;        </div>
<div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;        <span class="comment">//============================================ Compute peak averages for rest</span></div>
<div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;        sumX = 0.0; sumY = 0.0; sumZ = 0.0; sumH = 0.0;</div>
<div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign pkIt = 1; pkIt &lt; static_cast&lt;proshade_unsign&gt; ( detected.at(symIt).size() ); pkIt++ )</div>
<div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;        {</div>
<div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;            sumX                                     += peaks.at(detected.at(symIt).at(pkIt))[0];</div>
<div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;            sumY                                     += peaks.at(detected.at(symIt).at(pkIt))[1];</div>
<div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;            sumZ                                     += peaks.at(detected.at(symIt).at(pkIt))[2];</div>
<div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;            sumH                                     += peaks.at(detected.at(symIt).at(pkIt))[4];</div>
<div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;        }</div>
<div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;        sumX                                         /= <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( detected.at(symIt).size() - 1 );</div>
<div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;        sumY                                         /= <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( detected.at(symIt).size() - 1 );</div>
<div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;        sumZ                                         /= <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( detected.at(symIt).size() - 1 );</div>
<div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;        sumH                                         /= <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( detected.at(symIt).size() - 1 );</div>
<div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;        </div>
<div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;        <span class="comment">//============================================ And add these as well</span></div>
<div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;        hlpP[1]                                       = sumX;</div>
<div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;        hlpP[2]                                       = sumY;</div>
<div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;        hlpP[3]                                       = sumZ;</div>
<div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;        hlpP[5]                                       = sumH;</div>
<div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;        </div>
<div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;        <span class="comment">//============================================ Save the complete symmetry description to the vector, unless already there</span></div>
<div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;        <span class="keywordflow">if</span> ( !<a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#abb4d85e82d1c55d0aa18795fea449adf">ProSHADE_internal_symmetry::isSymmetrySame</a> ( ret, hlpP, axErr ) )</div>
<div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;        {</div>
<div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a> ( ret, hlpP );</div>
<div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;        }</div>
<div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;        {</div>
<div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;            <span class="keyword">delete</span>[] hlpP;</div>
<div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;        }</div>
<div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;    }</div>
<div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;    </div>
<div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;    return ;</div>
<div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;    </div>
<div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5dda335a87d6c26edfd3cf2a29ff7f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dda335a87d6c26edfd3cf2a29ff7f1f">&#9670;&nbsp;</a></span>saveDetectedCSymmetry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::saveDetectedCSymmetry </td>
          <td>(</td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>matchedPeaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function saves a detected symmetry for reporting to the user. </p>
<p>This function simply saves the supplied group members and fold value to the main output vector of vectors (also supplied). It makes sure the saving format (fold first, then all symmetry peak indices) is upheld.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fold</td><td>This is the fold value of the detected C symmetry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matchedPeaks</td><td>A vector containing the indices of all peaks forming this symmetry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>The vector of vectors to be returned by <a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a648ddad98891a4d8a6af5187d994c5ec" title="This function searches the list of peaks for presence of cyclic symmetry.">findPeaksCSymmetry()</a> and containing all detected symmetries (to which we are saving here). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>How loud the standard output of this run should be? </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00884">884</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;{</div>
<div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;    <span class="comment">//================================================ Save fold as first vector value</span></div>
<div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;    std::vector&lt; proshade_unsign &gt; hlpVec;</div>
<div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a>         ( &amp;hlpVec, fold );</div>
<div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;    </div>
<div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;    <span class="comment">//================================================ and follow it with indices of all symmetry forming peaks</span></div>
<div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign pIt = 0; pIt &lt; static_cast&lt;proshade_unsign&gt; ( matchedPeaks-&gt;size() ); pIt++ )</div>
<div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;    {</div>
<div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a>     ( &amp;hlpVec, matchedPeaks-&gt;at(pIt) );</div>
<div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;    }</div>
<div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a86e2bb172f766ab4a620df482d2fe481">ProSHADE_internal_misc::addToUnsignVectorVector</a>   ( ret, hlpVec );</div>
<div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;    </div>
<div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;    <span class="comment">//================================================ Report finding symmetry</span></div>
<div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;    std::stringstream hlpS;</div>
<div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;    hlpS &lt;&lt; <span class="stringliteral">&quot;Found symmetry C&quot;</span> &lt;&lt; fold;</div>
<div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a6aa8cdb600cad623409802cfaed494fa">ProSHADE_internal_messages::printProgressMessage</a>  ( verbose, 5, hlpS.str() );</div>
<div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;    </div>
<div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;    return ;</div>
<div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160; </div>
<div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab0ac919dd609bc6bded806c0f78201fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0ac919dd609bc6bded806c0f78201fd">&#9670;&nbsp;</a></span>saveDSymmetry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::saveDSymmetry </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>axisOne</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>axisTwo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function saves a detected dihedral symmetry to the dihedral symmetries list. </p>
<p>This function takes two C symmetry axes as supplied by the calling function and the list of the detected C symmetries. It then produces the saving structure for a dihedral symmetry formed by the two supplied axes and saves this structure to the supplied dihedral symmetry list vector - ret.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>The vector of double pointers to which the symmetry is to be saved to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axisOne</td><td>The index of the first C symmetry forming the dihedral symmetry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axisTwo</td><td>The index of the second C symmetry forming the dihedral symmetry. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01301">1301</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;{</div>
<div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;    <span class="comment">//================================================ Allocate the memory</span></div>
<div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160;    proshade_double* hlpP                             = <span class="keyword">new</span> proshade_double [12];</div>
<div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( hlpP, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l01306"></a><span class="lineno"> 1306</span>&#160;    </div>
<div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;    <span class="comment">//================================================ Set obvious values</span></div>
<div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;    hlpP[0]                                           = <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( CSymList-&gt;at(axisOne)[0] );</div>
<div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;    hlpP[4]                                           = <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( ( 2.0 * M_PI ) / hlpP[0] );</div>
<div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;    hlpP[6]                                           = <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( CSymList-&gt;at(axisTwo)[0] );</div>
<div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;    hlpP[10]                                          = <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( ( 2.0 * M_PI ) / hlpP[6] );</div>
<div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;    </div>
<div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;    <span class="comment">//================================================ Set the axis and heights</span></div>
<div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160;    hlpP[1]                                           = CSymList-&gt;at(axisOne)[1];</div>
<div class="line"><a name="l01315"></a><span class="lineno"> 1315</span>&#160;    hlpP[2]                                           = CSymList-&gt;at(axisOne)[2];</div>
<div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160;    hlpP[3]                                           = CSymList-&gt;at(axisOne)[3];</div>
<div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160;    hlpP[5]                                           = CSymList-&gt;at(axisOne)[5];</div>
<div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;    hlpP[7]                                           = CSymList-&gt;at(axisTwo)[1];</div>
<div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160;    hlpP[8]                                           = CSymList-&gt;at(axisTwo)[2];</div>
<div class="line"><a name="l01320"></a><span class="lineno"> 1320</span>&#160;    hlpP[9]                                           = CSymList-&gt;at(axisTwo)[3];</div>
<div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160;    hlpP[11]                                          = CSymList-&gt;at(axisTwo)[5];</div>
<div class="line"><a name="l01322"></a><span class="lineno"> 1322</span>&#160;    </div>
<div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160;    <span class="comment">//================================================ Save to ret</span></div>
<div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a>         ( ret, hlpP );</div>
<div class="line"><a name="l01325"></a><span class="lineno"> 1325</span>&#160;    </div>
<div class="line"><a name="l01326"></a><span class="lineno"> 1326</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01327"></a><span class="lineno"> 1327</span>&#160;    return ;</div>
<div class="line"><a name="l01328"></a><span class="lineno"> 1328</span>&#160;    </div>
<div class="line"><a name="l01329"></a><span class="lineno"> 1329</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5dc4353223fc752e0007b2adec193079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc4353223fc752e0007b2adec193079">&#9670;&nbsp;</a></span>saveMissingAxisNewOnly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::saveMissingAxisNewOnly </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>axVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function saves the recovered information about missing axis into a full symmetry, making sure no duplicates are created. </p>
<p>This function takes the information about the missing symmetry and proceeds to create a full symmetry description out of it. It then checks whether the vector already contains similar symmetry, either replacing the old or ignoring the new symmetry based on which has hiher height. If the symmetry does not match anything in the vector, it will be copied as a new vector entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">axVec</td><td>Vector containing all already detected missing axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axX</td><td>The x-axis element of the missing axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axY</td><td>The y-axis element of the missing axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axZ</td><td>The z-axis element of the missing axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>The average map height for this new axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fold</td><td>The fold of the searched for axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01799">1799</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01800"></a><span class="lineno"> 1800</span>&#160;{</div>
<div class="line"><a name="l01801"></a><span class="lineno"> 1801</span>&#160;    <span class="comment">//================================================  Create symmetry array from the inputs</span></div>
<div class="line"><a name="l01802"></a><span class="lineno"> 1802</span>&#160;    proshade_double* hlpSym                           = <span class="keyword">new</span> proshade_double [6];</div>
<div class="line"><a name="l01803"></a><span class="lineno"> 1803</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( hlpSym, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l01804"></a><span class="lineno"> 1804</span>&#160;    </div>
<div class="line"><a name="l01805"></a><span class="lineno"> 1805</span>&#160;    <span class="comment">//================================================ Fill it in</span></div>
<div class="line"><a name="l01806"></a><span class="lineno"> 1806</span>&#160;    hlpSym[0]                                         = <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( fold );</div>
<div class="line"><a name="l01807"></a><span class="lineno"> 1807</span>&#160;    hlpSym[1]                                         = axX;</div>
<div class="line"><a name="l01808"></a><span class="lineno"> 1808</span>&#160;    hlpSym[2]                                         = axY;</div>
<div class="line"><a name="l01809"></a><span class="lineno"> 1809</span>&#160;    hlpSym[3]                                         = axZ;</div>
<div class="line"><a name="l01810"></a><span class="lineno"> 1810</span>&#160;    hlpSym[4]                                         = ( 2.0 * M_PI ) / <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( fold );</div>
<div class="line"><a name="l01811"></a><span class="lineno"> 1811</span>&#160;    hlpSym[5]                                         = height;</div>
<div class="line"><a name="l01812"></a><span class="lineno"> 1812</span>&#160;    </div>
<div class="line"><a name="l01813"></a><span class="lineno"> 1813</span>&#160;    <span class="comment">//================================================ Check if similar symmetry does not exist already</span></div>
<div class="line"><a name="l01814"></a><span class="lineno"> 1814</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign symIt = 0; symIt &lt; static_cast&lt;proshade_unsign&gt; ( axVec-&gt;size() ); symIt++ )</div>
<div class="line"><a name="l01815"></a><span class="lineno"> 1815</span>&#160;    {</div>
<div class="line"><a name="l01816"></a><span class="lineno"> 1816</span>&#160;        <span class="comment">//============================================ Minor speed-up =&gt; only test for same folds</span></div>
<div class="line"><a name="l01817"></a><span class="lineno"> 1817</span>&#160;        <span class="keywordflow">if</span> ( axVec-&gt;at(symIt)[0] == hlpSym[0] )</div>
<div class="line"><a name="l01818"></a><span class="lineno"> 1818</span>&#160;        {</div>
<div class="line"><a name="l01819"></a><span class="lineno"> 1819</span>&#160;            <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2b2f67cba1eea57f19fdaf062db74fde">ProSHADE_internal_maths::vectorOrientationSimilarity</a> ( axVec-&gt;at(symIt)[1],</div>
<div class="line"><a name="l01820"></a><span class="lineno"> 1820</span>&#160;                                                                        axVec-&gt;at(symIt)[2],</div>
<div class="line"><a name="l01821"></a><span class="lineno"> 1821</span>&#160;                                                                        axVec-&gt;at(symIt)[3],</div>
<div class="line"><a name="l01822"></a><span class="lineno"> 1822</span>&#160;                                                                        hlpSym[1],</div>
<div class="line"><a name="l01823"></a><span class="lineno"> 1823</span>&#160;                                                                        hlpSym[2],</div>
<div class="line"><a name="l01824"></a><span class="lineno"> 1824</span>&#160;                                                                        hlpSym[3],</div>
<div class="line"><a name="l01825"></a><span class="lineno"> 1825</span>&#160;                                                                        axErr ) )</div>
<div class="line"><a name="l01826"></a><span class="lineno"> 1826</span>&#160;            {</div>
<div class="line"><a name="l01827"></a><span class="lineno"> 1827</span>&#160;                <span class="comment">//==================================== Almost identical entry</span></div>
<div class="line"><a name="l01828"></a><span class="lineno"> 1828</span>&#160;                <span class="keywordflow">if</span> ( axVec-&gt;at(symIt)[5] &lt; hlpSym[5] )</div>
<div class="line"><a name="l01829"></a><span class="lineno"> 1829</span>&#160;                {</div>
<div class="line"><a name="l01830"></a><span class="lineno"> 1830</span>&#160;                    <span class="comment">//================================ If higher, save</span></div>
<div class="line"><a name="l01831"></a><span class="lineno"> 1831</span>&#160;                    <span class="keyword">delete</span>[] axVec-&gt;at(symIt);</div>
<div class="line"><a name="l01832"></a><span class="lineno"> 1832</span>&#160;                    axVec-&gt;at(symIt)                  = hlpSym;</div>
<div class="line"><a name="l01833"></a><span class="lineno"> 1833</span>&#160;                    return ;</div>
<div class="line"><a name="l01834"></a><span class="lineno"> 1834</span>&#160;                }</div>
<div class="line"><a name="l01835"></a><span class="lineno"> 1835</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l01836"></a><span class="lineno"> 1836</span>&#160;                {</div>
<div class="line"><a name="l01837"></a><span class="lineno"> 1837</span>&#160;                    <span class="comment">//================================ or just terminate if better is already saved</span></div>
<div class="line"><a name="l01838"></a><span class="lineno"> 1838</span>&#160;                    <span class="keyword">delete</span>[] hlpSym;</div>
<div class="line"><a name="l01839"></a><span class="lineno"> 1839</span>&#160;                    return ;</div>
<div class="line"><a name="l01840"></a><span class="lineno"> 1840</span>&#160;                }</div>
<div class="line"><a name="l01841"></a><span class="lineno"> 1841</span>&#160;            }</div>
<div class="line"><a name="l01842"></a><span class="lineno"> 1842</span>&#160;        }</div>
<div class="line"><a name="l01843"></a><span class="lineno"> 1843</span>&#160;    }</div>
<div class="line"><a name="l01844"></a><span class="lineno"> 1844</span>&#160;    </div>
<div class="line"><a name="l01845"></a><span class="lineno"> 1845</span>&#160;    <span class="comment">//================================================ Not matched to anything</span></div>
<div class="line"><a name="l01846"></a><span class="lineno"> 1846</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a>         ( axVec, hlpSym );</div>
<div class="line"><a name="l01847"></a><span class="lineno"> 1847</span>&#160;    </div>
<div class="line"><a name="l01848"></a><span class="lineno"> 1848</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01849"></a><span class="lineno"> 1849</span>&#160;    return ;</div>
<div class="line"><a name="l01850"></a><span class="lineno"> 1850</span>&#160;    </div>
<div class="line"><a name="l01851"></a><span class="lineno"> 1851</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1ada2416687dbb0bec93603770cb4c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ada2416687dbb0bec93603770cb4c83">&#9670;&nbsp;</a></span>searchMissingSymmetrySpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::searchMissingSymmetrySpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>hlpVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tests feasible axes against the missing axis criteria, returning a set of matching axes. </p>
<p>This function does the real missing axis searching. It starts by taking all supplied axes and algebraically computing the vector which has the required angle to two of the supplied axes. This computed axis is then tested against the group for being unique and having an average height at least as high as required. If such axis is found, it is added to the axes list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataObj</td><td>The full data holding object pointer - this is to get access to self-rotation function values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>A vector of indices (relating to CSymList) of the group members. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hlpVec</td><td>A vector which will hold the detected, but not verified axes to be returned to the caller function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle</td><td>The angle that each group member is required to have against the symmetry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fold</td><td>The fold of the searched for axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum new axis average peak height in order for the axis to be added. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01867">1867</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01868"></a><span class="lineno"> 1868</span>&#160;{</div>
<div class="line"><a name="l01869"></a><span class="lineno"> 1869</span>&#160;    <span class="comment">//================================================ Sanity check</span></div>
<div class="line"><a name="l01870"></a><span class="lineno"> 1870</span>&#160;    <span class="keywordflow">if</span> ( grp-&gt;size() &lt; 2 ) { <span class="keywordflow">return</span>; }</div>
<div class="line"><a name="l01871"></a><span class="lineno"> 1871</span>&#160;    </div>
<div class="line"><a name="l01872"></a><span class="lineno"> 1872</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l01873"></a><span class="lineno"> 1873</span>&#160;    proshade_double axHeight                          = 0.0;</div>
<div class="line"><a name="l01874"></a><span class="lineno"> 1874</span>&#160;    proshade_double* symHlp                           = <span class="keyword">new</span> proshade_double[6];</div>
<div class="line"><a name="l01875"></a><span class="lineno"> 1875</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( symHlp, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l01876"></a><span class="lineno"> 1876</span>&#160;    </div>
<div class="line"><a name="l01877"></a><span class="lineno"> 1877</span>&#160;    <span class="comment">//================================================ For each axis pair in the group, find the possible solutions</span></div>
<div class="line"><a name="l01878"></a><span class="lineno"> 1878</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign fAx = 0; fAx &lt; static_cast&lt;proshade_unsign&gt; ( grp-&gt;size() ); fAx++ )</div>
<div class="line"><a name="l01879"></a><span class="lineno"> 1879</span>&#160;    {</div>
<div class="line"><a name="l01880"></a><span class="lineno"> 1880</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign sAx = 1; sAx &lt; static_cast&lt;proshade_unsign&gt; ( grp-&gt;size() ); sAx++ )</div>
<div class="line"><a name="l01881"></a><span class="lineno"> 1881</span>&#160;        {</div>
<div class="line"><a name="l01882"></a><span class="lineno"> 1882</span>&#160;            <span class="comment">//======================================== Only unique pairs</span></div>
<div class="line"><a name="l01883"></a><span class="lineno"> 1883</span>&#160;            <span class="keywordflow">if</span> ( fAx &gt;= sAx ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l01884"></a><span class="lineno"> 1884</span>&#160;            </div>
<div class="line"><a name="l01885"></a><span class="lineno"> 1885</span>&#160;            <span class="comment">//======================================== Find possible axis having the required angle to this pair ( solution 1 )</span></div>
<div class="line"><a name="l01886"></a><span class="lineno"> 1886</span>&#160;            std::vector&lt; proshade_double &gt; solVec     = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a45fbcfaeaabf9bae2fbd7d46a5fb4bc7">ProSHADE_internal_maths::findVectorFromTwoVAndTwoD</a> ( CSymList-&gt;at(grp-&gt;at(fAx))[1],</div>
<div class="line"><a name="l01887"></a><span class="lineno"> 1887</span>&#160;                                                                                                             CSymList-&gt;at(grp-&gt;at(fAx))[2],</div>
<div class="line"><a name="l01888"></a><span class="lineno"> 1888</span>&#160;                                                                                                             CSymList-&gt;at(grp-&gt;at(fAx))[3],</div>
<div class="line"><a name="l01889"></a><span class="lineno"> 1889</span>&#160;                                                                                                             CSymList-&gt;at(grp-&gt;at(sAx))[1],</div>
<div class="line"><a name="l01890"></a><span class="lineno"> 1890</span>&#160;                                                                                                             CSymList-&gt;at(grp-&gt;at(sAx))[2],</div>
<div class="line"><a name="l01891"></a><span class="lineno"> 1891</span>&#160;                                                                                                             CSymList-&gt;at(grp-&gt;at(sAx))[3], angle, angle );</div>
<div class="line"><a name="l01892"></a><span class="lineno"> 1892</span>&#160;            </div>
<div class="line"><a name="l01893"></a><span class="lineno"> 1893</span>&#160;            <span class="comment">//======================================== Set largest axis element to positive</span></div>
<div class="line"><a name="l01894"></a><span class="lineno"> 1894</span>&#160;            <span class="keywordflow">if</span> ( ( ( std::max ( std::abs ( solVec.at(0) ), std::max( std::abs ( solVec.at(1) ), std::abs ( solVec.at(2) ) ) ) == std::abs ( solVec.at(0) ) ) &amp;&amp; ( solVec.at(0) &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l01895"></a><span class="lineno"> 1895</span>&#160;                 ( ( std::max ( std::abs ( solVec.at(0) ), std::max( std::abs ( solVec.at(1) ), std::abs ( solVec.at(2) ) ) ) == std::abs ( solVec.at(1) ) ) &amp;&amp; ( solVec.at(1) &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l01896"></a><span class="lineno"> 1896</span>&#160;                 ( ( std::max ( std::abs ( solVec.at(0) ), std::max( std::abs ( solVec.at(1) ), std::abs ( solVec.at(2) ) ) ) == std::abs ( solVec.at(2) ) ) &amp;&amp; ( solVec.at(2) &lt; 0.0 ) ) )</div>
<div class="line"><a name="l01897"></a><span class="lineno"> 1897</span>&#160;            {</div>
<div class="line"><a name="l01898"></a><span class="lineno"> 1898</span>&#160;                solVec.at(0)                         *= -1.0;</div>
<div class="line"><a name="l01899"></a><span class="lineno"> 1899</span>&#160;                solVec.at(1)                         *= -1.0;</div>
<div class="line"><a name="l01900"></a><span class="lineno"> 1900</span>&#160;                solVec.at(2)                         *= -1.0;</div>
<div class="line"><a name="l01901"></a><span class="lineno"> 1901</span>&#160;            }</div>
<div class="line"><a name="l01902"></a><span class="lineno"> 1902</span>&#160;            </div>
<div class="line"><a name="l01903"></a><span class="lineno"> 1903</span>&#160;            <span class="comment">//======================================== Does the solution fit the whole group?</span></div>
<div class="line"><a name="l01904"></a><span class="lineno"> 1904</span>&#160;            symHlp[1] = solVec.at(0); symHlp[2] = solVec.at(1); symHlp[3] = solVec.at(2);</div>
<div class="line"><a name="l01905"></a><span class="lineno"> 1905</span>&#160;            <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad8c193e95c7069fafa78dccc1de1aaa4">ProSHADE_internal_symmetry::testGroupAgainstSymmetry</a> ( CSymList, grp, symHlp, axErr, angle, <span class="keyword">true</span> ) )</div>
<div class="line"><a name="l01906"></a><span class="lineno"> 1906</span>&#160;            {</div>
<div class="line"><a name="l01907"></a><span class="lineno"> 1907</span>&#160;                <span class="comment">//==================================== Find the height for the axis</span></div>
<div class="line"><a name="l01908"></a><span class="lineno"> 1908</span>&#160;                axHeight                              = <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad44ed609e8a3d59674b2b2256aec41f8">ProSHADE_internal_symmetry::missingAxisHeight</a> ( solVec.at(0), solVec.at(1), solVec.at(2), dataObj, fold, axErr );</div>
<div class="line"><a name="l01909"></a><span class="lineno"> 1909</span>&#160;                </div>
<div class="line"><a name="l01910"></a><span class="lineno"> 1910</span>&#160;                <span class="comment">//================================ Save max height result</span></div>
<div class="line"><a name="l01911"></a><span class="lineno"> 1911</span>&#160;                <span class="keywordflow">if</span> ( axHeight &gt;= minPeakHeight ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5dc4353223fc752e0007b2adec193079">ProSHADE_internal_symmetry::saveMissingAxisNewOnly</a> ( hlpVec, solVec.at(0), solVec.at(1), solVec.at(2), axHeight, fold, axErr ); }</div>
<div class="line"><a name="l01912"></a><span class="lineno"> 1912</span>&#160;            }</div>
<div class="line"><a name="l01913"></a><span class="lineno"> 1913</span>&#160;            </div>
<div class="line"><a name="l01914"></a><span class="lineno"> 1914</span>&#160;            <span class="comment">//======================================== Find possible axis having the required angle to this pair ( solution 2 )</span></div>
<div class="line"><a name="l01915"></a><span class="lineno"> 1915</span>&#160;            solVec                                    = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a45fbcfaeaabf9bae2fbd7d46a5fb4bc7">ProSHADE_internal_maths::findVectorFromTwoVAndTwoD</a> ( CSymList-&gt;at(grp-&gt;at(fAx))[1],</div>
<div class="line"><a name="l01916"></a><span class="lineno"> 1916</span>&#160;                                                                                                             CSymList-&gt;at(grp-&gt;at(fAx))[2],</div>
<div class="line"><a name="l01917"></a><span class="lineno"> 1917</span>&#160;                                                                                                             CSymList-&gt;at(grp-&gt;at(fAx))[3],</div>
<div class="line"><a name="l01918"></a><span class="lineno"> 1918</span>&#160;                                                                                                             CSymList-&gt;at(grp-&gt;at(sAx))[1],</div>
<div class="line"><a name="l01919"></a><span class="lineno"> 1919</span>&#160;                                                                                                             CSymList-&gt;at(grp-&gt;at(sAx))[2],</div>
<div class="line"><a name="l01920"></a><span class="lineno"> 1920</span>&#160;                                                                                                             CSymList-&gt;at(grp-&gt;at(sAx))[3], -angle, -angle );</div>
<div class="line"><a name="l01921"></a><span class="lineno"> 1921</span>&#160;            </div>
<div class="line"><a name="l01922"></a><span class="lineno"> 1922</span>&#160;            <span class="comment">//======================================== Set largest axis element to positive</span></div>
<div class="line"><a name="l01923"></a><span class="lineno"> 1923</span>&#160;            <span class="keywordflow">if</span> ( ( ( std::max ( std::abs ( solVec.at(0) ), std::max( std::abs ( solVec.at(1) ), std::abs ( solVec.at(2) ) ) ) == std::abs ( solVec.at(0) ) ) &amp;&amp; ( solVec.at(0) &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l01924"></a><span class="lineno"> 1924</span>&#160;                 ( ( std::max ( std::abs ( solVec.at(0) ), std::max( std::abs ( solVec.at(1) ), std::abs ( solVec.at(2) ) ) ) == std::abs ( solVec.at(1) ) ) &amp;&amp; ( solVec.at(1) &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l01925"></a><span class="lineno"> 1925</span>&#160;                 ( ( std::max ( std::abs ( solVec.at(0) ), std::max( std::abs ( solVec.at(1) ), std::abs ( solVec.at(2) ) ) ) == std::abs ( solVec.at(2) ) ) &amp;&amp; ( solVec.at(2) &lt; 0.0 ) ) )</div>
<div class="line"><a name="l01926"></a><span class="lineno"> 1926</span>&#160;            {</div>
<div class="line"><a name="l01927"></a><span class="lineno"> 1927</span>&#160;                solVec.at(0)                         *= -1.0;</div>
<div class="line"><a name="l01928"></a><span class="lineno"> 1928</span>&#160;                solVec.at(1)                         *= -1.0;</div>
<div class="line"><a name="l01929"></a><span class="lineno"> 1929</span>&#160;                solVec.at(2)                         *= -1.0;</div>
<div class="line"><a name="l01930"></a><span class="lineno"> 1930</span>&#160;            }</div>
<div class="line"><a name="l01931"></a><span class="lineno"> 1931</span>&#160;            </div>
<div class="line"><a name="l01932"></a><span class="lineno"> 1932</span>&#160;            <span class="comment">//======================================== Does the solution fit the whole group?</span></div>
<div class="line"><a name="l01933"></a><span class="lineno"> 1933</span>&#160;            symHlp[1] = solVec.at(0); symHlp[2] = solVec.at(1); symHlp[3] = solVec.at(2);</div>
<div class="line"><a name="l01934"></a><span class="lineno"> 1934</span>&#160;            <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad8c193e95c7069fafa78dccc1de1aaa4">ProSHADE_internal_symmetry::testGroupAgainstSymmetry</a> ( CSymList, grp, symHlp, axErr, angle, <span class="keyword">true</span> ) )</div>
<div class="line"><a name="l01935"></a><span class="lineno"> 1935</span>&#160;            {</div>
<div class="line"><a name="l01936"></a><span class="lineno"> 1936</span>&#160;                <span class="comment">//==================================== Find the height for the axis</span></div>
<div class="line"><a name="l01937"></a><span class="lineno"> 1937</span>&#160;                axHeight                              = <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad44ed609e8a3d59674b2b2256aec41f8">ProSHADE_internal_symmetry::missingAxisHeight</a> ( solVec.at(0), solVec.at(1), solVec.at(2), dataObj, fold, axErr );</div>
<div class="line"><a name="l01938"></a><span class="lineno"> 1938</span>&#160;                </div>
<div class="line"><a name="l01939"></a><span class="lineno"> 1939</span>&#160;                <span class="comment">//================================ Save max height result</span></div>
<div class="line"><a name="l01940"></a><span class="lineno"> 1940</span>&#160;                <span class="keywordflow">if</span> ( axHeight &gt;= minPeakHeight ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5dc4353223fc752e0007b2adec193079">ProSHADE_internal_symmetry::saveMissingAxisNewOnly</a> ( hlpVec, solVec.at(0), solVec.at(1), solVec.at(2), axHeight, fold, axErr ); }</div>
<div class="line"><a name="l01941"></a><span class="lineno"> 1941</span>&#160;            }</div>
<div class="line"><a name="l01942"></a><span class="lineno"> 1942</span>&#160;        }</div>
<div class="line"><a name="l01943"></a><span class="lineno"> 1943</span>&#160;    }</div>
<div class="line"><a name="l01944"></a><span class="lineno"> 1944</span>&#160;    </div>
<div class="line"><a name="l01945"></a><span class="lineno"> 1945</span>&#160;    <span class="comment">//================================================ Release memory</span></div>
<div class="line"><a name="l01946"></a><span class="lineno"> 1946</span>&#160;    <span class="keyword">delete</span>[] symHlp;</div>
<div class="line"><a name="l01947"></a><span class="lineno"> 1947</span>&#160;    </div>
<div class="line"><a name="l01948"></a><span class="lineno"> 1948</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01949"></a><span class="lineno"> 1949</span>&#160;    return ;</div>
<div class="line"><a name="l01950"></a><span class="lineno"> 1950</span>&#160;    </div>
<div class="line"><a name="l01951"></a><span class="lineno"> 1951</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2b3fcf4dd97e677da27192cf63dbb678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3fcf4dd97e677da27192cf63dbb678">&#9670;&nbsp;</a></span>smallestDistanceBetweenAngles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_symmetry::smallestDistanceBetweenAngles </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt;&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt;&#160;</td>
          <td class="paramname"><em>peaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double &gt; *&#160;</td>
          <td class="paramname"><em>tried</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>dist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function finds the smallest distance between the rotation angles within a group. </p>
<p>This function is used to control the while loop in the <a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a648ddad98891a4d8a6af5187d994c5ec" title="This function searches the list of peaks for presence of cyclic symmetry.">findPeaksCSymmetry()</a> function. It has two outputs, the standard returned value is a boolean stating whether a new distance between group rotation angles was found; the second output is the distance itself, which is saved in the dist variable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>A single symmetry axis group indices to be printed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">peaks</td><td>The vector of all peaks from which the indices are drawn. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tried</td><td>A vector of doubles holding the already tried distances and group combinations, so that they would not be tried again. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dist</td><td>A pointer to the variable where the smallest distance (if found) will be saved. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>Bool whether a new distance was found. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00551">551</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;{</div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;    <span class="keywordtype">bool</span> ret                                          = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;    <span class="keywordtype">bool</span> skip                                         = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;    proshade_unsign g1 = 0, g2 = 0;</div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;   *dist                                              = 999.9;</div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;    </div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;    <span class="comment">//================================================ For each group pair</span></div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign gr1It = 0; gr1It &lt; static_cast&lt;proshade_unsign&gt; ( grp.size() ); gr1It++ )</div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;    {</div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign gr2It = 1; gr2It &lt; static_cast&lt;proshade_unsign&gt; ( grp.size() ); gr2It++ )</div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;        {</div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;            <span class="comment">//======================================== Unique pairs only</span></div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;            <span class="keywordflow">if</span> ( gr1It &gt;= gr2It ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;            </div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;            <span class="comment">//======================================== Have we tried this already?</span></div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;            skip                                      = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;            <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; static_cast&lt;proshade_unsign&gt; ( tried-&gt;size() ); iter += 3 )</div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;            {</div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;                <span class="comment">//==================================== Avoid already tested combinations</span></div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;                <span class="keywordflow">if</span> ( ( gr2It == tried-&gt;at( iter + 1 ) ) &amp;&amp; ( gr1It == tried-&gt;at( iter ) ) ) { skip = <span class="keyword">true</span>; }</div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;                </div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;                <span class="comment">//==================================== Also avoid distances very close to already tested  distances (no problem until approx C700)</span></div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;                <span class="keywordflow">if</span> ( !skip &amp;&amp;</div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;                     ( ( std::abs( std::abs ( peaks.at(grp.at(gr1It))[3] ) - std::abs ( peaks.at(grp.at(gr2It))[3] ) ) - 0.01 ) &lt; tried-&gt;at( iter + 2 ) ) &amp;&amp;</div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;                     ( ( std::abs( std::abs ( peaks.at(grp.at(gr1It))[3] ) - std::abs ( peaks.at(grp.at(gr2It))[3] ) ) + 0.01 ) &gt; tried-&gt;at( iter + 2 ) ) )</div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;                {</div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;                    skip                              = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;                }</div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;            }</div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;            <span class="keywordflow">if</span> ( skip ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;            </div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;            <span class="comment">//======================================== Is this the smallest distance?</span></div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;            <span class="keywordflow">if</span> ( std::abs( std::abs ( peaks.at(grp.at(gr1It))[3] ) - std::abs ( peaks.at(grp.at(gr2It))[3] ) ) &lt; (*dist) )</div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;            {</div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;                <span class="comment">//==================================== Avoid very small angle distances as they would just take time (the hardcoded value would only be a problem for C700 and larger symmetries...</span></div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;                <span class="keywordflow">if</span> ( std::abs( std::abs ( peaks.at(grp.at(gr1It))[3] ) - std::abs ( peaks.at(grp.at(gr2It))[3] ) ) &gt; 0.01 )</div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;                {</div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;                    g1                                = gr1It;</div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;                    g2                                = gr2It;</div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;                   *dist                              = std::abs( std::abs ( peaks.at(grp.at(gr1It))[3] ) - std::abs ( peaks.at(grp.at(gr2It))[3] ) );</div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;                }</div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;            }</div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;        }</div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;    }</div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;    </div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;    <span class="comment">//================================================ If new dist found, save to tried and return success</span></div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;    <span class="keywordflow">if</span> ( *dist != 999.9 )</div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;    {</div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;        ret                                           = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a>     ( tried, g1 );</div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a>     ( tried, g2 );</div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a>     ( tried, *dist );</div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;    }</div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;    </div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;    <span class="keywordflow">return</span>                                            ( ret );</div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160; </div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a68d576f90449b7d3fcf5ae4d3114c268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d576f90449b7d3fcf5ae4d3114c268">&#9670;&nbsp;</a></span>sortArrVecHlp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_symmetry::sortArrVecHlp </td>
          <td>(</td>
          <td class="paramtype">const proshade_double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const proshade_double *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function compares two arrays of two based on the first number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first array to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second array to compare. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>Boolean whether the first is smaller than the second. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01642">1642</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01643"></a><span class="lineno"> 1643</span>&#160;{</div>
<div class="line"><a name="l01644"></a><span class="lineno"> 1644</span>&#160;    <span class="comment">//================================================ Compare</span></div>
<div class="line"><a name="l01645"></a><span class="lineno"> 1645</span>&#160;    <span class="keywordflow">return</span>                                            ( a[0] &lt; b[0] );</div>
<div class="line"><a name="l01646"></a><span class="lineno"> 1646</span>&#160;    </div>
<div class="line"><a name="l01647"></a><span class="lineno"> 1647</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5360c152697780177eb2676888cd5108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5360c152697780177eb2676888cd5108">&#9670;&nbsp;</a></span>testGroupAgainstGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_symmetry::testGroupAgainstGroup </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>GrList1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>grp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>GrList2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>grp2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function compares two groups of axes for a single pair having the required angle. </p>
<p>This simple helper function takes two sets of symmetry axes and two vectors of indices, each relating to one of the two sets. It then proceeds to check each of the indexed axes in each set against all the indexed axes in the other set, searching for a particular angle. If this angle is found for at least one pair, true is returned, while otherwise false is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">GrList1</td><td>A vector containing the symmetries for the group 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grp1</td><td>The indices respective to GrList1 which form group 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">GrList2</td><td>A vector containing the symmetries for the group 2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grp2</td><td>The indices respective to GrList1 which form group 2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle</td><td>The angle which needs to be found between any pair of axes in group 1 and 2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>True if succeeded, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l02050">2050</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02051"></a><span class="lineno"> 2051</span>&#160;{</div>
<div class="line"><a name="l02052"></a><span class="lineno"> 2052</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l02053"></a><span class="lineno"> 2053</span>&#160;    <span class="keywordtype">bool</span> ret                                          = <span class="keyword">false</span>;</div>
<div class="line"><a name="l02054"></a><span class="lineno"> 2054</span>&#160;    proshade_double dotProduct;</div>
<div class="line"><a name="l02055"></a><span class="lineno"> 2055</span>&#160;    </div>
<div class="line"><a name="l02056"></a><span class="lineno"> 2056</span>&#160;    <span class="comment">//================================================ For all pairs of axes</span></div>
<div class="line"><a name="l02057"></a><span class="lineno"> 2057</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign g1It = 0; g1It &lt; static_cast&lt;proshade_unsign&gt; ( grp1-&gt;size() ); g1It++ )</div>
<div class="line"><a name="l02058"></a><span class="lineno"> 2058</span>&#160;    {</div>
<div class="line"><a name="l02059"></a><span class="lineno"> 2059</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign g2It = 0; g2It &lt; static_cast&lt;proshade_unsign&gt; ( grp2-&gt;size() ); g2It++ )</div>
<div class="line"><a name="l02060"></a><span class="lineno"> 2060</span>&#160;        {</div>
<div class="line"><a name="l02061"></a><span class="lineno"> 2061</span>&#160;            <span class="comment">//======================================== Find the angle</span></div>
<div class="line"><a name="l02062"></a><span class="lineno"> 2062</span>&#160;            dotProduct                                = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> ( &amp;GrList1-&gt;at(grp1-&gt;at(g1It))[1],</div>
<div class="line"><a name="l02063"></a><span class="lineno"> 2063</span>&#160;                                                                                                     &amp;GrList1-&gt;at(grp1-&gt;at(g1It))[2],</div>
<div class="line"><a name="l02064"></a><span class="lineno"> 2064</span>&#160;                                                                                                     &amp;GrList1-&gt;at(grp1-&gt;at(g1It))[3],</div>
<div class="line"><a name="l02065"></a><span class="lineno"> 2065</span>&#160;                                                                                                     &amp;GrList2-&gt;at(grp2-&gt;at(g2It))[1],</div>
<div class="line"><a name="l02066"></a><span class="lineno"> 2066</span>&#160;                                                                                                     &amp;GrList2-&gt;at(grp2-&gt;at(g2It))[2],</div>
<div class="line"><a name="l02067"></a><span class="lineno"> 2067</span>&#160;                                                                                                     &amp;GrList2-&gt;at(grp2-&gt;at(g2It))[3] );</div>
<div class="line"><a name="l02068"></a><span class="lineno"> 2068</span>&#160;            </div>
<div class="line"><a name="l02069"></a><span class="lineno"> 2069</span>&#160;            <span class="comment">//======================================== Check the angle</span></div>
<div class="line"><a name="l02070"></a><span class="lineno"> 2070</span>&#160;            <span class="keywordflow">if</span> ( ( angle &gt; ( dotProduct - axErr ) ) &amp;&amp; ( angle &lt; ( dotProduct + axErr ) ) )</div>
<div class="line"><a name="l02071"></a><span class="lineno"> 2071</span>&#160;            {</div>
<div class="line"><a name="l02072"></a><span class="lineno"> 2072</span>&#160;                ret                                   = <span class="keyword">true</span>;</div>
<div class="line"><a name="l02073"></a><span class="lineno"> 2073</span>&#160;                <span class="keywordflow">return</span>                                ( ret );</div>
<div class="line"><a name="l02074"></a><span class="lineno"> 2074</span>&#160;            }</div>
<div class="line"><a name="l02075"></a><span class="lineno"> 2075</span>&#160;        }</div>
<div class="line"><a name="l02076"></a><span class="lineno"> 2076</span>&#160;    }</div>
<div class="line"><a name="l02077"></a><span class="lineno"> 2077</span>&#160;    </div>
<div class="line"><a name="l02078"></a><span class="lineno"> 2078</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l02079"></a><span class="lineno"> 2079</span>&#160;    <span class="keywordflow">return</span>                                            ( ret );</div>
<div class="line"><a name="l02080"></a><span class="lineno"> 2080</span>&#160;    </div>
<div class="line"><a name="l02081"></a><span class="lineno"> 2081</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad8c193e95c7069fafa78dccc1de1aaa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c193e95c7069fafa78dccc1de1aaa4">&#9670;&nbsp;</a></span>testGroupAgainstSymmetry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_symmetry::testGroupAgainstSymmetry </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>improve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tests whether a symmetry has particular angle to all members of a group. </p>
<p>This utility function tests if a sinlge symmetry axis has a given angle to all member of a particular symmetry group as given by the vector of indices and a vector of all symmetries. If the improve parameter is true, that it will also check for the tested axis for being parallel to any of the group axes while having higher average peak height - and in such cases, the function will replace the existing axis with the tested axis index as given in the pos argument. This utility is useful when searching for all axes of polyhedral symmetry groups.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>A vector of indices (relating to CSymList) of the group members. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sym</td><td>A double pointer to array containing the symmetry to be tested against the group. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle</td><td>The angle that each group member is required to have against the symmetry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">improve</td><td>Boolead value stating whether an axis with higher average height should be used instead of equal axis with lower average height, if such axis is found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>This is the CSymList index of the axis tested against the group. It will be used if improve = true to change the grp entry which is identical, but has lower height. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>Boolean value speciying whether all group members have the angle to the symmetry or not. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01515">1515</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01516"></a><span class="lineno"> 1516</span>&#160;{</div>
<div class="line"><a name="l01517"></a><span class="lineno"> 1517</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l01518"></a><span class="lineno"> 1518</span>&#160;    <span class="keywordtype">bool</span> allAnglesMet                                 = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01519"></a><span class="lineno"> 1519</span>&#160;    proshade_double dotProduct;</div>
<div class="line"><a name="l01520"></a><span class="lineno"> 1520</span>&#160;    </div>
<div class="line"><a name="l01521"></a><span class="lineno"> 1521</span>&#160;    <span class="comment">//================================================ Improve if required</span></div>
<div class="line"><a name="l01522"></a><span class="lineno"> 1522</span>&#160;    <span class="keywordflow">if</span> ( improve )</div>
<div class="line"><a name="l01523"></a><span class="lineno"> 1523</span>&#160;    {</div>
<div class="line"><a name="l01524"></a><span class="lineno"> 1524</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign mIt = 0; mIt &lt; static_cast&lt;proshade_unsign&gt; ( grp-&gt;size() ); mIt++ )</div>
<div class="line"><a name="l01525"></a><span class="lineno"> 1525</span>&#160;        {</div>
<div class="line"><a name="l01526"></a><span class="lineno"> 1526</span>&#160;            dotProduct                                = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> ( &amp;CSymList-&gt;at(grp-&gt;at(mIt))[1], &amp;CSymList-&gt;at(grp-&gt;at(mIt))[2], &amp;CSymList-&gt;at(grp-&gt;at(mIt))[3], &amp;sym[1], &amp;sym[2], &amp;sym[3] );</div>
<div class="line"><a name="l01527"></a><span class="lineno"> 1527</span>&#160;            </div>
<div class="line"><a name="l01528"></a><span class="lineno"> 1528</span>&#160;            <span class="keywordflow">if</span> ( ( ( 1.0 &gt; ( dotProduct - axErr ) ) &amp;&amp; ( 1.0 &lt; ( dotProduct + axErr ) ) ) || ( ( -1.0 &gt; ( dotProduct - axErr ) ) &amp;&amp; ( -1.0 &lt; ( dotProduct + axErr ) ) ) )</div>
<div class="line"><a name="l01529"></a><span class="lineno"> 1529</span>&#160;            {</div>
<div class="line"><a name="l01530"></a><span class="lineno"> 1530</span>&#160;                <span class="keywordflow">if</span> ( sym[5] &gt; CSymList-&gt;at(grp-&gt;at(mIt))[5] )</div>
<div class="line"><a name="l01531"></a><span class="lineno"> 1531</span>&#160;                {</div>
<div class="line"><a name="l01532"></a><span class="lineno"> 1532</span>&#160;                    grp-&gt;at(mIt)                      = pos;</div>
<div class="line"><a name="l01533"></a><span class="lineno"> 1533</span>&#160;                }</div>
<div class="line"><a name="l01534"></a><span class="lineno"> 1534</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l01535"></a><span class="lineno"> 1535</span>&#160;                {</div>
<div class="line"><a name="l01536"></a><span class="lineno"> 1536</span>&#160;                    allAnglesMet                      = <span class="keyword">false</span>;</div>
<div class="line"><a name="l01537"></a><span class="lineno"> 1537</span>&#160;                    <span class="keywordflow">return</span>                            ( allAnglesMet );</div>
<div class="line"><a name="l01538"></a><span class="lineno"> 1538</span>&#160;                }</div>
<div class="line"><a name="l01539"></a><span class="lineno"> 1539</span>&#160;            }</div>
<div class="line"><a name="l01540"></a><span class="lineno"> 1540</span>&#160;        }</div>
<div class="line"><a name="l01541"></a><span class="lineno"> 1541</span>&#160;    }</div>
<div class="line"><a name="l01542"></a><span class="lineno"> 1542</span>&#160;    </div>
<div class="line"><a name="l01543"></a><span class="lineno"> 1543</span>&#160;    <span class="comment">//================================================ For all group members</span></div>
<div class="line"><a name="l01544"></a><span class="lineno"> 1544</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign mIt = 0; mIt &lt; static_cast&lt;proshade_unsign&gt; ( grp-&gt;size() ); mIt++ )</div>
<div class="line"><a name="l01545"></a><span class="lineno"> 1545</span>&#160;    {</div>
<div class="line"><a name="l01546"></a><span class="lineno"> 1546</span>&#160;        dotProduct                                    = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> ( &amp;CSymList-&gt;at(grp-&gt;at(mIt))[1], &amp;CSymList-&gt;at(grp-&gt;at(mIt))[2], &amp;CSymList-&gt;at(grp-&gt;at(mIt))[3], &amp;sym[1], &amp;sym[2], &amp;sym[3] );</div>
<div class="line"><a name="l01547"></a><span class="lineno"> 1547</span>&#160;        </div>
<div class="line"><a name="l01548"></a><span class="lineno"> 1548</span>&#160;        <span class="keywordflow">if</span> ( ( angle &gt; ( std::abs ( dotProduct ) - axErr ) ) &amp;&amp;</div>
<div class="line"><a name="l01549"></a><span class="lineno"> 1549</span>&#160;             ( angle &lt; ( std::abs ( dotProduct ) + axErr ) ) )</div>
<div class="line"><a name="l01550"></a><span class="lineno"> 1550</span>&#160;        {</div>
<div class="line"><a name="l01551"></a><span class="lineno"> 1551</span>&#160;            <span class="comment">//======================================== Matching group memner - try next one</span></div>
<div class="line"><a name="l01552"></a><span class="lineno"> 1552</span>&#160;        }</div>
<div class="line"><a name="l01553"></a><span class="lineno"> 1553</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l01554"></a><span class="lineno"> 1554</span>&#160;        {</div>
<div class="line"><a name="l01555"></a><span class="lineno"> 1555</span>&#160;            <span class="comment">//======================================== Group member not matched - try next group</span></div>
<div class="line"><a name="l01556"></a><span class="lineno"> 1556</span>&#160;            allAnglesMet                              = <span class="keyword">false</span>;</div>
<div class="line"><a name="l01557"></a><span class="lineno"> 1557</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l01558"></a><span class="lineno"> 1558</span>&#160;        }</div>
<div class="line"><a name="l01559"></a><span class="lineno"> 1559</span>&#160;    }</div>
<div class="line"><a name="l01560"></a><span class="lineno"> 1560</span>&#160;    </div>
<div class="line"><a name="l01561"></a><span class="lineno"> 1561</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01562"></a><span class="lineno"> 1562</span>&#160;    <span class="keywordflow">return</span>                                           ( allAnglesMet );</div>
<div class="line"><a name="l01563"></a><span class="lineno"> 1563</span>&#160;    </div>
<div class="line"><a name="l01564"></a><span class="lineno"> 1564</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data_html_aec8b3ae9e7ccaeaa8abeda92571a1d50"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#aec8b3ae9e7ccaeaa8abeda92571a1d50">ProSHADE_internal_data::ProSHADE_data::optimiseDihedralAngleFromAngleAxis</a></div><div class="ttdeci">std::vector&lt; proshade_double * &gt; optimiseDihedralAngleFromAngleAxis(ProSHADE_settings *settings, proshade_double angle, proshade_double *axis1, proshade_double *axis2)</div><div class="ttdoc">...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l03822">ProSHADE_symmetry.cpp:3822</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_ae9f376bb341b192fff008b9b4ef5c603"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#ae9f376bb341b192fff008b9b4ef5c603">ProSHADE_internal_maths::findVectorFromThreeVAndThreeD</a></div><div class="ttdeci">std::vector&lt; proshade_double &gt; findVectorFromThreeVAndThreeD(proshade_double x1, proshade_double y1, proshade_double z1, proshade_double x2, proshade_double y2, proshade_double z2, proshade_double x3, proshade_double y3, proshade_double z3, proshade_double dot1, proshade_double dot2, proshade_double dot3)</div><div class="ttdoc">Function for finding a vector which would have a given three dot products to three other vectors.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01885">ProSHADE_maths.cpp:1885</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_af4f982fc282e8fca11b6a85f2d2069a5"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af4f982fc282e8fca11b6a85f2d2069a5">ProSHADE_internal_symmetry::findExpectedPeakRotations</a></div><div class="ttdeci">void findExpectedPeakRotations(proshade_unsign fold, std::vector&lt; proshade_double &gt; *expAngs)</div><div class="ttdoc">This function computes the expected peak rotations for given fold.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00705">ProSHADE_symmetry.cpp:705</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__misc_html_ad14d6427df4269728627fcd880abaf31"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__misc.html#ad14d6427df4269728627fcd880abaf31">ProSHADE_internal_misc::sortSymInvFoldHlp</a></div><div class="ttdeci">bool sortSymInvFoldHlp(const proshade_double *a, const proshade_double *b)</div><div class="ttdoc">This function compares two arrays of two based on the first number, sorting highest first.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__misc_8cpp_source.html#l00273">ProSHADE_misc.cpp:273</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_af6093da290ce7b73a33e8b55f2c83491"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af6093da290ce7b73a33e8b55f2c83491">ProSHADE_internal_symmetry::findMissingAxes</a></div><div class="ttdeci">bool findMissingAxes(std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; *possibilities, std::vector&lt; proshade_double * &gt; *CSymList, proshade_unsign requiredNoAxes, proshade_double axErr, proshade_double angle, proshade_unsign fold, ProSHADE_internal_data::ProSHADE_data *dataObj, proshade_double minPeakHeight)</div><div class="ttdoc">This function tries to find an axis which would complete a particular group of axes for polyhedral sy...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01582">ProSHADE_symmetry.cpp:1582</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__misc_html_aa3103c7b5e2dc2cbf1778705c7693334"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a></div><div class="ttdeci">void addToDblPtrVector(std::vector&lt; proshade_double * &gt; *vecToAddTo, proshade_double *elementToAdd)</div><div class="ttdoc">Adds the element to the vector.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__misc_8cpp_source.html#l00143">ProSHADE_misc.cpp:143</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_a98538547e5bcc6192bbbea1d7b51c537"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a98538547e5bcc6192bbbea1d7b51c537">ProSHADE_internal_symmetry::groupSameAxes</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; groupSameAxes(std::vector&lt; proshade_double * &gt; &amp;peaks, proshade_double errTolerance)</div><div class="ttdoc">This function groups the peaks by their axes of rotation.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00419">ProSHADE_symmetry.cpp:419</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__data_html_ac2cdde3bc58869b04f1aa39aee9b01bc"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__data.html#ac2cdde3bc58869b04f1aa39aee9b01bc">ProSHADE_internal_data::joinElementsFromDifferentGroups</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; proshade_double &gt; &gt; joinElementsFromDifferentGroups(std::vector&lt; std::vector&lt; proshade_double &gt; &gt; *first, std::vector&lt; std::vector&lt; proshade_double &gt; &gt; *second, proshade_double matrixTolerance, bool combine)</div><div class="ttdoc">This function joins two group element lists using only unique elements.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__data_8cpp_source.html#l02486">ProSHADE_data.cpp:2486</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_a68d576f90449b7d3fcf5ae4d3114c268"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a68d576f90449b7d3fcf5ae4d3114c268">ProSHADE_internal_symmetry::sortArrVecHlp</a></div><div class="ttdeci">bool sortArrVecHlp(const proshade_double *a, const proshade_double *b)</div><div class="ttdoc">This function compares two arrays of two based on the first number.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01642">ProSHADE_symmetry.cpp:1642</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_ad56b16f741c8701d43f8f74899c8ab2c"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad56b16f741c8701d43f8f74899c8ab2c">ProSHADE_internal_symmetry::addAxisUnlessSame</a></div><div class="ttdeci">void addAxisUnlessSame(proshade_unsign fold, proshade_double axX, proshade_double axY, proshade_double axZ, proshade_double axHeight, std::vector&lt; proshade_double * &gt; *prosp, proshade_double axErr)</div><div class="ttdoc">This function simply creates a new axis from information in aruments and tests if no such axis alread...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l02527">ProSHADE_symmetry.cpp:2527</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_a2b3fcf4dd97e677da27192cf63dbb678"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a2b3fcf4dd97e677da27192cf63dbb678">ProSHADE_internal_symmetry::smallestDistanceBetweenAngles</a></div><div class="ttdeci">bool smallestDistanceBetweenAngles(std::vector&lt; proshade_unsign &gt; grp, std::vector&lt; proshade_double * &gt; peaks, std::vector&lt; proshade_double &gt; *tried, proshade_double *dist)</div><div class="ttdoc">This function finds the smallest distance between the rotation angles within a group.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00551">ProSHADE_symmetry.cpp:551</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a01087ea3e0db56758d1771618e2e4a45"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a01087ea3e0db56758d1771618e2e4a45">ProSHADE_internal_maths::normalDistributionValue</a></div><div class="ttdeci">proshade_double normalDistributionValue(proshade_double mean, proshade_double standardDev, proshade_double value)</div><div class="ttdoc">Function to the heiht of normal distribution given by mean and standard deviation for a given value.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01685">ProSHADE_maths.cpp:1685</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_abb4d85e82d1c55d0aa18795fea449adf"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#abb4d85e82d1c55d0aa18795fea449adf">ProSHADE_internal_symmetry::isSymmetrySame</a></div><div class="ttdeci">bool isSymmetrySame(std::vector&lt; proshade_double * &gt; *ret, proshade_double *sym, proshade_double simThres)</div><div class="ttdoc">This function checks if a very similar symmetry is not already saved.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01177">ProSHADE_symmetry.cpp:1177</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__misc_html_a86e2bb172f766ab4a620df482d2fe481"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__misc.html#a86e2bb172f766ab4a620df482d2fe481">ProSHADE_internal_misc::addToUnsignVectorVector</a></div><div class="ttdeci">void addToUnsignVectorVector(std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; *vecToAddTo, std::vector&lt; proshade_unsign &gt; elementToAdd)</div><div class="ttdoc">Adds the element to the vector of vectors.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__misc_8cpp_source.html#l00188">ProSHADE_misc.cpp:188</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_ad44ed609e8a3d59674b2b2256aec41f8"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad44ed609e8a3d59674b2b2256aec41f8">ProSHADE_internal_symmetry::missingAxisHeight</a></div><div class="ttdeci">proshade_double missingAxisHeight(proshade_double xVal, proshade_double yVal, proshade_double zVal, ProSHADE_internal_data::ProSHADE_data *dataObj, proshade_unsign fold, proshade_double axErr)</div><div class="ttdoc">This function searches for the highest peaks average that would produce the required axis and fold.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01663">ProSHADE_symmetry.cpp:1663</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_a1ada2416687dbb0bec93603770cb4c83"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a1ada2416687dbb0bec93603770cb4c83">ProSHADE_internal_symmetry::searchMissingSymmetrySpace</a></div><div class="ttdeci">void searchMissingSymmetrySpace(ProSHADE_internal_data::ProSHADE_data *dataObj, std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_unsign &gt; *grp, std::vector&lt; proshade_double * &gt; *hlpVec, proshade_double axErr, proshade_double angle, proshade_unsign fold, proshade_double minPeakHeight)</div><div class="ttdoc">This function tests feasible axes against the missing axis criteria, returning a set of matching axes...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01867">ProSHADE_symmetry.cpp:1867</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_a6d9f533a789bd5c6031fa77b9649ed3d"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a6d9f533a789bd5c6031fa77b9649ed3d">ProSHADE_internal_symmetry::findMissingAxesDual</a></div><div class="ttdeci">bool findMissingAxesDual(std::vector&lt; proshade_unsign &gt; *possibilities, std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, std::vector&lt; proshade_unsign &gt; *retGroup, proshade_unsign requiredNoAxes, proshade_double axErr, proshade_unsign noMatchesG1, proshade_double angle1, proshade_unsign noMatchesG2, proshade_double angle2, proshade_unsign fold, ProSHADE_internal_data::ProSHADE_data *dataObj)</div><div class="ttdoc">This function tries to find a particular symmetry axes which would complete a group of symmetries wit...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l02434">ProSHADE_symmetry.cpp:2434</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_abd9fe573a48f499dd7d1df4f779222f1"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#abd9fe573a48f499dd7d1df4f779222f1">ProSHADE_internal_maths::getRotationMatrixFromEulerZXZAngles</a></div><div class="ttdeci">void getRotationMatrixFromEulerZXZAngles(proshade_double eulerAlpha, proshade_double eulerBeta, proshade_double eulerGamma, proshade_double *matrix)</div><div class="ttdoc">Function to find the rotation matrix from Euler angles (ZXZ convention).</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01005">ProSHADE_maths.cpp:1005</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data_html_a4f4bb25b05f273a41bce8205f9058717"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a4f4bb25b05f273a41bce8205f9058717">ProSHADE_internal_data::ProSHADE_data::computeGroupElementsForGroup</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; proshade_double &gt; &gt; computeGroupElementsForGroup(std::vector&lt; std::vector&lt; proshade_double &gt; &gt; *allCSyms, proshade_unsign grPosition)</div><div class="ttdoc">This function computes the group elements as rotation matrices (except for the identity element) for ...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__data_8cpp_source.html#l02263">ProSHADE_data.cpp:2263</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_ade9b717260e86c8f24bcbe6d17fe4e06"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ade9b717260e86c8f24bcbe6d17fe4e06">ProSHADE_internal_symmetry::addZeroPeakToGroups</a></div><div class="ttdeci">void addZeroPeakToGroups(std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; &amp;grpsVec, std::vector&lt; proshade_double * &gt; &amp;peaks)</div><div class="ttdoc">This function takes the peak groups and adds zero peak to each of them.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00621">ProSHADE_symmetry.cpp:621</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__messages_html_addbb90f2b4199441f60e241ac850daa2"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__messages.html#addbb90f2b4199441f60e241ac850daa2">ProSHADE_internal_messages::printWarningMessage</a></div><div class="ttdeci">void printWarningMessage(proshade_signed verbose, std::string message, std::string warnCode)</div><div class="ttdoc">General stderr message printing (used for warnings).</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__messages_8cpp_source.html#l00101">ProSHADE_messages.cpp:101</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a2b2f67cba1eea57f19fdaf062db74fde"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2b2f67cba1eea57f19fdaf062db74fde">ProSHADE_internal_maths::vectorOrientationSimilarity</a></div><div class="ttdeci">bool vectorOrientationSimilarity(proshade_double a1, proshade_double a2, proshade_double a3, proshade_double b1, proshade_double b2, proshade_double b3, proshade_double tolerance=0.1)</div><div class="ttdoc">This function compares two vectors using cosine distance and decides if they are similar using tolera...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l02016">ProSHADE_maths.cpp:2016</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__misc_html_a68c3eafaeea1c1873c33525f337f9d0b"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a></div><div class="ttdeci">void addToDoubleVector(std::vector&lt; proshade_double &gt; *vecToAddTo, proshade_double elementToAdd)</div><div class="ttdoc">Adds the element to the vector.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__misc_8cpp_source.html#l00077">ProSHADE_misc.cpp:77</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_a074d9c1d40d7491ea9f9f9639744e18d"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a074d9c1d40d7491ea9f9f9639744e18d">ProSHADE_internal_symmetry::checkExpectedAgainstFound</a></div><div class="ttdeci">proshade_unsign checkExpectedAgainstFound(std::vector&lt; proshade_unsign &gt; grp, std::vector&lt; proshade_double * &gt; peaks, std::vector&lt; proshade_double &gt; *expAngs, std::vector&lt; proshade_unsign &gt; *matchedAngs, std::vector&lt; proshade_unsign &gt; *missingAngs, proshade_double axisTol)</div><div class="ttdoc">This function computes the expected peak rotations for given fold.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00734">ProSHADE_symmetry.cpp:734</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_a5dc4353223fc752e0007b2adec193079"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5dc4353223fc752e0007b2adec193079">ProSHADE_internal_symmetry::saveMissingAxisNewOnly</a></div><div class="ttdeci">void saveMissingAxisNewOnly(std::vector&lt; proshade_double * &gt; *axVec, proshade_double axX, proshade_double axY, proshade_double axZ, proshade_double height, proshade_unsign fold, proshade_double axErr)</div><div class="ttdoc">This function saves the recovered information about missing axis into a full symmetry,...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01799">ProSHADE_symmetry.cpp:1799</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a2ac3b534f974de25b092e9d48d9f7dea"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a></div><div class="ttdeci">proshade_double computeDotProduct(proshade_double *x1, proshade_double *y1, proshade_double *z1, proshade_double *x2, proshade_double *y2, proshade_double *z2)</div><div class="ttdoc">Simple 3D vector dot product computation.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01701">ProSHADE_maths.cpp:1701</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_ac03088b2929641cd6fc3e2e4e20d874b"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ac03088b2929641cd6fc3e2e4e20d874b">ProSHADE_internal_symmetry::findSymmetryUsingFold</a></div><div class="ttdeci">void findSymmetryUsingFold(ProSHADE_internal_data::ProSHADE_data *dataObj, std::vector&lt; proshade_unsign &gt; *angsToTry, std::vector&lt; proshade_unsign &gt; *grp, std::vector&lt; proshade_double * &gt; *peaks, std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; *ret, std::vector&lt; proshade_unsign &gt; *testedAlready, proshade_double axErrTolerance, bool axErrToleranceDefault, proshade_double missPeakThres, proshade_unsign verbose)</div><div class="ttdoc">This function tests all supplied folds for being supported by the peaks (i.e. and being complete pres...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00989">ProSHADE_symmetry.cpp:989</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__misc_html_aff0d8344fdd83482e5531eadedaac550"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__misc.html#aff0d8344fdd83482e5531eadedaac550">ProSHADE_internal_misc::deepCopyAxisToDblPtrVector</a></div><div class="ttdeci">void deepCopyAxisToDblPtrVector(std::vector&lt; proshade_double * &gt; *dblPtrVec, proshade_double *axis)</div><div class="ttdoc">Does a deep copy of a double array to a vector of double arrays.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__misc_8cpp_source.html#l00287">ProSHADE_misc.cpp:287</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data_html_a152b43815a3d3debd4b60751d9c8afdd"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a152b43815a3d3debd4b60751d9c8afdd">ProSHADE_internal_data::ProSHADE_data::getMaxBand</a></div><div class="ttdeci">proshade_unsign getMaxBand(void)</div><div class="ttdoc">This function returns the maximum band value for the object.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__data_8cpp_source.html#l02986">ProSHADE_data.cpp:2986</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_a3008592c3ce58393395e03dac26c3626"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a3008592c3ce58393395e03dac26c3626">ProSHADE_internal_symmetry::completeMissingCSymmetry</a></div><div class="ttdeci">bool completeMissingCSymmetry(ProSHADE_internal_data::ProSHADE_data *dataObj, proshade_unsign fold, std::vector&lt; proshade_unsign &gt; *grp, std::vector&lt; proshade_double * &gt; *peaks, std::vector&lt; proshade_unsign &gt; *missingPeaks, std::vector&lt; proshade_double &gt; *expectedAngles, std::vector&lt; proshade_unsign &gt; *matchedPeaks, proshade_double axErrTolerance, proshade_unsign verbose)</div><div class="ttdoc">This function does the complete missing peak searching and filling in the missing peaks.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00924">ProSHADE_symmetry.cpp:924</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_a41150b2f8995b2ac1f144143fc83b6ee"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a41150b2f8995b2ac1f144143fc83b6ee">ProSHADE_internal_symmetry::giveOppositeAxesSameDirection</a></div><div class="ttdeci">void giveOppositeAxesSameDirection(std::vector&lt; proshade_double * &gt; peaks)</div><div class="ttdoc">This function modifiest the axes so that the highest vector element is always positive.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00491">ProSHADE_symmetry.cpp:491</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_af9835b91e354e4615beb79b5c2a674e9"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af9835b91e354e4615beb79b5c2a674e9">ProSHADE_internal_symmetry::printSymmetryPeaks</a></div><div class="ttdeci">void printSymmetryPeaks(std::vector&lt; proshade_unsign &gt; grp, std::vector&lt; proshade_double * &gt; peaks, proshade_signed verbose, proshade_unsign groupNo)</div><div class="ttdoc">This function simply prints the symmetry axis group supplied in the first parameter from the second p...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00518">ProSHADE_symmetry.cpp:518</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a2380a3710f7dbe672519c3adda30f7cd"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2380a3710f7dbe672519c3adda30f7cd">ProSHADE_internal_maths::isAxisUnique</a></div><div class="ttdeci">bool isAxisUnique(std::vector&lt; proshade_double * &gt; *CSymList, proshade_double *axis, proshade_double tolerance=0.1, bool improve=false)</div><div class="ttdoc">This function checks if new axis is unique, or already detected.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l02397">ProSHADE_maths.cpp:2397</a></div></div>
<div class="ttc" id="a_pro_s_h_a_d_e__symmetry_8cpp_html_a79ed59214fd3ab2bee9021cf1c7f3431"><div class="ttname"><a href="_pro_s_h_a_d_e__symmetry_8cpp.html#a79ed59214fd3ab2bee9021cf1c7f3431">findBestIcosDihedralPair</a></div><div class="ttdeci">std::pair&lt; proshade_unsign, proshade_unsign &gt; findBestIcosDihedralPair(std::vector&lt; proshade_double * &gt; *CSymList, proshade_double minPeakHeight, proshade_double axErr)</div><div class="ttdoc">This function finds the best pair of axes conforming to the icosahedron dihedral angle.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l02881">ProSHADE_symmetry.cpp:2881</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_ae266053664eb7cf916aa5e2d282e35dd"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ae266053664eb7cf916aa5e2d282e35dd">ProSHADE_internal_symmetry::findMissingAxesTriple</a></div><div class="ttdeci">bool findMissingAxesTriple(std::vector&lt; proshade_unsign &gt; *possibilities, std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, std::vector&lt; proshade_unsign &gt; *retGroup, proshade_unsign requiredNoAxes, proshade_double axErr, proshade_unsign noMatchesG1, proshade_double angle1, proshade_unsign noMatchesG2, proshade_double angle2, proshade_unsign noMatchesG3, proshade_double angle3, proshade_unsign fold, ProSHADE_internal_data::ProSHADE_data *dataObj)</div><div class="ttdoc">This function tries to find a particular symmetry axis which would complete a group of symmetries wit...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l03411">ProSHADE_symmetry.cpp:3411</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_aafc6f1626c7463de53c9f4f6fa11db22"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#aafc6f1626c7463de53c9f4f6fa11db22">ProSHADE_internal_maths::getAxisAngleFromRotationMatrix</a></div><div class="ttdeci">void getAxisAngleFromRotationMatrix(proshade_double *rotMat, proshade_double *x, proshade_double *y, proshade_double *z, proshade_double *ang)</div><div class="ttdoc">This function converts rotation matrix to the axis-angle representation.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01039">ProSHADE_maths.cpp:1039</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__map_manip_html_a50df80b02427f9f55a2c7af033a9fb93"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__map_manip.html#a50df80b02427f9f55a2c7af033a9fb93">ProSHADE_internal_mapManip::myRound</a></div><div class="ttdeci">proshade_signed myRound(proshade_double x)</div><div class="ttdoc">Calls the appropriate version of round function depending on compiler version.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__map_manip_8cpp_source.html#l00031">ProSHADE_mapManip.cpp:31</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_ad8c193e95c7069fafa78dccc1de1aaa4"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad8c193e95c7069fafa78dccc1de1aaa4">ProSHADE_internal_symmetry::testGroupAgainstSymmetry</a></div><div class="ttdeci">bool testGroupAgainstSymmetry(std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_unsign &gt; *grp, proshade_double *sym, proshade_double axErr, proshade_double angle, bool improve, proshade_unsign pos=0)</div><div class="ttdoc">This function tests whether a symmetry has particular angle to all members of a group.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01515">ProSHADE_symmetry.cpp:1515</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__misc_html_af556836aa9286c1571196de442a6b493"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a></div><div class="ttdeci">void checkMemoryAllocation(chVar checkVar, std::string fileP, unsigned int lineP, std::string funcP, std::string infoP=&quot;This error may occurs when ProSHADE requests memory to be\n                    : allocated to it and this operation fails. This could\n                    : happen when not enough memory is available, either due to\n                    : other processes using a lot of memory, or when the machine\n                    : does not have sufficient memory available. Re-run to see\n                    : if this problem persists.&quot;)</div><div class="ttdoc">Checks if memory was allocated properly.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__misc_8hpp_source.html#l00065">ProSHADE_misc.hpp:65</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_a5dda335a87d6c26edfd3cf2a29ff7f1f"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5dda335a87d6c26edfd3cf2a29ff7f1f">ProSHADE_internal_symmetry::saveDetectedCSymmetry</a></div><div class="ttdeci">void saveDetectedCSymmetry(proshade_unsign fold, std::vector&lt; proshade_unsign &gt; *matchedPeaks, std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; *ret, proshade_signed verbose)</div><div class="ttdoc">This function saves a detected symmetry for reporting to the user.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00884">ProSHADE_symmetry.cpp:884</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_acf6c5376edac98e54ef0e418cd05d706"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#acf6c5376edac98e54ef0e418cd05d706">ProSHADE_internal_maths::getEulerZXZFromSOFTPosition</a></div><div class="ttdeci">void getEulerZXZFromSOFTPosition(proshade_signed band, proshade_signed x, proshade_signed y, proshade_signed z, proshade_double *eulerAlpha, proshade_double *eulerBeta, proshade_double *eulerGamma)</div><div class="ttdoc">Function to find Euler angles (ZXZ convention) from index position in the inverse SOFT map.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00961">ProSHADE_maths.cpp:961</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_aacced7feb8ce5251dce199505912d997"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#aacced7feb8ce5251dce199505912d997">ProSHADE_internal_symmetry::checkForMissingPeak</a></div><div class="ttdeci">proshade_double checkForMissingPeak(ProSHADE_internal_data::ProSHADE_data *dataObj, proshade_double x, proshade_double y, proshade_double z, proshade_double angle, proshade_double heightThres, proshade_double axTol)</div><div class="ttdoc">This function checks for the high of the correlation for particular rotation angle and axis.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00816">ProSHADE_symmetry.cpp:816</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data_html_a2eb10989a2f8d46b849cdaf8410b68be"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a2eb10989a2f8d46b849cdaf8410b68be">ProSHADE_internal_data::ProSHADE_data::getInvSO3Coeffs</a></div><div class="ttdeci">proshade_complex * getInvSO3Coeffs(void)</div><div class="ttdoc">This function allows access to the inverse SO(3) coefficients array.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__data_8cpp_source.html#l03213">ProSHADE_data.cpp:3213</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__misc_html_a16336bdf0b391c953a549d3df115d691"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a></div><div class="ttdeci">void addToUnsignVector(std::vector&lt; proshade_unsign &gt; *vecToAddTo, proshade_unsign elementToAdd)</div><div class="ttdoc">Adds the element to the vector.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__misc_8cpp_source.html#l00099">ProSHADE_misc.cpp:99</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_a194944b48a4b6b523ef251a2a03eab17"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a194944b48a4b6b523ef251a2a03eab17">ProSHADE_internal_symmetry::checkFittingAxisTripleAndSave</a></div><div class="ttdeci">void checkFittingAxisTripleAndSave(std::vector&lt; proshade_unsign &gt; *retGroup, std::vector&lt; proshade_double * &gt; *ret, proshade_unsign fold, proshade_double axX, proshade_double axY, proshade_double axZ, std::vector&lt; proshade_double * &gt; *prosp, proshade_double axErr, proshade_unsign noMatchesG1, proshade_double angle1, proshade_unsign noMatchesG2, proshade_double angle2, proshade_unsign noMatchesG3, proshade_double angle3, ProSHADE_internal_data::ProSHADE_data *dataObj)</div><div class="ttdoc">This function takes a newly detected &quot;missing&quot; axis and tests it for belonging to the group,...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l03522">ProSHADE_symmetry.cpp:3522</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a45fbcfaeaabf9bae2fbd7d46a5fb4bc7"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a45fbcfaeaabf9bae2fbd7d46a5fb4bc7">ProSHADE_internal_maths::findVectorFromTwoVAndTwoD</a></div><div class="ttdeci">std::vector&lt; proshade_double &gt; findVectorFromTwoVAndTwoD(proshade_double x1, proshade_double y1, proshade_double z1, proshade_double x2, proshade_double y2, proshade_double z2, proshade_double dot1, proshade_double dot2)</div><div class="ttdoc">Function for finding a vector which would have a given two dot products to two other vectors.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01743">ProSHADE_maths.cpp:1743</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_ac0a8dc71c37de02256521ebc9178c8d4"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ac0a8dc71c37de02256521ebc9178c8d4">ProSHADE_internal_symmetry::determineFoldToTry</a></div><div class="ttdeci">bool determineFoldToTry(proshade_double dist, proshade_double *divBasis, proshade_double *divRem, proshade_double peakErr, proshade_double *symmErr, std::vector&lt; proshade_unsign &gt; *angsToTry)</div><div class="ttdoc">This function determines the symmetry fold to be searched for.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00658">ProSHADE_symmetry.cpp:658</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__messages_html_a6aa8cdb600cad623409802cfaed494fa"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__messages.html#a6aa8cdb600cad623409802cfaed494fa">ProSHADE_internal_messages::printProgressMessage</a></div><div class="ttdeci">void printProgressMessage(proshade_signed verbose, proshade_signed messageLevel, std::string message)</div><div class="ttdoc">General stdout message printing.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__messages_8cpp_source.html#l00070">ProSHADE_messages.cpp:70</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__misc_html_a2e915d310892aea124046acd14db4a84"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__misc.html#a2e915d310892aea124046acd14db4a84">ProSHADE_internal_misc::sortSymHlpInv</a></div><div class="ttdeci">bool sortSymHlpInv(const proshade_double *a, const proshade_double *b)</div><div class="ttdoc">This function compares two arrays of two based on the fifth number, sorting highest first.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__misc_8cpp_source.html#l00243">ProSHADE_misc.cpp:243</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_a210ee0af651d440b68168882ead71c66"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a210ee0af651d440b68168882ead71c66">ProSHADE_internal_symmetry::checkFittingAxisDualAndSave</a></div><div class="ttdeci">bool checkFittingAxisDualAndSave(std::vector&lt; proshade_unsign &gt; *retGroup, std::vector&lt; proshade_double * &gt; *ret, proshade_unsign fold, proshade_double axX, proshade_double axY, proshade_double axZ, std::vector&lt; proshade_double * &gt; *prosp, proshade_double axErr, proshade_unsign noMatchesG1, proshade_double angle1, proshade_unsign noMatchesG2, proshade_double angle2, ProSHADE_internal_data::ProSHADE_data *dataObj)</div><div class="ttdoc">This function takes a newly detected &quot;missing&quot; axis and tests it for belonging to the group,...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l02577">ProSHADE_symmetry.cpp:2577</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_a465606e58df7d6a2238d40c6919b2e58"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a465606e58df7d6a2238d40c6919b2e58">ProSHADE_internal_symmetry::findMissingAxisPoints</a></div><div class="ttdeci">std::vector&lt; proshade_double * &gt; findMissingAxisPoints(proshade_double xVal, proshade_double yVal, proshade_double zVal, ProSHADE_internal_data::ProSHADE_data *dataObj, proshade_double axErr)</div><div class="ttdoc">This function searches for all the self-rotation map points conforming to the axis,...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01725">ProSHADE_symmetry.cpp:1725</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html">ProSHADE_internal_symmetry</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
