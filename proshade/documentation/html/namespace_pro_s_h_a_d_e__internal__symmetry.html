<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ProSHADE: ProSHADE_internal_symmetry Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Logo_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ProSHADE
   &#160;<span id="projectnumber">0.7.6.2 (DEC 2021)</span>
   </div>
   <div id="projectbrief">Protein Shape Detection</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespace_pro_s_h_a_d_e__internal__symmetry.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ProSHADE_internal_symmetry Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This namespace contains the symmetry detection related code.  
<a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a262d9e21cd6b81b8bda35ec22eb363dd"><td class="memItemLeft" align="right" valign="top">proshade_signed&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a262d9e21cd6b81b8bda35ec22eb363dd">addAxisUnlessSame</a> (proshade_unsign fold, proshade_double axX, proshade_double axY, proshade_double axZ, proshade_double axHeight, proshade_double averageFSC, std::vector&lt; proshade_double * &gt; *prosp, proshade_double axErr)</td></tr>
<tr class="memdesc:a262d9e21cd6b81b8bda35ec22eb363dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function simply creates a new axis from information in aruments and tests if no such axis already exists, saving it if need be.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a262d9e21cd6b81b8bda35ec22eb363dd">More...</a><br /></td></tr>
<tr class="separator:a262d9e21cd6b81b8bda35ec22eb363dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad977c265833d6466598cceb406a085db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad977c265833d6466598cceb406a085db">isSymmetrySame</a> (std::vector&lt; proshade_double * &gt; *ret, proshade_double *sym, proshade_double simThres, proshade_signed *matchedPos)</td></tr>
<tr class="memdesc:ad977c265833d6466598cceb406a085db"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if a very similar symmetry is not already saved.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad977c265833d6466598cceb406a085db">More...</a><br /></td></tr>
<tr class="separator:ad977c265833d6466598cceb406a085db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10af3702dc9022c3afcaf72b049779f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a10af3702dc9022c3afcaf72b049779f3">isSymmetrySame</a> (std::vector&lt; proshade_double * &gt; *ret, proshade_double *sym, proshade_double simThres, proshade_signed *matchedPos, proshade_double fscVal)</td></tr>
<tr class="memdesc:a10af3702dc9022c3afcaf72b049779f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if a very similar symmetry is not already saved.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a10af3702dc9022c3afcaf72b049779f3">More...</a><br /></td></tr>
<tr class="separator:a10af3702dc9022c3afcaf72b049779f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ac919dd609bc6bded806c0f78201fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ab0ac919dd609bc6bded806c0f78201fd">saveDSymmetry</a> (std::vector&lt; proshade_double * &gt; *ret, std::vector&lt; proshade_double * &gt; *CSymList, proshade_unsign axisOne, proshade_unsign axisTwo)</td></tr>
<tr class="memdesc:ab0ac919dd609bc6bded806c0f78201fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function saves a detected dihedral symmetry to the dihedral symmetries list.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ab0ac919dd609bc6bded806c0f78201fd">More...</a><br /></td></tr>
<tr class="separator:ab0ac919dd609bc6bded806c0f78201fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37925ac477480c718451debb01a9c74a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a37925ac477480c718451debb01a9c74a">detectTetrahedralSymmetry</a> (std::vector&lt; proshade_double * &gt; *CSymList, proshade_double axErr, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:a37925ac477480c718451debb01a9c74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and decides whether basic requirements for tetrahedral symmetry are there.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a37925ac477480c718451debb01a9c74a">More...</a><br /></td></tr>
<tr class="separator:a37925ac477480c718451debb01a9c74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4e5e34da6e4a9ed4a67cca16491c17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5d4e5e34da6e4a9ed4a67cca16491c17">findTetra4C3s</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, proshade_double axErr, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_signed verbose, proshade_signed messageShift, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:a5d4e5e34da6e4a9ed4a67cca16491c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and finds the 4 C3 symmetries with correct angles required for full tetrahedral symmetry.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5d4e5e34da6e4a9ed4a67cca16491c17">More...</a><br /></td></tr>
<tr class="separator:a5d4e5e34da6e4a9ed4a67cca16491c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c193e95c7069fafa78dccc1de1aaa4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad8c193e95c7069fafa78dccc1de1aaa4">testGroupAgainstSymmetry</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_unsign &gt; *grp, proshade_double *sym, proshade_double axErr, proshade_double angle, bool improve, proshade_unsign pos=0)</td></tr>
<tr class="memdesc:ad8c193e95c7069fafa78dccc1de1aaa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tests whether a symmetry has particular angle to all members of a group.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad8c193e95c7069fafa78dccc1de1aaa4">More...</a><br /></td></tr>
<tr class="separator:ad8c193e95c7069fafa78dccc1de1aaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6093da290ce7b73a33e8b55f2c83491"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af6093da290ce7b73a33e8b55f2c83491">findMissingAxes</a> (std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; *possibilities, std::vector&lt; proshade_double * &gt; *CSymList, proshade_unsign requiredNoAxes, proshade_double axErr, proshade_double angle, proshade_unsign fold, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:af6093da290ce7b73a33e8b55f2c83491"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tries to find an axis which would complete a particular group of axes for polyhedral symmetry detection.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af6093da290ce7b73a33e8b55f2c83491">More...</a><br /></td></tr>
<tr class="separator:af6093da290ce7b73a33e8b55f2c83491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44ed609e8a3d59674b2b2256aec41f8"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad44ed609e8a3d59674b2b2256aec41f8">missingAxisHeight</a> (proshade_double xVal, proshade_double yVal, proshade_double zVal, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_unsign fold, proshade_double axErr)</td></tr>
<tr class="memdesc:ad44ed609e8a3d59674b2b2256aec41f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function searches for the highest peaks average that would produce the required axis and fold.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad44ed609e8a3d59674b2b2256aec41f8">More...</a><br /></td></tr>
<tr class="separator:ad44ed609e8a3d59674b2b2256aec41f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465606e58df7d6a2238d40c6919b2e58"><td class="memItemLeft" align="right" valign="top">std::vector&lt; proshade_double * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a465606e58df7d6a2238d40c6919b2e58">findMissingAxisPoints</a> (proshade_double xVal, proshade_double yVal, proshade_double zVal, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_double axErr)</td></tr>
<tr class="memdesc:a465606e58df7d6a2238d40c6919b2e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function searches for all the self-rotation map points conforming to the axis, returning their angles and heights.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a465606e58df7d6a2238d40c6919b2e58">More...</a><br /></td></tr>
<tr class="separator:a465606e58df7d6a2238d40c6919b2e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d576f90449b7d3fcf5ae4d3114c268"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a68d576f90449b7d3fcf5ae4d3114c268">sortArrVecHlp</a> (const proshade_double *a, const proshade_double *b)</td></tr>
<tr class="memdesc:a68d576f90449b7d3fcf5ae4d3114c268"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compares two arrays of two based on the first number.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a68d576f90449b7d3fcf5ae4d3114c268">More...</a><br /></td></tr>
<tr class="separator:a68d576f90449b7d3fcf5ae4d3114c268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc4353223fc752e0007b2adec193079"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5dc4353223fc752e0007b2adec193079">saveMissingAxisNewOnly</a> (std::vector&lt; proshade_double * &gt; *axVec, proshade_double axX, proshade_double axY, proshade_double axZ, proshade_double height, proshade_unsign fold, proshade_double axErr)</td></tr>
<tr class="memdesc:a5dc4353223fc752e0007b2adec193079"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function saves the recovered information about missing axis into a full symmetry, making sure no duplicates are created.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5dc4353223fc752e0007b2adec193079">More...</a><br /></td></tr>
<tr class="separator:a5dc4353223fc752e0007b2adec193079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ada2416687dbb0bec93603770cb4c83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a1ada2416687dbb0bec93603770cb4c83">searchMissingSymmetrySpace</a> (<a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_unsign &gt; *grp, std::vector&lt; proshade_double * &gt; *hlpVec, proshade_double axErr, proshade_double angle, proshade_unsign fold, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:a1ada2416687dbb0bec93603770cb4c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tests feasible axes against the missing axis criteria, returning a set of matching axes.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a1ada2416687dbb0bec93603770cb4c83">More...</a><br /></td></tr>
<tr class="separator:a1ada2416687dbb0bec93603770cb4c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5d3ccec33e4cf7204124a5647fe5c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5e5d3ccec33e4cf7204124a5647fe5c9">findTetra3C2s</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, proshade_double axErr, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_signed verbose, proshade_signed messageShift, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:a5e5d3ccec33e4cf7204124a5647fe5c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and finds the 3 C2 symmetries with correct angles required for full tetrahedral symmetry.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5e5d3ccec33e4cf7204124a5647fe5c9">More...</a><br /></td></tr>
<tr class="separator:a5e5d3ccec33e4cf7204124a5647fe5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5360c152697780177eb2676888cd5108"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5360c152697780177eb2676888cd5108">testGroupAgainstGroup</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_unsign &gt; *grp1, std::vector&lt; proshade_double * &gt; *RetList, std::vector&lt; proshade_unsign &gt; *grp2, proshade_double angle, proshade_double axErr)</td></tr>
<tr class="memdesc:a5360c152697780177eb2676888cd5108"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compares two groups of axes for a single pair having the required angle.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5360c152697780177eb2676888cd5108">More...</a><br /></td></tr>
<tr class="separator:a5360c152697780177eb2676888cd5108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d456057604616a7cf6b68f59b4f2d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a18d456057604616a7cf6b68f59b4f2d0">detectOctahedralSymmetry</a> (std::vector&lt; proshade_double * &gt; *CSymList, proshade_double axErr, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:a18d456057604616a7cf6b68f59b4f2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and decides whether basic requirements for octahhedral symmetry are there.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a18d456057604616a7cf6b68f59b4f2d0">More...</a><br /></td></tr>
<tr class="separator:a18d456057604616a7cf6b68f59b4f2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e25079d4a20a0d6442c7fb36fdeaea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a31e25079d4a20a0d6442c7fb36fdeaea">findOcta3C4s</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, proshade_double axErr, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_signed verbose, proshade_signed messageShift, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:a31e25079d4a20a0d6442c7fb36fdeaea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and finds the 3 C4 symmetries with perpendicular angles required for full octahedral symmetry.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a31e25079d4a20a0d6442c7fb36fdeaea">More...</a><br /></td></tr>
<tr class="separator:a31e25079d4a20a0d6442c7fb36fdeaea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db775b80f6ce426bb98d87f8ba99d72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a1db775b80f6ce426bb98d87f8ba99d72">findOcta4C3s</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, proshade_double axErr, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_signed verbose, proshade_signed messageShift, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:a1db775b80f6ce426bb98d87f8ba99d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and finds the four C3 symmetries with correct angles required for full octahedral symmetry.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a1db775b80f6ce426bb98d87f8ba99d72">More...</a><br /></td></tr>
<tr class="separator:a1db775b80f6ce426bb98d87f8ba99d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f24f5b37a7810ce379fce1b71877a0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a7f24f5b37a7810ce379fce1b71877a0e">findOcta6C2s</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, proshade_double axErr, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_signed verbose, proshade_signed messageShift, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:a7f24f5b37a7810ce379fce1b71877a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and finds the six C2 symmetries with correct angles required for full octahedral symmetry.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a7f24f5b37a7810ce379fce1b71877a0e">More...</a><br /></td></tr>
<tr class="separator:a7f24f5b37a7810ce379fce1b71877a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9f533a789bd5c6031fa77b9649ed3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a6d9f533a789bd5c6031fa77b9649ed3d">findMissingAxesDual</a> (std::vector&lt; proshade_unsign &gt; *possibilities, std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, std::vector&lt; proshade_unsign &gt; *retGroup, proshade_unsign requiredNoAxes, proshade_double axErr, proshade_unsign noMatchesG1, proshade_double angle1, proshade_unsign noMatchesG2, proshade_double angle2, proshade_unsign fold, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj)</td></tr>
<tr class="memdesc:a6d9f533a789bd5c6031fa77b9649ed3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tries to find a particular symmetry axes which would complete a group of symmetries with two different angle requirement to another group.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a6d9f533a789bd5c6031fa77b9649ed3d">More...</a><br /></td></tr>
<tr class="separator:a6d9f533a789bd5c6031fa77b9649ed3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a784fd675e871b3b032d8f62013262"><td class="memItemLeft" align="right" valign="top">proshade_signed&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a00a784fd675e871b3b032d8f62013262">addAxisUnlessSame</a> (proshade_unsign fold, proshade_double axX, proshade_double axY, proshade_double axZ, proshade_double axHeight, std::vector&lt; proshade_double * &gt; *prosp, proshade_double axErr)</td></tr>
<tr class="memdesc:a00a784fd675e871b3b032d8f62013262"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function simply creates a new axis from information in aruments and tests if no such axis already exists, saving it if need be.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a00a784fd675e871b3b032d8f62013262">More...</a><br /></td></tr>
<tr class="separator:a00a784fd675e871b3b032d8f62013262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210ee0af651d440b68168882ead71c66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a210ee0af651d440b68168882ead71c66">checkFittingAxisDualAndSave</a> (std::vector&lt; proshade_unsign &gt; *retGroup, std::vector&lt; proshade_double * &gt; *ret, proshade_unsign fold, proshade_double axX, proshade_double axY, proshade_double axZ, std::vector&lt; proshade_double * &gt; *prosp, proshade_double axErr, proshade_unsign noMatchesG1, proshade_double angle1, proshade_unsign noMatchesG2, proshade_double angle2, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj)</td></tr>
<tr class="memdesc:a210ee0af651d440b68168882ead71c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a newly detected "missing" axis and tests it for belonging to the group, checking the height and replacing lower height members with better members.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a210ee0af651d440b68168882ead71c66">More...</a><br /></td></tr>
<tr class="separator:a210ee0af651d440b68168882ead71c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f09b90de1f15b345ee7998ff31327f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a4f09b90de1f15b345ee7998ff31327f3">detectIcosahedralSymmetry</a> (std::vector&lt; proshade_double * &gt; *CSymList, proshade_double axErr, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:a4f09b90de1f15b345ee7998ff31327f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and decides whether basic requirements for isosahedral symmetry are there.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a4f09b90de1f15b345ee7998ff31327f3">More...</a><br /></td></tr>
<tr class="separator:a4f09b90de1f15b345ee7998ff31327f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4dec365c5650c93198d73b6d259e4e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af4dec365c5650c93198d73b6d259e4e7">findIcos6C5s</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, proshade_double axErr, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_signed verbose, proshade_signed messageShift, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:af4dec365c5650c93198d73b6d259e4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and finds the six C5 symmetries with given angles required for full icosahedral symmetry.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af4dec365c5650c93198d73b6d259e4e7">More...</a><br /></td></tr>
<tr class="separator:af4dec365c5650c93198d73b6d259e4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53cd7561731d9426989f5ace523826a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ab53cd7561731d9426989f5ace523826a">findIcos10C3s</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, proshade_double axErr, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_signed verbose, proshade_signed messageShift, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:ab53cd7561731d9426989f5ace523826a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and finds the ten C3 symmetries with correct angles required for full icosahedral symmetry.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ab53cd7561731d9426989f5ace523826a">More...</a><br /></td></tr>
<tr class="separator:ab53cd7561731d9426989f5ace523826a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422414bb07db89a5c797f371a5448c0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a422414bb07db89a5c797f371a5448c0e">findIcos15C2s</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, proshade_double axErr, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_signed verbose, proshade_signed messageShift, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:a422414bb07db89a5c797f371a5448c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and finds the fifteen C3 symmetries with correct angles required for full icosahedral symmetry.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a422414bb07db89a5c797f371a5448c0e">More...</a><br /></td></tr>
<tr class="separator:a422414bb07db89a5c797f371a5448c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae266053664eb7cf916aa5e2d282e35dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ae266053664eb7cf916aa5e2d282e35dd">findMissingAxesTriple</a> (std::vector&lt; proshade_unsign &gt; *possibilities, std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, std::vector&lt; proshade_unsign &gt; *retGroup, proshade_unsign requiredNoAxes, proshade_double axErr, proshade_unsign noMatchesG1, proshade_double angle1, proshade_unsign noMatchesG2, proshade_double angle2, proshade_unsign noMatchesG3, proshade_double angle3, proshade_unsign fold, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj)</td></tr>
<tr class="memdesc:ae266053664eb7cf916aa5e2d282e35dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tries to find a particular symmetry axis which would complete a group of symmetries with three different angle requirement to another group.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ae266053664eb7cf916aa5e2d282e35dd">More...</a><br /></td></tr>
<tr class="separator:ae266053664eb7cf916aa5e2d282e35dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194944b48a4b6b523ef251a2a03eab17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a194944b48a4b6b523ef251a2a03eab17">checkFittingAxisTripleAndSave</a> (std::vector&lt; proshade_unsign &gt; *retGroup, std::vector&lt; proshade_double * &gt; *ret, proshade_unsign fold, proshade_double axX, proshade_double axY, proshade_double axZ, std::vector&lt; proshade_double * &gt; *prosp, proshade_double axErr, proshade_unsign noMatchesG1, proshade_double angle1, proshade_unsign noMatchesG2, proshade_double angle2, proshade_unsign noMatchesG3, proshade_double angle3, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj)</td></tr>
<tr class="memdesc:a194944b48a4b6b523ef251a2a03eab17"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a newly detected "missing" axis and tests it for belonging to the group, checking the height and replacing lower height members with better members.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a194944b48a4b6b523ef251a2a03eab17">More...</a><br /></td></tr>
<tr class="separator:a194944b48a4b6b523ef251a2a03eab17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c00659b5f6abf315fb5a426c45810c"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a58c00659b5f6abf315fb5a426c45810c">findPredictedSingleAxisHeight</a> (proshade_double *axis, proshade_double fold, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, <a class="el" href="class_pro_s_h_a_d_e__settings.html">ProSHADE_settings</a> *settings)</td></tr>
<tr class="memdesc:a58c00659b5f6abf315fb5a426c45810c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds the rotation function value for a single axis.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a58c00659b5f6abf315fb5a426c45810c">More...</a><br /></td></tr>
<tr class="separator:a58c00659b5f6abf315fb5a426c45810c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c650c19a6954800bba6b3a8f5842e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a33c650c19a6954800bba6b3a8f5842e6">findPredictedAxesHeights</a> (std::vector&lt; proshade_double * &gt; *ret, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, <a class="el" href="class_pro_s_h_a_d_e__settings.html">ProSHADE_settings</a> *settings)</td></tr>
<tr class="memdesc:a33c650c19a6954800bba6b3a8f5842e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds the rotation function value for all axes supplied in the ret parameter.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a33c650c19a6954800bba6b3a8f5842e6">More...</a><br /></td></tr>
<tr class="separator:a33c650c19a6954800bba6b3a8f5842e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b39de1c901703986cb476d8cb8cf9dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a8b39de1c901703986cb476d8cb8cf9dc">optimiseDGroupAngleFromAxesHeights</a> (std::vector&lt; std::vector&lt; proshade_double &gt; &gt; *ret, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, <a class="el" href="class_pro_s_h_a_d_e__settings.html">ProSHADE_settings</a> *settings)</td></tr>
<tr class="memdesc:a8b39de1c901703986cb476d8cb8cf9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes two axes with almost dihedral angle and optimises their relative positions as well as orientation with respect to the optimal angle and the rotation function.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a8b39de1c901703986cb476d8cb8cf9dc">More...</a><br /></td></tr>
<tr class="separator:a8b39de1c901703986cb476d8cb8cf9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e9966655e7cfbf988ef38d4653bd69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ae4e9966655e7cfbf988ef38d4653bd69">optimiseDGroupAngleFromAxesHeights</a> (std::vector&lt; std::vector&lt; proshade_double &gt; &gt; *allCs, std::vector&lt; proshade_unsign &gt; selection, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, <a class="el" href="class_pro_s_h_a_d_e__settings.html">ProSHADE_settings</a> *settings)</td></tr>
<tr class="memdesc:ae4e9966655e7cfbf988ef38d4653bd69"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes two axes with almost dihedral angle and optimises their relative positions as well as orientation with respect to the optimal angle and the rotation function.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ae4e9966655e7cfbf988ef38d4653bd69">More...</a><br /></td></tr>
<tr class="separator:ae4e9966655e7cfbf988ef38d4653bd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d3cf24f73eafc1d5b8ef9e204aaf8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a16d3cf24f73eafc1d5b8ef9e204aaf8d">predictIcosAxes</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; std::vector&lt; proshade_double * &gt; &gt; *ret, proshade_double axErr, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:a16d3cf24f73eafc1d5b8ef9e204aaf8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function predicts all possible icosahedral point groups symmetry axes from the cyclic point groups list.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a16d3cf24f73eafc1d5b8ef9e204aaf8d">More...</a><br /></td></tr>
<tr class="separator:a16d3cf24f73eafc1d5b8ef9e204aaf8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ce8efbbe05220793b5f01f0fef07a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a38ce8efbbe05220793b5f01f0fef07a6">predictOctaAxes</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, proshade_double axErr, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:a38ce8efbbe05220793b5f01f0fef07a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function predicts all octahedral point group symmetry axes from the cyclic point groups list.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a38ce8efbbe05220793b5f01f0fef07a6">More...</a><br /></td></tr>
<tr class="separator:a38ce8efbbe05220793b5f01f0fef07a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7a2435e9d3616d860aeee2d94dba55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#aef7a2435e9d3616d860aeee2d94dba55">predictTetraAxes</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, proshade_double axErr, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:aef7a2435e9d3616d860aeee2d94dba55"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function predicts all tetrahedral point group symmetry axes from the cyclic point groups list.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#aef7a2435e9d3616d860aeee2d94dba55">More...</a><br /></td></tr>
<tr class="separator:aef7a2435e9d3616d860aeee2d94dba55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b1e5bdc80f63a47d0abff4b66ee6b2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; proshade_unsign &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a29b1e5bdc80f63a47d0abff4b66ee6b2">findReliableUnphasedSymmetries</a> (std::vector&lt; std::vector&lt; proshade_double &gt; &gt; *allCs, proshade_signed verbose, proshade_signed messageShift, proshade_double tolerance)</td></tr>
<tr class="memdesc:a29b1e5bdc80f63a47d0abff4b66ee6b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks the list of detected axes (presumably from phaseless symmetry detection) and returns the best dihedral (or cyclic, if no dihedral is found) point group, or empty vector if nothing is found.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a29b1e5bdc80f63a47d0abff4b66ee6b2">More...</a><br /></td></tr>
<tr class="separator:a29b1e5bdc80f63a47d0abff4b66ee6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952318f67deb547d73ae3ed62ee6d5c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a952318f67deb547d73ae3ed62ee6d5c4">allocateCentreOfMapFourierTransforms</a> (proshade_unsign xDim, proshade_unsign yDim, proshade_unsign zDim, fftw_complex *&amp;origMap, fftw_complex *&amp;origCoeffs, fftw_complex *&amp;rotMapComplex, fftw_complex *&amp;rotCoeffs, fftw_complex *&amp;trFunc, fftw_complex *&amp;trFuncCoeffs, fftw_plan *planForwardFourier, fftw_plan *planForwardFourierRot, fftw_plan *planReverseFourierComb)</td></tr>
<tr class="memdesc:a952318f67deb547d73ae3ed62ee6d5c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allocates the required memory for the Fourier transforms required to find the centre of the map.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a952318f67deb547d73ae3ed62ee6d5c4">More...</a><br /></td></tr>
<tr class="separator:a952318f67deb547d73ae3ed62ee6d5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e67dc983f98cde3963b0d805f41ce30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a4e67dc983f98cde3963b0d805f41ce30">releaseCentreOfMapFourierTransforms</a> (fftw_complex *origMap, fftw_complex *origCoeffs, fftw_complex *rotMapComplex, fftw_complex *rotCoeffs, fftw_complex *trFunc, fftw_complex *trFuncCoeffs, fftw_plan planForwardFourier, fftw_plan planForwardFourierRot, fftw_plan planReverseFourierComb)</td></tr>
<tr class="memdesc:a4e67dc983f98cde3963b0d805f41ce30"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function releases the allocated memory for the Fourier transforms used to find the centre of the map.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a4e67dc983f98cde3963b0d805f41ce30">More...</a><br /></td></tr>
<tr class="separator:a4e67dc983f98cde3963b0d805f41ce30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec1b87286193d7797b6afa2bed1ea33"><td class="memItemLeft" align="right" valign="top">std::vector&lt; proshade_double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a3ec1b87286193d7797b6afa2bed1ea33">findTranslationBetweenRotatedAndOriginalMap</a> (<a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *symStr, std::vector&lt; proshade_double &gt; symElem, fftw_complex *origCoeffs, fftw_complex *rotMapComplex, fftw_complex *rotCoeffs, fftw_plan planForwardFourierRot, fftw_complex *trFuncCoeffs, fftw_complex *trFunc, fftw_plan planReverseFourierComb)</td></tr>
<tr class="memdesc:a3ec1b87286193d7797b6afa2bed1ea33"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a single rotation matrix and procceds to compute the optimal translation between the original map and a map rotated by the supplied rotation matrix.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a3ec1b87286193d7797b6afa2bed1ea33">More...</a><br /></td></tr>
<tr class="separator:a3ec1b87286193d7797b6afa2bed1ea33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194544dbfe4daae5fe9300daeb98c779"><td class="memItemLeft" align="right" valign="top">std::vector&lt; proshade_double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a194544dbfe4daae5fe9300daeb98c779">findPointFromTranslations</a> (<a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *symStr, std::vector&lt; std::vector&lt; proshade_double &gt; &gt; symElems, fftw_complex *origCoeffs, fftw_complex *rotMapComplex, fftw_complex *rotCoeffs, fftw_plan planForwardFourierRot, fftw_complex *trFuncCoeffs, fftw_complex *trFunc, fftw_plan planReverseFourierComb)</td></tr>
<tr class="memdesc:a194544dbfe4daae5fe9300daeb98c779"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the average of optimal translations for a cyclic point group.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a194544dbfe4daae5fe9300daeb98c779">More...</a><br /></td></tr>
<tr class="separator:a194544dbfe4daae5fe9300daeb98c779"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace contains the symmetry detection related code. </p>
<p>The <a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html" title="This namespace contains the symmetry detection related code.">ProSHADE_internal_symmetry</a> namespace contains the functions related to the symmetry detection task. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a262d9e21cd6b81b8bda35ec22eb363dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a262d9e21cd6b81b8bda35ec22eb363dd">&#9670;&nbsp;</a></span>addAxisUnlessSame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">proshade_signed ProSHADE_internal_symmetry::addAxisUnlessSame </td>
          <td>(</td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>averageFSC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>prosp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function simply creates a new axis from information in aruments and tests if no such axis already exists, saving it if need be. </p>
<p>This is a simple helper function, which takes all the new axis information and creates the ProSHADE axis representation from these. It then proceeds to check if such axis does not already exist in the supplied vector, if not, it saves the new axis; alternatively, it just discards the created axis and terminates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fold</td><td>The fold of the searched for axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axX</td><td>The x-axis element of the new axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axY</td><td>The y-axis element of the new axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axZ</td><td>The z-axis element of the new axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axHeight</td><td>The average peak height of the new axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">averageFSC</td><td>The value of average FSC, if computed - otherwise enter -1.0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prosp</td><td>The vector to which the axis is to be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">addedNo</td><td>Position at which the symmetry either already is, or was added to. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01657">1657</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01658"></a><span class="lineno"> 1658</span>&#160;{</div>
<div class="line"><a name="l01659"></a><span class="lineno"> 1659</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l01660"></a><span class="lineno"> 1660</span>&#160;    proshade_double* symHlp                           = <span class="keyword">new</span> proshade_double[7];</div>
<div class="line"><a name="l01661"></a><span class="lineno"> 1661</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( symHlp, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l01662"></a><span class="lineno"> 1662</span>&#160;    proshade_signed ret                               = -1;</div>
<div class="line"><a name="l01663"></a><span class="lineno"> 1663</span>&#160;    </div>
<div class="line"><a name="l01664"></a><span class="lineno"> 1664</span>&#160;    <span class="comment">//================================================ Fill in the prospective axis</span></div>
<div class="line"><a name="l01665"></a><span class="lineno"> 1665</span>&#160;    symHlp[0]                                         = <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( fold );</div>
<div class="line"><a name="l01666"></a><span class="lineno"> 1666</span>&#160;    symHlp[1]                                         = axX;</div>
<div class="line"><a name="l01667"></a><span class="lineno"> 1667</span>&#160;    symHlp[2]                                         = axY;</div>
<div class="line"><a name="l01668"></a><span class="lineno"> 1668</span>&#160;    symHlp[3]                                         = axZ;</div>
<div class="line"><a name="l01669"></a><span class="lineno"> 1669</span>&#160;    symHlp[4]                                         = 2.0 * M_PI / symHlp[0];</div>
<div class="line"><a name="l01670"></a><span class="lineno"> 1670</span>&#160;    symHlp[5]                                         = axHeight;</div>
<div class="line"><a name="l01671"></a><span class="lineno"> 1671</span>&#160;    symHlp[6]                                         = averageFSC;</div>
<div class="line"><a name="l01672"></a><span class="lineno"> 1672</span>&#160;    </div>
<div class="line"><a name="l01673"></a><span class="lineno"> 1673</span>&#160;    <span class="comment">//================================================ If it is not the same as already saved axes</span></div>
<div class="line"><a name="l01674"></a><span class="lineno"> 1674</span>&#160;    <span class="keywordflow">if</span> ( !<a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad977c265833d6466598cceb406a085db">ProSHADE_internal_symmetry::isSymmetrySame</a> ( prosp, symHlp, axErr, &amp;ret, averageFSC ) )</div>
<div class="line"><a name="l01675"></a><span class="lineno"> 1675</span>&#160;    {</div>
<div class="line"><a name="l01676"></a><span class="lineno"> 1676</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a>     ( prosp, symHlp );</div>
<div class="line"><a name="l01677"></a><span class="lineno"> 1677</span>&#160;        <span class="keywordflow">return</span>                                        ( <span class="keyword">static_cast&lt;</span> proshade_signed <span class="keyword">&gt;</span> ( prosp-&gt;size() - 1 ) );</div>
<div class="line"><a name="l01678"></a><span class="lineno"> 1678</span>&#160;    }</div>
<div class="line"><a name="l01679"></a><span class="lineno"> 1679</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l01680"></a><span class="lineno"> 1680</span>&#160;    {</div>
<div class="line"><a name="l01681"></a><span class="lineno"> 1681</span>&#160;        <span class="keyword">delete</span>[] symHlp;</div>
<div class="line"><a name="l01682"></a><span class="lineno"> 1682</span>&#160;        <span class="keywordflow">return</span>                                        ( ret );</div>
<div class="line"><a name="l01683"></a><span class="lineno"> 1683</span>&#160;    }</div>
<div class="line"><a name="l01684"></a><span class="lineno"> 1684</span>&#160;    </div>
<div class="line"><a name="l01685"></a><span class="lineno"> 1685</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01686"></a><span class="lineno"> 1686</span>&#160;    </div>
<div class="line"><a name="l01687"></a><span class="lineno"> 1687</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a00a784fd675e871b3b032d8f62013262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a784fd675e871b3b032d8f62013262">&#9670;&nbsp;</a></span>addAxisUnlessSame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">proshade_signed ProSHADE_internal_symmetry::addAxisUnlessSame </td>
          <td>(</td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>prosp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function simply creates a new axis from information in aruments and tests if no such axis already exists, saving it if need be. </p>
<p>This is a simple helper function, which takes all the new axis information and creates the ProSHADE axis representation from these. It then proceeds to check if such axis does not already exist in the supplied vector, if not, it saves the new axis; alternatively, it just discards the created axis and terminates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fold</td><td>The fold of the searched for axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axX</td><td>The x-axis element of the new axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axY</td><td>The y-axis element of the new axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axZ</td><td>The z-axis element of the new axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axHeight</td><td>The average peak height of the new axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prosp</td><td>The vector to which the axis is to be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">addedNo</td><td>Position at which the symmetry either already is, or was added to. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01703">1703</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01704"></a><span class="lineno"> 1704</span>&#160;{</div>
<div class="line"><a name="l01705"></a><span class="lineno"> 1705</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l01706"></a><span class="lineno"> 1706</span>&#160;    proshade_double* symHlp                           = <span class="keyword">new</span> proshade_double[7];</div>
<div class="line"><a name="l01707"></a><span class="lineno"> 1707</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( symHlp, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l01708"></a><span class="lineno"> 1708</span>&#160;    proshade_signed ret                               = -1;</div>
<div class="line"><a name="l01709"></a><span class="lineno"> 1709</span>&#160;    </div>
<div class="line"><a name="l01710"></a><span class="lineno"> 1710</span>&#160;    <span class="comment">//================================================ Fill in the prospective axis</span></div>
<div class="line"><a name="l01711"></a><span class="lineno"> 1711</span>&#160;    symHlp[0]                                         = <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( fold );</div>
<div class="line"><a name="l01712"></a><span class="lineno"> 1712</span>&#160;    symHlp[1]                                         = axX;</div>
<div class="line"><a name="l01713"></a><span class="lineno"> 1713</span>&#160;    symHlp[2]                                         = axY;</div>
<div class="line"><a name="l01714"></a><span class="lineno"> 1714</span>&#160;    symHlp[3]                                         = axZ;</div>
<div class="line"><a name="l01715"></a><span class="lineno"> 1715</span>&#160;    symHlp[4]                                         = 2.0 * M_PI / symHlp[0];</div>
<div class="line"><a name="l01716"></a><span class="lineno"> 1716</span>&#160;    symHlp[5]                                         = axHeight;</div>
<div class="line"><a name="l01717"></a><span class="lineno"> 1717</span>&#160;    symHlp[6]                                         = -std::numeric_limits &lt; proshade_double &gt;::infinity();</div>
<div class="line"><a name="l01718"></a><span class="lineno"> 1718</span>&#160;    </div>
<div class="line"><a name="l01719"></a><span class="lineno"> 1719</span>&#160;    <span class="comment">//================================================ If it is not the same as already saved axes</span></div>
<div class="line"><a name="l01720"></a><span class="lineno"> 1720</span>&#160;    <span class="keywordflow">if</span> ( !<a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad977c265833d6466598cceb406a085db">ProSHADE_internal_symmetry::isSymmetrySame</a> ( prosp, symHlp, axErr, &amp;ret ) )</div>
<div class="line"><a name="l01721"></a><span class="lineno"> 1721</span>&#160;    {</div>
<div class="line"><a name="l01722"></a><span class="lineno"> 1722</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a>     ( prosp, symHlp );</div>
<div class="line"><a name="l01723"></a><span class="lineno"> 1723</span>&#160;        <span class="keywordflow">return</span>                                        ( <span class="keyword">static_cast&lt;</span> proshade_signed <span class="keyword">&gt;</span> ( prosp-&gt;size() - 1 ) );</div>
<div class="line"><a name="l01724"></a><span class="lineno"> 1724</span>&#160;    }</div>
<div class="line"><a name="l01725"></a><span class="lineno"> 1725</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l01726"></a><span class="lineno"> 1726</span>&#160;    {</div>
<div class="line"><a name="l01727"></a><span class="lineno"> 1727</span>&#160;        <span class="keyword">delete</span>[] symHlp;</div>
<div class="line"><a name="l01728"></a><span class="lineno"> 1728</span>&#160;        <span class="keywordflow">return</span>                                        ( ret );</div>
<div class="line"><a name="l01729"></a><span class="lineno"> 1729</span>&#160;    }</div>
<div class="line"><a name="l01730"></a><span class="lineno"> 1730</span>&#160;    </div>
<div class="line"><a name="l01731"></a><span class="lineno"> 1731</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01732"></a><span class="lineno"> 1732</span>&#160;    </div>
<div class="line"><a name="l01733"></a><span class="lineno"> 1733</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a952318f67deb547d73ae3ed62ee6d5c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952318f67deb547d73ae3ed62ee6d5c4">&#9670;&nbsp;</a></span>allocateCentreOfMapFourierTransforms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::allocateCentreOfMapFourierTransforms </td>
          <td>(</td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>xDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>yDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>zDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_complex *&amp;&#160;</td>
          <td class="paramname"><em>origMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_complex *&amp;&#160;</td>
          <td class="paramname"><em>origCoeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_complex *&amp;&#160;</td>
          <td class="paramname"><em>rotMapComplex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_complex *&amp;&#160;</td>
          <td class="paramname"><em>rotCoeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_complex *&amp;&#160;</td>
          <td class="paramname"><em>trFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_complex *&amp;&#160;</td>
          <td class="paramname"><em>trFuncCoeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_plan *&#160;</td>
          <td class="paramname"><em>planForwardFourier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_plan *&#160;</td>
          <td class="paramname"><em>planForwardFourierRot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_plan *&#160;</td>
          <td class="paramname"><em>planReverseFourierComb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function allocates the required memory for the Fourier transforms required to find the centre of the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xDim</td><td>The size of the x-axis in indices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yDim</td><td>The size of the y-axis in indices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zDim</td><td>The size of the z-axis in indices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">origMap</td><td>Array to which the original map will be saved before Fourier transform computation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">origCoeffs</td><td>Array to which the result of the Fourier transform of the original map will be saved into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotMapComplex</td><td>Array to which the rotated map will be saved before Fourier transform computation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotCoeffs</td><td>Array to which the result of the Fourier transform of the rotated map will be saved into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trFunc</td><td>Array to which the results of inverse Fourier transform of the conbined coefficients will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trFuncCoeffs</td><td>Array to which the two maps coefficients will be combined into before inverse Fourier transform computation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">planForwardFourier</td><td>FFTW3 plan for the original map Fourier transform. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">planForwardFourierRot</td><td>FFTW3 plat for the rotated map Fourier transform. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">planReverseFourierComb</td><td>FFTW3 plan for the inverse Fourier transform from the combined coefficients to translation function. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l03791">3791</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03792"></a><span class="lineno"> 3792</span>&#160;{</div>
<div class="line"><a name="l03793"></a><span class="lineno"> 3793</span>&#160;    <span class="comment">//================================================ Allocate the memory</span></div>
<div class="line"><a name="l03794"></a><span class="lineno"> 3794</span>&#160;    origMap                                           = <span class="keyword">new</span> fftw_complex [xDim * yDim * zDim];</div>
<div class="line"><a name="l03795"></a><span class="lineno"> 3795</span>&#160;    origCoeffs                                        = <span class="keyword">new</span> fftw_complex [xDim * yDim * zDim];</div>
<div class="line"><a name="l03796"></a><span class="lineno"> 3796</span>&#160;    rotMapComplex                                     = <span class="keyword">new</span> fftw_complex [xDim * yDim * zDim];</div>
<div class="line"><a name="l03797"></a><span class="lineno"> 3797</span>&#160;    rotCoeffs                                         = <span class="keyword">new</span> fftw_complex [xDim * yDim * zDim];</div>
<div class="line"><a name="l03798"></a><span class="lineno"> 3798</span>&#160;    trFunc                                            = <span class="keyword">new</span> fftw_complex [xDim * yDim * zDim];</div>
<div class="line"><a name="l03799"></a><span class="lineno"> 3799</span>&#160;    trFuncCoeffs                                      = <span class="keyword">new</span> fftw_complex [xDim * yDim * zDim];</div>
<div class="line"><a name="l03800"></a><span class="lineno"> 3800</span>&#160;    </div>
<div class="line"><a name="l03801"></a><span class="lineno"> 3801</span>&#160;    <span class="comment">//================================================ Check the memory allocation</span></div>
<div class="line"><a name="l03802"></a><span class="lineno"> 3802</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( origMap,       __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l03803"></a><span class="lineno"> 3803</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( origCoeffs,    __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l03804"></a><span class="lineno"> 3804</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( rotMapComplex, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l03805"></a><span class="lineno"> 3805</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( rotCoeffs,     __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l03806"></a><span class="lineno"> 3806</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( trFunc,        __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l03807"></a><span class="lineno"> 3807</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( trFuncCoeffs,  __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l03808"></a><span class="lineno"> 3808</span>&#160;    </div>
<div class="line"><a name="l03809"></a><span class="lineno"> 3809</span>&#160;    <span class="comment">//================================================</span></div>
<div class="line"><a name="l03810"></a><span class="lineno"> 3810</span>&#160;   *planForwardFourier                                = fftw_plan_dft_3d ( <span class="keyword">static_cast&lt;</span> <span class="keywordtype">int</span> <span class="keyword">&gt;</span> ( xDim ), <span class="keyword">static_cast&lt;</span> <span class="keywordtype">int</span> <span class="keyword">&gt;</span> ( yDim ), <span class="keyword">static_cast&lt;</span> <span class="keywordtype">int</span> <span class="keyword">&gt;</span> ( zDim ), origMap,       origCoeffs, FFTW_FORWARD,   FFTW_ESTIMATE );</div>
<div class="line"><a name="l03811"></a><span class="lineno"> 3811</span>&#160;   *planForwardFourierRot                             = fftw_plan_dft_3d ( <span class="keyword">static_cast&lt;</span> <span class="keywordtype">int</span> <span class="keyword">&gt;</span> ( xDim ), <span class="keyword">static_cast&lt;</span> <span class="keywordtype">int</span> <span class="keyword">&gt;</span> ( yDim ), <span class="keyword">static_cast&lt;</span> <span class="keywordtype">int</span> <span class="keyword">&gt;</span> ( zDim ), rotMapComplex, rotCoeffs,  FFTW_FORWARD,   FFTW_ESTIMATE );</div>
<div class="line"><a name="l03812"></a><span class="lineno"> 3812</span>&#160;   *planReverseFourierComb                            = fftw_plan_dft_3d ( <span class="keyword">static_cast&lt;</span> <span class="keywordtype">int</span> <span class="keyword">&gt;</span> ( xDim ), <span class="keyword">static_cast&lt;</span> <span class="keywordtype">int</span> <span class="keyword">&gt;</span> ( yDim ), <span class="keyword">static_cast&lt;</span> <span class="keywordtype">int</span> <span class="keyword">&gt;</span> ( zDim ), trFuncCoeffs,  trFunc,     FFTW_BACKWARD,  FFTW_ESTIMATE );</div>
<div class="line"><a name="l03813"></a><span class="lineno"> 3813</span>&#160;    </div>
<div class="line"><a name="l03814"></a><span class="lineno"> 3814</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l03815"></a><span class="lineno"> 3815</span>&#160;    return ;</div>
<div class="line"><a name="l03816"></a><span class="lineno"> 3816</span>&#160;    </div>
<div class="line"><a name="l03817"></a><span class="lineno"> 3817</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a210ee0af651d440b68168882ead71c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210ee0af651d440b68168882ead71c66">&#9670;&nbsp;</a></span>checkFittingAxisDualAndSave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_symmetry::checkFittingAxisDualAndSave </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>retGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>prosp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>noMatchesG1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>angle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>noMatchesG2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>angle2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes a newly detected "missing" axis and tests it for belonging to the group, checking the height and replacing lower height members with better members. </p>
<p>This function takes the list of already detected axes, information about the tested new axis and the conditions for belonging. It then proceeds to check if the new axis conforms to the conditions of belonging. If so, it then checks if the axis height is high enough to be considered as part of the group. Again, if so, it will save this new axis to the old set, replacing any old axis with this new one, if it is the same and has better height.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">retGroup</td><td>A vector of indices in the ret list which form the group to which new axes are compared to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>A list of already detected axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fold</td><td>The fold of the searched for axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axX</td><td>The x-axis element of the new axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axY</td><td>The y-axis element of the new axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axZ</td><td>The z-axis element of the new axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prosp</td><td>The vector to which the axis is to be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noMatchesG1</td><td>The number of axes from ret that need to be matched with angle1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle1</td><td>The angle with which noMatchesG1 axes need to be matched with the retGroup axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noMatchesG2</td><td>The number of axes from ret that need to be matched with angle2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle2</td><td>The angle with which noMatchesG2 axes need to be matched with the retGroup axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataObj</td><td>The full data holding object pointer - this is to get access to self-rotation function values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Bool</td><td>True if the axis was added to the group, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01756">1756</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01757"></a><span class="lineno"> 1757</span>&#160;{</div>
<div class="line"><a name="l01758"></a><span class="lineno"> 1758</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l01759"></a><span class="lineno"> 1759</span>&#160;    proshade_unsign noG1                              = 0;</div>
<div class="line"><a name="l01760"></a><span class="lineno"> 1760</span>&#160;    proshade_unsign noG2                              = 0;</div>
<div class="line"><a name="l01761"></a><span class="lineno"> 1761</span>&#160;    proshade_double dotProd                           = 0.0;</div>
<div class="line"><a name="l01762"></a><span class="lineno"> 1762</span>&#160;    proshade_double axHeight                          = 0.0;</div>
<div class="line"><a name="l01763"></a><span class="lineno"> 1763</span>&#160;    </div>
<div class="line"><a name="l01764"></a><span class="lineno"> 1764</span>&#160;    <span class="comment">//================================================ Find the angle and count dual matching frequencies</span></div>
<div class="line"><a name="l01765"></a><span class="lineno"> 1765</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign rIt = 0; rIt &lt; static_cast&lt;proshade_unsign&gt; ( retGroup-&gt;size() ); rIt++ )</div>
<div class="line"><a name="l01766"></a><span class="lineno"> 1766</span>&#160;    {</div>
<div class="line"><a name="l01767"></a><span class="lineno"> 1767</span>&#160;        dotProd                                       = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> ( &amp;ret-&gt;at(retGroup-&gt;at(rIt))[1],</div>
<div class="line"><a name="l01768"></a><span class="lineno"> 1768</span>&#160;                                                                                                     &amp;ret-&gt;at(retGroup-&gt;at(rIt))[2],</div>
<div class="line"><a name="l01769"></a><span class="lineno"> 1769</span>&#160;                                                                                                     &amp;ret-&gt;at(retGroup-&gt;at(rIt))[3],</div>
<div class="line"><a name="l01770"></a><span class="lineno"> 1770</span>&#160;                                                                                                     &amp;axX, &amp;axY, &amp;axZ );</div>
<div class="line"><a name="l01771"></a><span class="lineno"> 1771</span>&#160;        </div>
<div class="line"><a name="l01772"></a><span class="lineno"> 1772</span>&#160;        <span class="keywordflow">if</span> ( ( std::abs ( dotProd ) &gt; ( angle1 - axErr ) ) &amp;&amp; ( std::abs ( dotProd ) &lt; ( angle1 + axErr ) ) ) { noG1 += 1; <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l01773"></a><span class="lineno"> 1773</span>&#160;        <span class="keywordflow">if</span> ( ( std::abs ( dotProd ) &gt; ( angle2 - axErr ) ) &amp;&amp; ( std::abs ( dotProd ) &lt; ( angle2 + axErr ) ) ) { noG2 += 1; <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l01774"></a><span class="lineno"> 1774</span>&#160;    }</div>
<div class="line"><a name="l01775"></a><span class="lineno"> 1775</span>&#160;    </div>
<div class="line"><a name="l01776"></a><span class="lineno"> 1776</span>&#160;    <span class="comment">//================================================ If correct frequencies are matched, check height.</span></div>
<div class="line"><a name="l01777"></a><span class="lineno"> 1777</span>&#160;    <span class="keywordflow">if</span> ( ( noG1 == noMatchesG1 ) &amp;&amp; ( noG2 == noMatchesG2 ) )</div>
<div class="line"><a name="l01778"></a><span class="lineno"> 1778</span>&#160;    {</div>
<div class="line"><a name="l01779"></a><span class="lineno"> 1779</span>&#160;        <span class="comment">//============================================ Is the height good enough?</span></div>
<div class="line"><a name="l01780"></a><span class="lineno"> 1780</span>&#160;        axHeight                                      = <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad44ed609e8a3d59674b2b2256aec41f8">ProSHADE_internal_symmetry::missingAxisHeight</a> ( axX, axY, axZ, dataObj, fold, axErr );</div>
<div class="line"><a name="l01781"></a><span class="lineno"> 1781</span>&#160;        </div>
<div class="line"><a name="l01782"></a><span class="lineno"> 1782</span>&#160;        <span class="comment">//============================================ If so, save</span></div>
<div class="line"><a name="l01783"></a><span class="lineno"> 1783</span>&#160;        <span class="keywordflow">if</span> ( axHeight &gt; 0.1 )</div>
<div class="line"><a name="l01784"></a><span class="lineno"> 1784</span>&#160;        {</div>
<div class="line"><a name="l01785"></a><span class="lineno"> 1785</span>&#160;            proshade_unsign prevProsp                 = <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( prosp-&gt;size() );</div>
<div class="line"><a name="l01786"></a><span class="lineno"> 1786</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a262d9e21cd6b81b8bda35ec22eb363dd">ProSHADE_internal_symmetry::addAxisUnlessSame</a> ( fold, axX, axY, axZ, axHeight, prosp, axErr );</div>
<div class="line"><a name="l01787"></a><span class="lineno"> 1787</span>&#160;            </div>
<div class="line"><a name="l01788"></a><span class="lineno"> 1788</span>&#160;            <span class="keywordflow">if</span> ( <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( prosp-&gt;size() ) &gt; prevProsp ) { <span class="keywordflow">return</span> ( <span class="keyword">true</span> ); }</div>
<div class="line"><a name="l01789"></a><span class="lineno"> 1789</span>&#160;            <span class="keywordflow">else</span>                                                              { <span class="keywordflow">return</span> ( <span class="keyword">false</span> ); }</div>
<div class="line"><a name="l01790"></a><span class="lineno"> 1790</span>&#160;        }</div>
<div class="line"><a name="l01791"></a><span class="lineno"> 1791</span>&#160;    }</div>
<div class="line"><a name="l01792"></a><span class="lineno"> 1792</span>&#160;    </div>
<div class="line"><a name="l01793"></a><span class="lineno"> 1793</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01794"></a><span class="lineno"> 1794</span>&#160;    <span class="keywordflow">return</span>                                            ( <span class="keyword">false</span> );</div>
<div class="line"><a name="l01795"></a><span class="lineno"> 1795</span>&#160;    </div>
<div class="line"><a name="l01796"></a><span class="lineno"> 1796</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a194944b48a4b6b523ef251a2a03eab17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194944b48a4b6b523ef251a2a03eab17">&#9670;&nbsp;</a></span>checkFittingAxisTripleAndSave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::checkFittingAxisTripleAndSave </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>retGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>prosp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>noMatchesG1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>angle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>noMatchesG2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>angle2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>noMatchesG3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>angle3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes a newly detected "missing" axis and tests it for belonging to the group, checking the height and replacing lower height members with better members. </p>
<p>This function takes the list of already detected axes, information about the tested new axis and the conditions for belonging. It then proceeds to check if the new axis conforms to the conditions of belonging. If so, it then checks if the axis height is high enough to be considered as part of the group. Again, if so, it will save this new axis to the old set, replacing any old axis with this new one, if it is the same and has better height.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">retGroup</td><td>A vector of indices in the ret list which form the group to which new axes are compared to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>A list of already detected axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fold</td><td>The fold of the searched for axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axX</td><td>The x-axis element of the new axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axY</td><td>The y-axis element of the new axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axZ</td><td>The z-axis element of the new axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prosp</td><td>The vector to which the axis is to be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noMatchesG1</td><td>The number of axes from ret that need to be matched with angle1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle1</td><td>The angle with which noMatchesG1 axes need to be matched with the retGroup axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noMatchesG2</td><td>The number of axes from ret that need to be matched with angle2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle2</td><td>The angle with which noMatchesG2 axes need to be matched with the retGroup axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noMatchesG3</td><td>The number of axes from ret that need to be matched with angle3. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle3</td><td>The angle with which noMatchesG3 axes need to be matched with the retGroup axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataObj</td><td>The full data holding object pointer - this is to get access to self-rotation function values. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l02718">2718</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02719"></a><span class="lineno"> 2719</span>&#160;{</div>
<div class="line"><a name="l02720"></a><span class="lineno"> 2720</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l02721"></a><span class="lineno"> 2721</span>&#160;    proshade_unsign noG1                              = 0;</div>
<div class="line"><a name="l02722"></a><span class="lineno"> 2722</span>&#160;    proshade_unsign noG2                              = 0;</div>
<div class="line"><a name="l02723"></a><span class="lineno"> 2723</span>&#160;    proshade_unsign noG3                              = 0;</div>
<div class="line"><a name="l02724"></a><span class="lineno"> 2724</span>&#160;    proshade_double dotProd                           = 0.0;</div>
<div class="line"><a name="l02725"></a><span class="lineno"> 2725</span>&#160;    proshade_double axHeight                          = 0.0;</div>
<div class="line"><a name="l02726"></a><span class="lineno"> 2726</span>&#160;    </div>
<div class="line"><a name="l02727"></a><span class="lineno"> 2727</span>&#160;    <span class="comment">//================================================ Find the angle and count dual matching frequencies</span></div>
<div class="line"><a name="l02728"></a><span class="lineno"> 2728</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign rIt = 0; rIt &lt; static_cast&lt;proshade_unsign&gt; ( retGroup-&gt;size() ); rIt++ )</div>
<div class="line"><a name="l02729"></a><span class="lineno"> 2729</span>&#160;    {</div>
<div class="line"><a name="l02730"></a><span class="lineno"> 2730</span>&#160;        dotProd                                       = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> ( &amp;ret-&gt;at(retGroup-&gt;at(rIt))[1],</div>
<div class="line"><a name="l02731"></a><span class="lineno"> 2731</span>&#160;                                                                                                     &amp;ret-&gt;at(retGroup-&gt;at(rIt))[2],</div>
<div class="line"><a name="l02732"></a><span class="lineno"> 2732</span>&#160;                                                                                                     &amp;ret-&gt;at(retGroup-&gt;at(rIt))[3],</div>
<div class="line"><a name="l02733"></a><span class="lineno"> 2733</span>&#160;                                                                                                     &amp;axX, &amp;axY, &amp;axZ );</div>
<div class="line"><a name="l02734"></a><span class="lineno"> 2734</span>&#160;        </div>
<div class="line"><a name="l02735"></a><span class="lineno"> 2735</span>&#160;        <span class="keywordflow">if</span> ( ( std::abs ( dotProd ) &gt; ( angle1 - axErr ) ) &amp;&amp; ( std::abs ( dotProd ) &lt; ( angle1 + axErr ) ) ) { noG1 += 1; <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l02736"></a><span class="lineno"> 2736</span>&#160;        <span class="keywordflow">if</span> ( ( std::abs ( dotProd ) &gt; ( angle2 - axErr ) ) &amp;&amp; ( std::abs ( dotProd ) &lt; ( angle2 + axErr ) ) ) { noG2 += 1; <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l02737"></a><span class="lineno"> 2737</span>&#160;        <span class="keywordflow">if</span> ( ( std::abs ( dotProd ) &gt; ( angle3 - axErr ) ) &amp;&amp; ( std::abs ( dotProd ) &lt; ( angle3 + axErr ) ) ) { noG3 += 1; <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l02738"></a><span class="lineno"> 2738</span>&#160;    }</div>
<div class="line"><a name="l02739"></a><span class="lineno"> 2739</span>&#160;    </div>
<div class="line"><a name="l02740"></a><span class="lineno"> 2740</span>&#160;    <span class="comment">//================================================ If correct frequencies are matched, check height.</span></div>
<div class="line"><a name="l02741"></a><span class="lineno"> 2741</span>&#160;    <span class="keywordflow">if</span> ( ( noG1 == noMatchesG1 ) &amp;&amp; ( noG2 == noMatchesG2 ) &amp;&amp; ( noG3 == noMatchesG3 ) )</div>
<div class="line"><a name="l02742"></a><span class="lineno"> 2742</span>&#160;    {</div>
<div class="line"><a name="l02743"></a><span class="lineno"> 2743</span>&#160;        <span class="comment">//============================================ Is the height good enough?</span></div>
<div class="line"><a name="l02744"></a><span class="lineno"> 2744</span>&#160;        axHeight                                      = <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad44ed609e8a3d59674b2b2256aec41f8">ProSHADE_internal_symmetry::missingAxisHeight</a> ( axX, axY, axZ, dataObj, fold, axErr );</div>
<div class="line"><a name="l02745"></a><span class="lineno"> 2745</span>&#160;        </div>
<div class="line"><a name="l02746"></a><span class="lineno"> 2746</span>&#160;        <span class="comment">//============================================ If so, save</span></div>
<div class="line"><a name="l02747"></a><span class="lineno"> 2747</span>&#160;        <span class="keywordflow">if</span> ( axHeight &gt; 0.1 )</div>
<div class="line"><a name="l02748"></a><span class="lineno"> 2748</span>&#160;        {</div>
<div class="line"><a name="l02749"></a><span class="lineno"> 2749</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a262d9e21cd6b81b8bda35ec22eb363dd">ProSHADE_internal_symmetry::addAxisUnlessSame</a> ( fold, axX, axY, axZ, axHeight, prosp, axErr );</div>
<div class="line"><a name="l02750"></a><span class="lineno"> 2750</span>&#160;        }</div>
<div class="line"><a name="l02751"></a><span class="lineno"> 2751</span>&#160;    }</div>
<div class="line"><a name="l02752"></a><span class="lineno"> 2752</span>&#160;    </div>
<div class="line"><a name="l02753"></a><span class="lineno"> 2753</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l02754"></a><span class="lineno"> 2754</span>&#160;    return ;</div>
<div class="line"><a name="l02755"></a><span class="lineno"> 2755</span>&#160;    </div>
<div class="line"><a name="l02756"></a><span class="lineno"> 2756</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4f09b90de1f15b345ee7998ff31327f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f09b90de1f15b345ee7998ff31327f3">&#9670;&nbsp;</a></span>detectIcosahedralSymmetry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_symmetry::detectIcosahedralSymmetry </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes the list of C symmetries and decides whether basic requirements for isosahedral symmetry are there. </p>
<p>This function first finds all the C5 symmetries in the C symmetries list and then it checks each present C5 against all C3 symmetries for having the angle between the pair equal to the dihedral angle of an icosahedron ( acos( sqrt(5)/3 ) ). If a single such pair is detected, this is likely an icosahedral symmetry and all other axes need to be located. Otherwise, false is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum average peak height required for symmetry axis to be considered. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>Boolean value telling whether there are C5 and C3 symmetries with icosahedral dihhedral angle. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01971">1971</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01972"></a><span class="lineno"> 1972</span>&#160;{</div>
<div class="line"><a name="l01973"></a><span class="lineno"> 1973</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l01974"></a><span class="lineno"> 1974</span>&#160;    std::vector&lt; proshade_unsign &gt; C5List;</div>
<div class="line"><a name="l01975"></a><span class="lineno"> 1975</span>&#160;    proshade_double dotProduct;</div>
<div class="line"><a name="l01976"></a><span class="lineno"> 1976</span>&#160;    </div>
<div class="line"><a name="l01977"></a><span class="lineno"> 1977</span>&#160;    <span class="comment">//================================================ Find all C5 symmetries</span></div>
<div class="line"><a name="l01978"></a><span class="lineno"> 1978</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign cSym = 0; cSym &lt; static_cast&lt;proshade_unsign&gt; ( CSymList-&gt;size() ); cSym++ )</div>
<div class="line"><a name="l01979"></a><span class="lineno"> 1979</span>&#160;    {</div>
<div class="line"><a name="l01980"></a><span class="lineno"> 1980</span>&#160;        <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; lhs1 ( CSymList-&gt;at(cSym)[0] ), rhs1 ( 5.0 );</div>
<div class="line"><a name="l01981"></a><span class="lineno"> 1981</span>&#160;        <span class="keywordflow">if</span> ( lhs1.AlmostEquals ( rhs1 ) &amp;&amp; CSymList-&gt;at(cSym)[5] &gt;= minPeakHeight ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C5List, cSym ); }</div>
<div class="line"><a name="l01982"></a><span class="lineno"> 1982</span>&#160;    }</div>
<div class="line"><a name="l01983"></a><span class="lineno"> 1983</span>&#160;    </div>
<div class="line"><a name="l01984"></a><span class="lineno"> 1984</span>&#160;    <span class="comment">//================================================ For each unique pair of C5 and C3</span></div>
<div class="line"><a name="l01985"></a><span class="lineno"> 1985</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign c5 = 0; c5 &lt; static_cast&lt;proshade_unsign&gt; ( C5List.size() ); c5++ )</div>
<div class="line"><a name="l01986"></a><span class="lineno"> 1986</span>&#160;    {</div>
<div class="line"><a name="l01987"></a><span class="lineno"> 1987</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign cSym = 0; cSym &lt; static_cast&lt;proshade_unsign&gt; ( CSymList-&gt;size() ); cSym++ )</div>
<div class="line"><a name="l01988"></a><span class="lineno"> 1988</span>&#160;        {</div>
<div class="line"><a name="l01989"></a><span class="lineno"> 1989</span>&#160;            <span class="comment">//======================================== Compare only C3s to the C5List</span></div>
<div class="line"><a name="l01990"></a><span class="lineno"> 1990</span>&#160;            <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; lhs1 ( CSymList-&gt;at(cSym)[0] ), rhs1 ( 3.0 );</div>
<div class="line"><a name="l01991"></a><span class="lineno"> 1991</span>&#160;            <span class="keywordflow">if</span> ( !lhs1.AlmostEquals ( rhs1 ) ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l01992"></a><span class="lineno"> 1992</span>&#160;            </div>
<div class="line"><a name="l01993"></a><span class="lineno"> 1993</span>&#160;            <span class="comment">//========================================  Check the angle between the C5 and C3 axes</span></div>
<div class="line"><a name="l01994"></a><span class="lineno"> 1994</span>&#160;            dotProduct                                = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> ( &amp;CSymList-&gt;at(C5List.at(c5))[1],</div>
<div class="line"><a name="l01995"></a><span class="lineno"> 1995</span>&#160;                                                                                                     &amp;CSymList-&gt;at(C5List.at(c5))[2],</div>
<div class="line"><a name="l01996"></a><span class="lineno"> 1996</span>&#160;                                                                                                     &amp;CSymList-&gt;at(C5List.at(c5))[3],</div>
<div class="line"><a name="l01997"></a><span class="lineno"> 1997</span>&#160;                                                                                                     &amp;CSymList-&gt;at(cSym)[1],</div>
<div class="line"><a name="l01998"></a><span class="lineno"> 1998</span>&#160;                                                                                                     &amp;CSymList-&gt;at(cSym)[2],</div>
<div class="line"><a name="l01999"></a><span class="lineno"> 1999</span>&#160;                                                                                                     &amp;CSymList-&gt;at(cSym)[3] );</div>
<div class="line"><a name="l02000"></a><span class="lineno"> 2000</span>&#160;            </div>
<div class="line"><a name="l02001"></a><span class="lineno"> 2001</span>&#160;            <span class="comment">//======================================== Is the angle approximately the dihedral angle</span></div>
<div class="line"><a name="l02002"></a><span class="lineno"> 2002</span>&#160;            <span class="keywordflow">if</span> ( std::abs ( std::abs( std::sqrt ( ( 1.0 + 2.0 / std::sqrt ( 5.0 ) ) / 3.0 ) ) - std::abs( dotProduct ) ) &lt; axErr )</div>
<div class="line"><a name="l02003"></a><span class="lineno"> 2003</span>&#160;            {</div>
<div class="line"><a name="l02004"></a><span class="lineno"> 2004</span>&#160;                <span class="keywordflow">return</span>                                ( <span class="keyword">true</span> );</div>
<div class="line"><a name="l02005"></a><span class="lineno"> 2005</span>&#160;            }</div>
<div class="line"><a name="l02006"></a><span class="lineno"> 2006</span>&#160;        }</div>
<div class="line"><a name="l02007"></a><span class="lineno"> 2007</span>&#160;    }</div>
<div class="line"><a name="l02008"></a><span class="lineno"> 2008</span>&#160;    </div>
<div class="line"><a name="l02009"></a><span class="lineno"> 2009</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l02010"></a><span class="lineno"> 2010</span>&#160;    <span class="keywordflow">return</span>                                            ( <span class="keyword">false</span> );</div>
<div class="line"><a name="l02011"></a><span class="lineno"> 2011</span>&#160;    </div>
<div class="line"><a name="l02012"></a><span class="lineno"> 2012</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a18d456057604616a7cf6b68f59b4f2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d456057604616a7cf6b68f59b4f2d0">&#9670;&nbsp;</a></span>detectOctahedralSymmetry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_symmetry::detectOctahedralSymmetry </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes the list of C symmetries and decides whether basic requirements for octahhedral symmetry are there. </p>
<p>This function first finds all the C4 symmetries in the C symmetries list and then it checks each present C4 against all C3 symmetries for having the angle between the pair equal to the dihedral angle of an octahedron ( acos(1/sqrt(3)) ). If a single such pair is detected, this is likely an octahedral symmetry and all other axes need to be located. Otherwise, false is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum average peak height for axis to be considered. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>Boolean value telling whether there are C4 and C3 symmetries with octahedral dihhedral angle. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01273">1273</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160;{</div>
<div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;    std::vector&lt; proshade_unsign &gt; C4List;</div>
<div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160;    proshade_double dotProduct;</div>
<div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;    </div>
<div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;    <span class="comment">//================================================ Find all C4 symmetries</span></div>
<div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign cSym = 0; cSym &lt; static_cast&lt;proshade_unsign&gt; ( CSymList-&gt;size() ); cSym++ )</div>
<div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160;    {</div>
<div class="line"><a name="l01282"></a><span class="lineno"> 1282</span>&#160;        <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; lhs1 ( CSymList-&gt;at(cSym)[0] ), rhs1 ( 4.0 );</div>
<div class="line"><a name="l01283"></a><span class="lineno"> 1283</span>&#160;        <span class="keywordflow">if</span> ( lhs1.AlmostEquals ( rhs1 ) &amp;&amp; CSymList-&gt;at(cSym)[5] &gt;= minPeakHeight ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C4List, cSym ); }</div>
<div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;    }</div>
<div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;    </div>
<div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;    <span class="comment">//================================================ For each unique pair of C3s</span></div>
<div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign c4 = 0; c4 &lt; static_cast&lt;proshade_unsign&gt; ( C4List.size() ); c4++ )</div>
<div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;    {</div>
<div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign cSym = 0; cSym &lt; static_cast&lt;proshade_unsign&gt; ( CSymList-&gt;size() ); cSym++ )</div>
<div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;        {</div>
<div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;            <span class="comment">//======================================== Compare only C3s to the C3List</span></div>
<div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;            <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; lhs1 ( CSymList-&gt;at(cSym)[0] ), rhs1 ( 3.0 );</div>
<div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160;            <span class="keywordflow">if</span> ( !lhs1.AlmostEquals ( rhs1 ) ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;            </div>
<div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160;            <span class="comment">//========================================  Check the angle between the C4 and C3 axes</span></div>
<div class="line"><a name="l01296"></a><span class="lineno"> 1296</span>&#160;            dotProduct                                = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> ( &amp;CSymList-&gt;at(C4List.at(c4))[1],</div>
<div class="line"><a name="l01297"></a><span class="lineno"> 1297</span>&#160;                                                                                                     &amp;CSymList-&gt;at(C4List.at(c4))[2],</div>
<div class="line"><a name="l01298"></a><span class="lineno"> 1298</span>&#160;                                                                                                     &amp;CSymList-&gt;at(C4List.at(c4))[3],</div>
<div class="line"><a name="l01299"></a><span class="lineno"> 1299</span>&#160;                                                                                                     &amp;CSymList-&gt;at(cSym)[1],</div>
<div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;                                                                                                     &amp;CSymList-&gt;at(cSym)[2],</div>
<div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;                                                                                                     &amp;CSymList-&gt;at(cSym)[3] );</div>
<div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;            </div>
<div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;            <span class="comment">//======================================== Is the angle approximately the dihedral angle</span></div>
<div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160;            <span class="keywordflow">if</span> ( ( ( 1.0 / sqrt ( 3.0 ) ) &gt; ( dotProduct - axErr ) ) &amp;&amp; ( ( 1.0 / sqrt ( 3.0 ) ) &lt; ( dotProduct + axErr ) ) )</div>
<div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160;            {</div>
<div class="line"><a name="l01306"></a><span class="lineno"> 1306</span>&#160;                <span class="keywordflow">return</span>                                ( <span class="keyword">true</span> );</div>
<div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;            }</div>
<div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;        }</div>
<div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;    }</div>
<div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;    </div>
<div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;    <span class="keywordflow">return</span>                                            ( <span class="keyword">false</span> );</div>
<div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;    </div>
<div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a37925ac477480c718451debb01a9c74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37925ac477480c718451debb01a9c74a">&#9670;&nbsp;</a></span>detectTetrahedralSymmetry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_symmetry::detectTetrahedralSymmetry </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes the list of C symmetries and decides whether basic requirements for tetrahedral symmetry are there. </p>
<p>This function first finds all the C3 symmetries in the C symmetries list and then it checks all pais of such present C3s for have the angle between the pair equal to the dihedral angle of a tetrahedron ( acos(1/3) ). If a single such pair is detected, this is likely a tetrahedral symmetry and all other axes need to be located. Otherwise, false is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum average peak height for axis to be considered. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>Boolean value telling whether there are two C3 symmetries with tetrahedral dihhedral angle. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00488">488</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;{</div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;    std::vector&lt; proshade_unsign &gt; C3List;</div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;    proshade_double dotProduct;</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;    </div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;    <span class="comment">//================================================ Find all C3 symmetries</span></div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign cSym = 0; cSym &lt; static_cast&lt;proshade_unsign&gt; ( CSymList-&gt;size() ); cSym++ )</div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;    {</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;        <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; lhs ( CSymList-&gt;at(cSym)[0] ), rhs ( 3.0 );</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;        <span class="keywordflow">if</span> ( lhs.AlmostEquals ( rhs ) &amp;&amp; CSymList-&gt;at(cSym)[5] &gt;= minPeakHeight ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C3List, cSym ); }</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;    }</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;    </div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;    <span class="comment">//================================================ For each unique pair of C3s</span></div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign c31 = 0; c31 &lt; static_cast&lt;proshade_unsign&gt; ( C3List.size() ); c31++ )</div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;    {</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign c32 = 1; c32 &lt; static_cast&lt;proshade_unsign&gt; ( C3List.size() ); c32++ )</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;        {</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;            <span class="comment">//================================ Unique pairs only</span></div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;            <span class="keywordflow">if</span> ( c31 &gt;= c32 ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;            </div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;            <span class="comment">//========================================  Check the angle between the C3 axes</span></div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;            dotProduct                                = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> ( &amp;CSymList-&gt;at(C3List.at(c31))[1], &amp;CSymList-&gt;at(C3List.at(c31))[2], &amp;CSymList-&gt;at(C3List.at(c31))[3], &amp;CSymList-&gt;at(C3List.at(c32))[1], &amp;CSymList-&gt;at(C3List.at(c32))[2], &amp;CSymList-&gt;at(C3List.at(c32))[3] );</div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;            </div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;            <span class="comment">//================================ Is the angle approximately the dihedral angle</span></div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;            <span class="keywordflow">if</span> ( ( ( 1.0 / 3.0 ) &gt; ( dotProduct - axErr ) ) &amp;&amp; ( ( 1.0 / 3.0 ) &lt; ( dotProduct + axErr ) ) )</div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;            {</div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;                <span class="keywordflow">return</span>                                ( <span class="keyword">true</span> );</div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;            }</div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;        }</div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;    }</div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;    </div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;    <span class="keywordflow">return</span>                                            ( <span class="keyword">false</span> );</div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;    </div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab53cd7561731d9426989f5ace523826a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab53cd7561731d9426989f5ace523826a">&#9670;&nbsp;</a></span>findIcos10C3s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::findIcos10C3s </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>messageShift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes the list of C symmetries and finds the ten C3 symmetries with correct angles required for full icosahedral symmetry. </p>
<p>This function is specific to detecting the icosahedral symmetry. It should be called once icosahedral symmetry is suspected (by detecting its dihedral angles) and it needs to be fully described. This function specifically searches for the ten C3 symmetries which must all be detected in order to fully describe icosahedral symmetry. If all ten are found, the ret vector will have these ten axes added to the already present six C5 axes; alternatively, the ret array size will not change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>The vector containing the already detected axes to which newly detected axes (if any) will be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum average peak height for axis to be considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>How loud the announcments should be? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">messageShift</td><td>Are we in a subprocess, so that the log should be shifted for this function call? If so, by how much? </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l02451">2451</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02452"></a><span class="lineno"> 2452</span>&#160;{</div>
<div class="line"><a name="l02453"></a><span class="lineno"> 2453</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l02454"></a><span class="lineno"> 2454</span>&#160;    std::vector&lt; proshade_unsign &gt; prospectiveC3s, retGrp;</div>
<div class="line"><a name="l02455"></a><span class="lineno"> 2455</span>&#160;    proshade_double dotProd;</div>
<div class="line"><a name="l02456"></a><span class="lineno"> 2456</span>&#160;    proshade_unsign noClose, noAway;</div>
<div class="line"><a name="l02457"></a><span class="lineno"> 2457</span>&#160;    </div>
<div class="line"><a name="l02458"></a><span class="lineno"> 2458</span>&#160;    <span class="comment">//================================================ Report progress</span></div>
<div class="line"><a name="l02459"></a><span class="lineno"> 2459</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a4f98d32ed17424a1d8bf451a68370e20">ProSHADE_internal_messages::printProgressMessage</a>  ( verbose, 2, <span class="stringliteral">&quot;Starting detection of ten C3 axes.&quot;</span>, messageShift );</div>
<div class="line"><a name="l02460"></a><span class="lineno"> 2460</span>&#160; </div>
<div class="line"><a name="l02461"></a><span class="lineno"> 2461</span>&#160;    <span class="comment">//================================================ For each C3</span></div>
<div class="line"><a name="l02462"></a><span class="lineno"> 2462</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign cIt = 0; cIt &lt; static_cast&lt;proshade_unsign&gt; ( CSymList-&gt;size() ); cIt++ )</div>
<div class="line"><a name="l02463"></a><span class="lineno"> 2463</span>&#160;    {</div>
<div class="line"><a name="l02464"></a><span class="lineno"> 2464</span>&#160;        <span class="comment">//============================================ Use only C3s with hight enough average</span></div>
<div class="line"><a name="l02465"></a><span class="lineno"> 2465</span>&#160;        <span class="keywordflow">if</span> ( CSymList-&gt;at(cIt)[0] != 3.0 || CSymList-&gt;at(cIt)[0] &lt; minPeakHeight ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l02466"></a><span class="lineno"> 2466</span>&#160; </div>
<div class="line"><a name="l02467"></a><span class="lineno"> 2467</span>&#160;        <span class="comment">//============================================ Check the C3 has acos ( std::sqrt ( ( 1.0 + 2.0 / std::sqrt ( 5.0 ) ) / 3.0 ) ) to 3 C5s and acos ( 1.0 - ( std::sqrt ( ( 1.0 + 2.0 / std::sqrt ( 5.0 ) ) / 3.0 ) ) ) to the other three C5s</span></div>
<div class="line"><a name="l02468"></a><span class="lineno"> 2468</span>&#160;        noClose = 0; noAway = 0;</div>
<div class="line"><a name="l02469"></a><span class="lineno"> 2469</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign rIt = 0; rIt &lt; 6; rIt++ )</div>
<div class="line"><a name="l02470"></a><span class="lineno"> 2470</span>&#160;        {</div>
<div class="line"><a name="l02471"></a><span class="lineno"> 2471</span>&#160;            dotProd                                   = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> ( &amp;ret-&gt;at(rIt)[1],</div>
<div class="line"><a name="l02472"></a><span class="lineno"> 2472</span>&#160;                                                                                                     &amp;ret-&gt;at(rIt)[2],</div>
<div class="line"><a name="l02473"></a><span class="lineno"> 2473</span>&#160;                                                                                                     &amp;ret-&gt;at(rIt)[3],</div>
<div class="line"><a name="l02474"></a><span class="lineno"> 2474</span>&#160;                                                                                                     &amp;CSymList-&gt;at(cIt)[1],</div>
<div class="line"><a name="l02475"></a><span class="lineno"> 2475</span>&#160;                                                                                                     &amp;CSymList-&gt;at(cIt)[2],</div>
<div class="line"><a name="l02476"></a><span class="lineno"> 2476</span>&#160;                                                                                                     &amp;CSymList-&gt;at(cIt)[3] );</div>
<div class="line"><a name="l02477"></a><span class="lineno"> 2477</span>&#160; </div>
<div class="line"><a name="l02478"></a><span class="lineno"> 2478</span>&#160;            <span class="keywordflow">if</span> ( ( std::abs ( dotProd ) &gt; (       ( std::sqrt ( ( 1.0 + 2.0 / std::sqrt ( 5.0 ) ) / 3.0 ) ) - axErr ) ) &amp;&amp; ( std::abs ( dotProd ) &lt; (       ( std::sqrt ( ( 1.0 + 2.0 / std::sqrt ( 5.0 ) ) / 3.0 ) ) + axErr ) ) ) { noClose += 1; <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l02479"></a><span class="lineno"> 2479</span>&#160;            <span class="keywordflow">if</span> ( ( std::abs ( dotProd ) &gt; ( 1.0 - ( std::sqrt ( ( 1.0 + 2.0 / std::sqrt ( 5.0 ) ) / 3.0 ) ) - axErr ) ) &amp;&amp; ( std::abs ( dotProd ) &lt; ( 1.0 - ( std::sqrt ( ( 1.0 + 2.0 / std::sqrt ( 5.0 ) ) / 3.0 ) ) + axErr ) ) ) { noAway  += 1; <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l02480"></a><span class="lineno"> 2480</span>&#160;        }</div>
<div class="line"><a name="l02481"></a><span class="lineno"> 2481</span>&#160; </div>
<div class="line"><a name="l02482"></a><span class="lineno"> 2482</span>&#160;        <span class="comment">//============================================ If correct angles distribution is found, save the axis</span></div>
<div class="line"><a name="l02483"></a><span class="lineno"> 2483</span>&#160;        <span class="keywordflow">if</span> ( ( noClose == 3 ) &amp;&amp; ( noAway == 3 ) )</div>
<div class="line"><a name="l02484"></a><span class="lineno"> 2484</span>&#160;        {</div>
<div class="line"><a name="l02485"></a><span class="lineno"> 2485</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;prospectiveC3s, cIt );</div>
<div class="line"><a name="l02486"></a><span class="lineno"> 2486</span>&#160;        }</div>
<div class="line"><a name="l02487"></a><span class="lineno"> 2487</span>&#160;    }</div>
<div class="line"><a name="l02488"></a><span class="lineno"> 2488</span>&#160; </div>
<div class="line"><a name="l02489"></a><span class="lineno"> 2489</span>&#160;    <span class="comment">//================================================ Search for missing axes</span></div>
<div class="line"><a name="l02490"></a><span class="lineno"> 2490</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; 6; iter++ ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;retGrp, iter ); }</div>
<div class="line"><a name="l02491"></a><span class="lineno"> 2491</span>&#160;    <span class="keywordflow">if</span> ( !<a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a6d9f533a789bd5c6031fa77b9649ed3d">ProSHADE_internal_symmetry::findMissingAxesDual</a> ( &amp;prospectiveC3s, CSymList, ret, &amp;retGrp, 10, axErr, 3, std::sqrt ( ( 1.0 + 2.0 / std::sqrt ( 5.0 ) ) / 3.0 ), 3, 1.0 - ( std::sqrt ( ( 1.0 + 2.0 / std::sqrt ( 5.0 ) ) / 3.0 ) ), 3, dataObj ) )</div>
<div class="line"><a name="l02492"></a><span class="lineno"> 2492</span>&#160;    {</div>
<div class="line"><a name="l02493"></a><span class="lineno"> 2493</span>&#160;        return ;</div>
<div class="line"><a name="l02494"></a><span class="lineno"> 2494</span>&#160;    }</div>
<div class="line"><a name="l02495"></a><span class="lineno"> 2495</span>&#160; </div>
<div class="line"><a name="l02496"></a><span class="lineno"> 2496</span>&#160;    <span class="comment">//================================================ Found correct number of axes! Now save the</span></div>
<div class="line"><a name="l02497"></a><span class="lineno"> 2497</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; static_cast&lt;proshade_unsign&gt; ( prospectiveC3s.size() ); iter++ )</div>
<div class="line"><a name="l02498"></a><span class="lineno"> 2498</span>&#160;    {</div>
<div class="line"><a name="l02499"></a><span class="lineno"> 2499</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a>     ( ret, CSymList-&gt;at(prospectiveC3s.at(iter)) );</div>
<div class="line"><a name="l02500"></a><span class="lineno"> 2500</span>&#160;    }</div>
<div class="line"><a name="l02501"></a><span class="lineno"> 2501</span>&#160; </div>
<div class="line"><a name="l02502"></a><span class="lineno"> 2502</span>&#160;    <span class="comment">//================================================ Report progress</span></div>
<div class="line"><a name="l02503"></a><span class="lineno"> 2503</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a4f98d32ed17424a1d8bf451a68370e20">ProSHADE_internal_messages::printProgressMessage</a>  ( verbose, 3, <span class="stringliteral">&quot;Detection of ten C3 axes successfull.&quot;</span>, messageShift );</div>
<div class="line"><a name="l02504"></a><span class="lineno"> 2504</span>&#160;    </div>
<div class="line"><a name="l02505"></a><span class="lineno"> 2505</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l02506"></a><span class="lineno"> 2506</span>&#160;    return ;</div>
<div class="line"><a name="l02507"></a><span class="lineno"> 2507</span>&#160;    </div>
<div class="line"><a name="l02508"></a><span class="lineno"> 2508</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a422414bb07db89a5c797f371a5448c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422414bb07db89a5c797f371a5448c0e">&#9670;&nbsp;</a></span>findIcos15C2s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::findIcos15C2s </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>messageShift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes the list of C symmetries and finds the fifteen C3 symmetries with correct angles required for full icosahedral symmetry. </p>
<p>This function is specific to detecting the icosahedral symmetry. It should be called once icosahedral symmetry is suspected (by detecting its dihedral angles) and it needs to be fully described. This function specifically searches for the ten C3 symmetries which must all be detected in order to fully describe icosahedral symmetry. If all ten are found, the ret vector will have these ten axes added to the already present six C5 axes; alternatively, the ret array size will not change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>The vector containing the already detected axes to which newly detected axes (if any) will be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum average peak height for axis to be considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>How loud the announcments should be? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">messageShift</td><td>Are we in a subprocess, so that the log should be shifted for this function call? If so, by how much? </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l02524">2524</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02525"></a><span class="lineno"> 2525</span>&#160;{</div>
<div class="line"><a name="l02526"></a><span class="lineno"> 2526</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l02527"></a><span class="lineno"> 2527</span>&#160;    std::vector&lt; proshade_unsign &gt; prospectiveC2s, retGrp;</div>
<div class="line"><a name="l02528"></a><span class="lineno"> 2528</span>&#160;    proshade_double dotProd;</div>
<div class="line"><a name="l02529"></a><span class="lineno"> 2529</span>&#160;    proshade_unsign noClose, noMidway, noAway;</div>
<div class="line"><a name="l02530"></a><span class="lineno"> 2530</span>&#160;    </div>
<div class="line"><a name="l02531"></a><span class="lineno"> 2531</span>&#160;    <span class="comment">//================================================ Report progress</span></div>
<div class="line"><a name="l02532"></a><span class="lineno"> 2532</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a4f98d32ed17424a1d8bf451a68370e20">ProSHADE_internal_messages::printProgressMessage</a>  ( verbose, 2, <span class="stringliteral">&quot;Starting detection of fifteen C2 axes.&quot;</span>, messageShift );</div>
<div class="line"><a name="l02533"></a><span class="lineno"> 2533</span>&#160; </div>
<div class="line"><a name="l02534"></a><span class="lineno"> 2534</span>&#160;    <span class="comment">//================================================ For each C2</span></div>
<div class="line"><a name="l02535"></a><span class="lineno"> 2535</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign cIt = 0; cIt &lt; static_cast&lt;proshade_unsign&gt; ( CSymList-&gt;size() ); cIt++ )</div>
<div class="line"><a name="l02536"></a><span class="lineno"> 2536</span>&#160;    {</div>
<div class="line"><a name="l02537"></a><span class="lineno"> 2537</span>&#160;        <span class="comment">//============================================ Use only C2s</span></div>
<div class="line"><a name="l02538"></a><span class="lineno"> 2538</span>&#160;        <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; lhs999 ( CSymList-&gt;at(cIt)[5] ), rhs999 ( <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( -999.9 ) );</div>
<div class="line"><a name="l02539"></a><span class="lineno"> 2539</span>&#160;        <span class="keywordflow">if</span> ( CSymList-&gt;at(cIt)[0] != 2.0 || ( ( CSymList-&gt;at(cIt)[5] &lt; minPeakHeight ) &amp;&amp; !( lhs999.AlmostEquals( rhs999 ) ) ) ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l02540"></a><span class="lineno"> 2540</span>&#160; </div>
<div class="line"><a name="l02541"></a><span class="lineno"> 2541</span>&#160;        <span class="comment">//============================================ Check the C2 has acos ( 0.0 ) to 2 C5s, acos ( 0.5 ) to another 2 C5s and acos ( sqrt ( 3.0 ) / 2.0 ) to the last two C5s</span></div>
<div class="line"><a name="l02542"></a><span class="lineno"> 2542</span>&#160;        noClose = 0; noMidway = 0; noAway = 0;</div>
<div class="line"><a name="l02543"></a><span class="lineno"> 2543</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign rIt = 0; rIt &lt; 6; rIt++ )</div>
<div class="line"><a name="l02544"></a><span class="lineno"> 2544</span>&#160;        {</div>
<div class="line"><a name="l02545"></a><span class="lineno"> 2545</span>&#160;            dotProd                                   = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> ( &amp;ret-&gt;at(rIt)[1],</div>
<div class="line"><a name="l02546"></a><span class="lineno"> 2546</span>&#160;                                                                                                     &amp;ret-&gt;at(rIt)[2],</div>
<div class="line"><a name="l02547"></a><span class="lineno"> 2547</span>&#160;                                                                                                     &amp;ret-&gt;at(rIt)[3],</div>
<div class="line"><a name="l02548"></a><span class="lineno"> 2548</span>&#160;                                                                                                     &amp;CSymList-&gt;at(cIt)[1],</div>
<div class="line"><a name="l02549"></a><span class="lineno"> 2549</span>&#160;                                                                                                     &amp;CSymList-&gt;at(cIt)[2],</div>
<div class="line"><a name="l02550"></a><span class="lineno"> 2550</span>&#160;                                                                                                     &amp;CSymList-&gt;at(cIt)[3] );</div>
<div class="line"><a name="l02551"></a><span class="lineno"> 2551</span>&#160; </div>
<div class="line"><a name="l02552"></a><span class="lineno"> 2552</span>&#160;            <span class="keywordflow">if</span> ( ( std::abs ( dotProd ) &gt; ( ( sqrt ( 3.0 ) / 2.0 ) - axErr ) ) &amp;&amp; ( std::abs ( dotProd ) &lt; ( ( sqrt ( 3.0 ) / 2.0 ) + axErr ) ) ) { noAway    += 1; <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l02553"></a><span class="lineno"> 2553</span>&#160;            <span class="keywordflow">if</span> ( ( std::abs ( dotProd ) &gt; ( ( 1.0 / 2.0 )          - axErr ) ) &amp;&amp; ( std::abs ( dotProd ) &lt; ( ( 1.0 / 2.0 )          + axErr ) ) ) { noMidway  += 1; <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l02554"></a><span class="lineno"> 2554</span>&#160;            <span class="keywordflow">if</span> ( ( std::abs ( dotProd ) &gt; ( ( 0.0 )                - axErr ) ) &amp;&amp; ( std::abs ( dotProd ) &lt; ( ( 0.0 )                + axErr ) ) ) { noClose   += 1; <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l02555"></a><span class="lineno"> 2555</span>&#160;        }</div>
<div class="line"><a name="l02556"></a><span class="lineno"> 2556</span>&#160; </div>
<div class="line"><a name="l02557"></a><span class="lineno"> 2557</span>&#160;        <span class="comment">//============================================ If correct angles distribution is found, save the axis</span></div>
<div class="line"><a name="l02558"></a><span class="lineno"> 2558</span>&#160;        <span class="keywordflow">if</span> ( ( noClose == 2 ) &amp;&amp; ( noMidway == 2 ) &amp;&amp; ( noAway == 2 ) )</div>
<div class="line"><a name="l02559"></a><span class="lineno"> 2559</span>&#160;        {</div>
<div class="line"><a name="l02560"></a><span class="lineno"> 2560</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;prospectiveC2s, cIt );</div>
<div class="line"><a name="l02561"></a><span class="lineno"> 2561</span>&#160;        }</div>
<div class="line"><a name="l02562"></a><span class="lineno"> 2562</span>&#160;    }</div>
<div class="line"><a name="l02563"></a><span class="lineno"> 2563</span>&#160; </div>
<div class="line"><a name="l02564"></a><span class="lineno"> 2564</span>&#160;    <span class="comment">//================================================ Search for missing axes</span></div>
<div class="line"><a name="l02565"></a><span class="lineno"> 2565</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; 6; iter++ ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;retGrp, iter ); }</div>
<div class="line"><a name="l02566"></a><span class="lineno"> 2566</span>&#160;    <span class="keywordflow">if</span> ( !<a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ae266053664eb7cf916aa5e2d282e35dd">ProSHADE_internal_symmetry::findMissingAxesTriple</a> ( &amp;prospectiveC2s, CSymList, ret, &amp;retGrp, 15, axErr, 2, 0.0, 2, 1.0/2.0, 2, sqrt ( 3.0 ) / 2.0, 2, dataObj ) )</div>
<div class="line"><a name="l02567"></a><span class="lineno"> 2567</span>&#160;    {</div>
<div class="line"><a name="l02568"></a><span class="lineno"> 2568</span>&#160;        return ;</div>
<div class="line"><a name="l02569"></a><span class="lineno"> 2569</span>&#160;    }</div>
<div class="line"><a name="l02570"></a><span class="lineno"> 2570</span>&#160;    </div>
<div class="line"><a name="l02571"></a><span class="lineno"> 2571</span>&#160;    <span class="comment">//================================================ Found correct number of axes! Now save the</span></div>
<div class="line"><a name="l02572"></a><span class="lineno"> 2572</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; static_cast&lt;proshade_unsign&gt; ( prospectiveC2s.size() ); iter++ )</div>
<div class="line"><a name="l02573"></a><span class="lineno"> 2573</span>&#160;    {</div>
<div class="line"><a name="l02574"></a><span class="lineno"> 2574</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a>     ( ret, CSymList-&gt;at(prospectiveC2s.at(iter)) );</div>
<div class="line"><a name="l02575"></a><span class="lineno"> 2575</span>&#160;    }</div>
<div class="line"><a name="l02576"></a><span class="lineno"> 2576</span>&#160; </div>
<div class="line"><a name="l02577"></a><span class="lineno"> 2577</span>&#160;    <span class="comment">//================================================ Report progress</span></div>
<div class="line"><a name="l02578"></a><span class="lineno"> 2578</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a4f98d32ed17424a1d8bf451a68370e20">ProSHADE_internal_messages::printProgressMessage</a>  ( verbose, 3, <span class="stringliteral">&quot;Detection of fifteen C2 axes successfull.&quot;</span>, messageShift );</div>
<div class="line"><a name="l02579"></a><span class="lineno"> 2579</span>&#160;    </div>
<div class="line"><a name="l02580"></a><span class="lineno"> 2580</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l02581"></a><span class="lineno"> 2581</span>&#160;    return ;</div>
<div class="line"><a name="l02582"></a><span class="lineno"> 2582</span>&#160;    </div>
<div class="line"><a name="l02583"></a><span class="lineno"> 2583</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af4dec365c5650c93198d73b6d259e4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4dec365c5650c93198d73b6d259e4e7">&#9670;&nbsp;</a></span>findIcos6C5s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::findIcos6C5s </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>messageShift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes the list of C symmetries and finds the six C5 symmetries with given angles required for full icosahedral symmetry. </p>
<p>This function searches the list of all detected C symmetries for the presence of six C5 symmetries, which have the angle of acos (0.5) to each other; this ability is specifically required for detection of icosahedral symmetry. This function allows for multiple groups of C5 symmetries, doing the missing symmetry axis checks and returning the group with highest average peak height. If successfull, the ret vector will have 6 entries, otherwise it will be empty.</p>
<p>This function is specific to detecting the octahedral symmetry. It should be called once octahedral symmetry is suspected (by detecting its dihedral angles) and it needs to be fully described. This function specifically searches for the three C4 symmetries which must all be detected in order to fully describe octahedral symmetry. If all three are found, the ret vector will contain these as its only four entries, while it will be empty if some of the C4 symmetries are not found. The missing symmetry axis detection is implemented as part of this function as well.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>The vector . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum average peak height for axis to be considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>How loud the announcments should be? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">messageShift</td><td>Are we in a subprocess, so that the log should be shifted for this function call? If so, by how much? </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l02032">2032</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02033"></a><span class="lineno"> 2033</span>&#160;{</div>
<div class="line"><a name="l02034"></a><span class="lineno"> 2034</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l02035"></a><span class="lineno"> 2035</span>&#160;    std::vector&lt; proshade_unsign &gt; C5PossibilitiesHlp;</div>
<div class="line"><a name="l02036"></a><span class="lineno"> 2036</span>&#160;    std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; C5Possibilities;</div>
<div class="line"><a name="l02037"></a><span class="lineno"> 2037</span>&#160;    <span class="keywordtype">bool</span> groupMatched;</div>
<div class="line"><a name="l02038"></a><span class="lineno"> 2038</span>&#160;    </div>
<div class="line"><a name="l02039"></a><span class="lineno"> 2039</span>&#160;    <span class="comment">//================================================ Report progress</span></div>
<div class="line"><a name="l02040"></a><span class="lineno"> 2040</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a4f98d32ed17424a1d8bf451a68370e20">ProSHADE_internal_messages::printProgressMessage</a>  ( verbose, 2, <span class="stringliteral">&quot;Starting detection of six C5 axes.&quot;</span>, messageShift );</div>
<div class="line"><a name="l02041"></a><span class="lineno"> 2041</span>&#160; </div>
<div class="line"><a name="l02042"></a><span class="lineno"> 2042</span>&#160;    <span class="comment">//================================================ For all symmetries in the C symmetries list</span></div>
<div class="line"><a name="l02043"></a><span class="lineno"> 2043</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign cIt = 0; cIt &lt; static_cast&lt;proshade_unsign&gt; ( CSymList-&gt;size() ); cIt++ )</div>
<div class="line"><a name="l02044"></a><span class="lineno"> 2044</span>&#160;    {</div>
<div class="line"><a name="l02045"></a><span class="lineno"> 2045</span>&#160;        <span class="comment">//============================================ Search only using C5s and check peak height</span></div>
<div class="line"><a name="l02046"></a><span class="lineno"> 2046</span>&#160;        <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; lhs1 ( CSymList-&gt;at(cIt)[0] ), rhs1 ( 5.0 );</div>
<div class="line"><a name="l02047"></a><span class="lineno"> 2047</span>&#160;        <span class="keywordflow">if</span> ( !lhs1.AlmostEquals ( rhs1 ) || CSymList-&gt;at(cIt)[5] &lt; minPeakHeight ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l02048"></a><span class="lineno"> 2048</span>&#160; </div>
<div class="line"><a name="l02049"></a><span class="lineno"> 2049</span>&#160;        <span class="comment">//============================================ If second or more C5, check if it has the correct angle to all other already found C5s for each group</span></div>
<div class="line"><a name="l02050"></a><span class="lineno"> 2050</span>&#160;        groupMatched                                  = <span class="keyword">false</span>;</div>
<div class="line"><a name="l02051"></a><span class="lineno"> 2051</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign gIt = 0; gIt &lt; static_cast&lt;proshade_unsign&gt; ( C5Possibilities.size() ); gIt++ )</div>
<div class="line"><a name="l02052"></a><span class="lineno"> 2052</span>&#160;        {</div>
<div class="line"><a name="l02053"></a><span class="lineno"> 2053</span>&#160;            <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad8c193e95c7069fafa78dccc1de1aaa4">ProSHADE_internal_symmetry::testGroupAgainstSymmetry</a> ( CSymList, &amp;C5Possibilities.at(gIt), CSymList-&gt;at(cIt), axErr, 1.0/2.0, <span class="keyword">true</span>, cIt ) ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C5Possibilities.at(gIt), cIt ); groupMatched = <span class="keyword">true</span>; <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l02054"></a><span class="lineno"> 2054</span>&#160;        }</div>
<div class="line"><a name="l02055"></a><span class="lineno"> 2055</span>&#160; </div>
<div class="line"><a name="l02056"></a><span class="lineno"> 2056</span>&#160;        <span class="comment">//============================================ If no group matched, create a new group</span></div>
<div class="line"><a name="l02057"></a><span class="lineno"> 2057</span>&#160;        <span class="keywordflow">if</span> ( !groupMatched ) { C5PossibilitiesHlp.clear(); <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C5PossibilitiesHlp, cIt ); <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a86e2bb172f766ab4a620df482d2fe481">ProSHADE_internal_misc::addToUnsignVectorVector</a> ( &amp;C5Possibilities, C5PossibilitiesHlp ); <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l02058"></a><span class="lineno"> 2058</span>&#160;    }</div>
<div class="line"><a name="l02059"></a><span class="lineno"> 2059</span>&#160;    </div>
<div class="line"><a name="l02060"></a><span class="lineno"> 2060</span>&#160;    <span class="comment">//================================================ Test for missing symmetry axes, if need be</span></div>
<div class="line"><a name="l02061"></a><span class="lineno"> 2061</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af6093da290ce7b73a33e8b55f2c83491">ProSHADE_internal_symmetry::findMissingAxes</a>       ( &amp;C5Possibilities, CSymList, 6, axErr, 1.0 / 2.0, 5, dataObj, minPeakHeight );</div>
<div class="line"><a name="l02062"></a><span class="lineno"> 2062</span>&#160; </div>
<div class="line"><a name="l02063"></a><span class="lineno"> 2063</span>&#160;    <span class="comment">//=================================================Any group has 6 entries? If more such groups, take the one with highest average height.</span></div>
<div class="line"><a name="l02064"></a><span class="lineno"> 2064</span>&#160;    proshade_double maxHeight = 0.0; proshade_unsign maxGrp = 0;</div>
<div class="line"><a name="l02065"></a><span class="lineno"> 2065</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; static_cast&lt;proshade_unsign&gt; ( C5Possibilities.size() ); iter++ ) { <span class="keywordflow">if</span> ( C5Possibilities.at(iter).size() == 6 ) { <span class="keywordflow">if</span> ( ( ( CSymList-&gt;at(C5Possibilities.at(iter).at(0))[5] + CSymList-&gt;at(C5Possibilities.at(iter).at(1))[5] + CSymList-&gt;at(C5Possibilities.at(iter).at(2))[5] + CSymList-&gt;at(C5Possibilities.at(iter).at(3))[5] + CSymList-&gt;at(C5Possibilities.at(iter).at(4))[5] + CSymList-&gt;at(C5Possibilities.at(iter).at(5))[5] ) / 6.0 ) &gt; maxHeight ) { maxHeight = ( ( CSymList-&gt;at(C5Possibilities.at(iter).at(0))[5] + CSymList-&gt;at(C5Possibilities.at(iter).at(1))[5] + CSymList-&gt;at(C5Possibilities.at(iter).at(2))[5] + CSymList-&gt;at(C5Possibilities.at(iter).at(3))[5] + CSymList-&gt;at(C5Possibilities.at(iter).at(4))[5] + CSymList-&gt;at(C5Possibilities.at(iter).at(5))[5] ) / 6.0 ); maxGrp = iter; } } }</div>
<div class="line"><a name="l02066"></a><span class="lineno"> 2066</span>&#160; </div>
<div class="line"><a name="l02067"></a><span class="lineno"> 2067</span>&#160;    <span class="keywordflow">if</span> ( C5Possibilities.at(maxGrp).size() == 6 )</div>
<div class="line"><a name="l02068"></a><span class="lineno"> 2068</span>&#160;    {</div>
<div class="line"><a name="l02069"></a><span class="lineno"> 2069</span>&#160;        <span class="comment">//============================================ Success! Save and exit</span></div>
<div class="line"><a name="l02070"></a><span class="lineno"> 2070</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign it = 0; it &lt; static_cast&lt;proshade_unsign&gt; ( C5Possibilities.at(maxGrp).size() ); it++ ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a> ( ret, CSymList-&gt;at(C5Possibilities.at(maxGrp).at(it)) ); }</div>
<div class="line"><a name="l02071"></a><span class="lineno"> 2071</span>&#160; </div>
<div class="line"><a name="l02072"></a><span class="lineno"> 2072</span>&#160;        <span class="comment">//============================================ Report progress</span></div>
<div class="line"><a name="l02073"></a><span class="lineno"> 2073</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a4f98d32ed17424a1d8bf451a68370e20">ProSHADE_internal_messages::printProgressMessage</a> ( verbose, 3, <span class="stringliteral">&quot;Detection of six C5 axes successfull.&quot;</span>, messageShift );</div>
<div class="line"><a name="l02074"></a><span class="lineno"> 2074</span>&#160; </div>
<div class="line"><a name="l02075"></a><span class="lineno"> 2075</span>&#160;        <span class="comment">//============================================ Done</span></div>
<div class="line"><a name="l02076"></a><span class="lineno"> 2076</span>&#160;        return ;</div>
<div class="line"><a name="l02077"></a><span class="lineno"> 2077</span>&#160;    }</div>
<div class="line"><a name="l02078"></a><span class="lineno"> 2078</span>&#160;    </div>
<div class="line"><a name="l02079"></a><span class="lineno"> 2079</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l02080"></a><span class="lineno"> 2080</span>&#160;    return ;</div>
<div class="line"><a name="l02081"></a><span class="lineno"> 2081</span>&#160;    </div>
<div class="line"><a name="l02082"></a><span class="lineno"> 2082</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af6093da290ce7b73a33e8b55f2c83491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6093da290ce7b73a33e8b55f2c83491">&#9670;&nbsp;</a></span>findMissingAxes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_symmetry::findMissingAxes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; *&#160;</td>
          <td class="paramname"><em>possibilities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>requiredNoAxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tries to find an axis which would complete a particular group of axes for polyhedral symmetry detection. </p>
<p>This function assumes that there is a set of already detected axes and that for a polyhedral symmetry, another axis with known fold and angle to some of the already detected axis needs to be found. It uses algebraic solution to try to find such an axis (or a given number of them) and also tests for these newly detected axes being unique and having at least minPeakHeight average peak height. If such axes are found, they are added to the CSymList vector and their indices are also added to the possibilities vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">possibilities</td><td>A vector of vectors of indices to the cyclic symmetries list with all the already determined axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">requiredNoAxes</td><td>Number of axes required for positive result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle</td><td>The angle that each group member is required to have against the symmetry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fold</td><td>The fold of the searched for axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataObj</td><td>The full data holding object pointer - this is to get access to self-rotation function values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum new axis average peak height in order for the axis to be added. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">atLeastOne</td><td>Boolean value speciying whether at least the minimum required number of axes was found. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00676">676</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;{</div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;    std::vector&lt; proshade_double* &gt; hlpVec;</div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;    <span class="keywordtype">bool</span> atLeastOne                                   = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;    </div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;    <span class="comment">//================================================ Proceed only if need be</span></div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign gIt = 0; gIt &lt; static_cast&lt;proshade_unsign&gt; ( possibilities-&gt;size() ); gIt++ )</div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;    {</div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;        <span class="keywordflow">if</span> ( <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( possibilities-&gt;at(gIt).size() ) == requiredNoAxes ) { atLeastOne = <span class="keyword">true</span>; <span class="keywordflow">return</span> ( atLeastOne ); }</div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;    }</div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;    </div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;    <span class="comment">//================================================ For each possible group</span></div>
<div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign gIt = 0; gIt &lt; static_cast&lt;proshade_unsign&gt; ( possibilities-&gt;size() ); gIt++ )</div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;    {</div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;        <span class="comment">//============================================ This will not work for less than two axes in group</span></div>
<div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;        <span class="keywordflow">if</span> ( possibilities-&gt;at(gIt).size() &lt; 2 ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;        </div>
<div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;        <span class="comment">//============================================ Prepare iteration</span></div>
<div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;        hlpVec.clear                                  ( );</div>
<div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;        </div>
<div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;        <span class="comment">//============================================ Search for missing axes</span></div>
<div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a1ada2416687dbb0bec93603770cb4c83">ProSHADE_internal_symmetry::searchMissingSymmetrySpace</a> ( dataObj, CSymList, &amp;possibilities-&gt;at(gIt), &amp;hlpVec, axErr, angle, fold, minPeakHeight );</div>
<div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;        </div>
<div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;        <span class="comment">//============================================ Add missing axes</span></div>
<div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;        <span class="keywordflow">if</span> ( hlpVec.size() &gt; 0 )</div>
<div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;        {</div>
<div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;            <span class="comment">//======================================== Start adding by highest first</span></div>
<div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;            std::sort                                 ( hlpVec.begin(), hlpVec.end(), <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a2e915d310892aea124046acd14db4a84">ProSHADE_internal_misc::sortSymHlpInv</a> );</div>
<div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;            </div>
<div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;            <span class="comment">//======================================== For each missing axis</span></div>
<div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;            <span class="keywordflow">for</span> ( proshade_unsign axIt = 0; axIt &lt; static_cast&lt;proshade_unsign&gt; ( hlpVec.size() ); axIt++ )</div>
<div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;            {</div>
<div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;                <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad8c193e95c7069fafa78dccc1de1aaa4">ProSHADE_internal_symmetry::testGroupAgainstSymmetry</a> ( CSymList, &amp;possibilities-&gt;at(gIt), hlpVec.at(axIt), axErr, angle, <span class="keyword">false</span> ) )</div>
<div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;                {</div>
<div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;                    <span class="comment">//================================ Check for uniqueness</span></div>
<div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;                    <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2380a3710f7dbe672519c3adda30f7cd">ProSHADE_internal_maths::isAxisUnique</a> ( CSymList, hlpVec.at(axIt), axErr ) )</div>
<div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;                    {</div>
<div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;                        <span class="comment">//============================ Add</span></div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;                        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a> ( CSymList, hlpVec.at(axIt) );</div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;                        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;possibilities-&gt;at(gIt), <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( CSymList-&gt;size()-1 ) );</div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;                    }</div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;                }</div>
<div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;            }</div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;        }</div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;        </div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;        <span class="keywordflow">if</span> ( possibilities-&gt;at(gIt).size() == requiredNoAxes ) { atLeastOne = <span class="keyword">true</span>; }</div>
<div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;    }</div>
<div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;    </div>
<div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;    <span class="keywordflow">return</span>                                            ( atLeastOne );</div>
<div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;    </div>
<div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6d9f533a789bd5c6031fa77b9649ed3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9f533a789bd5c6031fa77b9649ed3d">&#9670;&nbsp;</a></span>findMissingAxesDual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_symmetry::findMissingAxesDual </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>possibilities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>retGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>requiredNoAxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>noMatchesG1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>angle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>noMatchesG2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>angle2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tries to find a particular symmetry axes which would complete a group of symmetries with two different angle requirement to another group. </p>
<p>This function takes a list of axes to which a new axis should have two particular angles (to two different group members, that is). It then uses algebraic solution finding approach to compute possible solutions which would satisfy this condition, testing whether such solutions comply with the appropriate number of angles to number of members and for the new solutions being unique. If the required number of solutions is found, it will add the newly detected solutions to the CSymList vector and update the possibilities indices list, otherwise it will leave both alone.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">possibilities</td><td>A vector of already detected axis indices which should be extended. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>A list of already detected octahedral axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">retGroup</td><td>A vector of indices in the ret list which form the group to which new axes are compared to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">requiredNoAxes</td><td>Number of axes required for positive result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noMatchesG1</td><td>The number of axes from ret that need to be matched with angle1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle1</td><td>The angle with which noMatchesG1 axes need to be matched with the retGroup axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noMatchesG2</td><td>The number of axes from ret that need to be matched with angle2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle2</td><td>The angle with which noMatchesG2 axes need to be matched with the retGroup axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fold</td><td>The fold of the searched for axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataObj</td><td>The full data holding object pointer - this is to get access to self-rotation function values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">atLeastOne</td><td>Boolean value speciying whether at least the minimum required number of axes was found. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01562">1562</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01563"></a><span class="lineno"> 1563</span>&#160;{</div>
<div class="line"><a name="l01564"></a><span class="lineno"> 1564</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l01565"></a><span class="lineno"> 1565</span>&#160;    <span class="keywordtype">bool</span> atLeastOne                                   = <span class="keyword">false</span>;</div>
<div class="line"><a name="l01566"></a><span class="lineno"> 1566</span>&#160;    std::vector&lt; proshade_double* &gt; prosp;</div>
<div class="line"><a name="l01567"></a><span class="lineno"> 1567</span>&#160;    std::vector&lt; proshade_double &gt; sol;</div>
<div class="line"><a name="l01568"></a><span class="lineno"> 1568</span>&#160;    </div>
<div class="line"><a name="l01569"></a><span class="lineno"> 1569</span>&#160;    <span class="comment">//================================================ Proceed only if need be</span></div>
<div class="line"><a name="l01570"></a><span class="lineno"> 1570</span>&#160;    <span class="keywordflow">if</span> ( <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( possibilities-&gt;size() ) == requiredNoAxes ) { atLeastOne = <span class="keyword">true</span>; <span class="keywordflow">return</span> ( atLeastOne ); }</div>
<div class="line"><a name="l01571"></a><span class="lineno"> 1571</span>&#160;    </div>
<div class="line"><a name="l01572"></a><span class="lineno"> 1572</span>&#160;    <span class="comment">//================================================ Copy already found to prospective</span></div>
<div class="line"><a name="l01573"></a><span class="lineno"> 1573</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign prIt = 0; prIt &lt; static_cast&lt;proshade_unsign&gt; ( possibilities-&gt;size() ); prIt++ )</div>
<div class="line"><a name="l01574"></a><span class="lineno"> 1574</span>&#160;    {</div>
<div class="line"><a name="l01575"></a><span class="lineno"> 1575</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a262d9e21cd6b81b8bda35ec22eb363dd">ProSHADE_internal_symmetry::addAxisUnlessSame</a> ( <span class="keyword">static_cast&lt;</span> proshade_unsign <span class="keyword">&gt;</span> ( CSymList-&gt;at(possibilities-&gt;at(prIt))[0] ),</div>
<div class="line"><a name="l01576"></a><span class="lineno"> 1576</span>&#160;                                                        CSymList-&gt;at(possibilities-&gt;at(prIt))[1],</div>
<div class="line"><a name="l01577"></a><span class="lineno"> 1577</span>&#160;                                                        CSymList-&gt;at(possibilities-&gt;at(prIt))[2],</div>
<div class="line"><a name="l01578"></a><span class="lineno"> 1578</span>&#160;                                                        CSymList-&gt;at(possibilities-&gt;at(prIt))[3],</div>
<div class="line"><a name="l01579"></a><span class="lineno"> 1579</span>&#160;                                                        CSymList-&gt;at(possibilities-&gt;at(prIt))[5], &amp;prosp, axErr );</div>
<div class="line"><a name="l01580"></a><span class="lineno"> 1580</span>&#160;    }</div>
<div class="line"><a name="l01581"></a><span class="lineno"> 1581</span>&#160;    </div>
<div class="line"><a name="l01582"></a><span class="lineno"> 1582</span>&#160;    <span class="comment">//================================================ Start generating possible solutions</span></div>
<div class="line"><a name="l01583"></a><span class="lineno"> 1583</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign rgIt1 = 0; rgIt1 &lt; static_cast&lt;proshade_unsign&gt; ( retGroup-&gt;size() ); rgIt1++ )</div>
<div class="line"><a name="l01584"></a><span class="lineno"> 1584</span>&#160;    {</div>
<div class="line"><a name="l01585"></a><span class="lineno"> 1585</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign rgIt2 = 0; rgIt2 &lt; static_cast&lt;proshade_unsign&gt; ( retGroup-&gt;size() ); rgIt2++ )</div>
<div class="line"><a name="l01586"></a><span class="lineno"> 1586</span>&#160;        {</div>
<div class="line"><a name="l01587"></a><span class="lineno"> 1587</span>&#160;            <span class="comment">//======================================== Use unique combinations (order matters here!)</span></div>
<div class="line"><a name="l01588"></a><span class="lineno"> 1588</span>&#160;            <span class="keywordflow">if</span> ( rgIt1 == rgIt2 ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l01589"></a><span class="lineno"> 1589</span>&#160;            </div>
<div class="line"><a name="l01590"></a><span class="lineno"> 1590</span>&#160;            <span class="comment">//======================================== Generate possible solution (1)</span></div>
<div class="line"><a name="l01591"></a><span class="lineno"> 1591</span>&#160;            sol                                       = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a45fbcfaeaabf9bae2fbd7d46a5fb4bc7">ProSHADE_internal_maths::findVectorFromTwoVAndTwoD</a> ( ret-&gt;at(rgIt1)[1], ret-&gt;at(rgIt1)[2], ret-&gt;at(rgIt1)[3],</div>
<div class="line"><a name="l01592"></a><span class="lineno"> 1592</span>&#160;                                                                                                             ret-&gt;at(rgIt2)[1], ret-&gt;at(rgIt2)[2], ret-&gt;at(rgIt2)[3], angle1, angle2 );</div>
<div class="line"><a name="l01593"></a><span class="lineno"> 1593</span>&#160;            </div>
<div class="line"><a name="l01594"></a><span class="lineno"> 1594</span>&#160;            <span class="comment">//======================================== Check if solution fits the group completely</span></div>
<div class="line"><a name="l01595"></a><span class="lineno"> 1595</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a210ee0af651d440b68168882ead71c66">ProSHADE_internal_symmetry::checkFittingAxisDualAndSave</a> ( retGroup, ret, fold, sol.at(0), sol.at(1), sol.at(2), &amp;prosp, axErr, noMatchesG1, angle1, noMatchesG2, angle2, dataObj );</div>
<div class="line"><a name="l01596"></a><span class="lineno"> 1596</span>&#160;            <span class="keywordflow">if</span> ( prosp.size() == requiredNoAxes ) { <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l01597"></a><span class="lineno"> 1597</span>&#160;            </div>
<div class="line"><a name="l01598"></a><span class="lineno"> 1598</span>&#160;            <span class="comment">//======================================== Generate possible solution (2)</span></div>
<div class="line"><a name="l01599"></a><span class="lineno"> 1599</span>&#160;            sol                                       = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a45fbcfaeaabf9bae2fbd7d46a5fb4bc7">ProSHADE_internal_maths::findVectorFromTwoVAndTwoD</a> ( ret-&gt;at(rgIt1)[1], ret-&gt;at(rgIt1)[2], ret-&gt;at(rgIt1)[3],</div>
<div class="line"><a name="l01600"></a><span class="lineno"> 1600</span>&#160;                                                                                                             ret-&gt;at(rgIt2)[1], ret-&gt;at(rgIt2)[2], ret-&gt;at(rgIt2)[3], -angle1, -angle2 );</div>
<div class="line"><a name="l01601"></a><span class="lineno"> 1601</span>&#160;            </div>
<div class="line"><a name="l01602"></a><span class="lineno"> 1602</span>&#160;            <span class="comment">//======================================== Check if solution fits the group completely</span></div>
<div class="line"><a name="l01603"></a><span class="lineno"> 1603</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a210ee0af651d440b68168882ead71c66">ProSHADE_internal_symmetry::checkFittingAxisDualAndSave</a> ( retGroup, ret, fold, sol.at(0), sol.at(1), sol.at(2), &amp;prosp, axErr, noMatchesG1, angle1, noMatchesG2, angle2, dataObj );</div>
<div class="line"><a name="l01604"></a><span class="lineno"> 1604</span>&#160;            <span class="keywordflow">if</span> ( prosp.size() == requiredNoAxes ) { <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l01605"></a><span class="lineno"> 1605</span>&#160;        }</div>
<div class="line"><a name="l01606"></a><span class="lineno"> 1606</span>&#160;        </div>
<div class="line"><a name="l01607"></a><span class="lineno"> 1607</span>&#160;        <span class="keywordflow">if</span> ( prosp.size() == requiredNoAxes ) { <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l01608"></a><span class="lineno"> 1608</span>&#160;    }</div>
<div class="line"><a name="l01609"></a><span class="lineno"> 1609</span>&#160; </div>
<div class="line"><a name="l01610"></a><span class="lineno"> 1610</span>&#160;    <span class="comment">//================================================ Found all required axes!</span></div>
<div class="line"><a name="l01611"></a><span class="lineno"> 1611</span>&#160;    <span class="keywordflow">if</span> ( <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( prosp.size() ) == requiredNoAxes )</div>
<div class="line"><a name="l01612"></a><span class="lineno"> 1612</span>&#160;    {</div>
<div class="line"><a name="l01613"></a><span class="lineno"> 1613</span>&#160;        <span class="comment">//============================================ Copy the detected axes</span></div>
<div class="line"><a name="l01614"></a><span class="lineno"> 1614</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign iter = <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( possibilities-&gt;size() ); iter &lt; <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( prosp.size() ); iter++ )</div>
<div class="line"><a name="l01615"></a><span class="lineno"> 1615</span>&#160;        {</div>
<div class="line"><a name="l01616"></a><span class="lineno"> 1616</span>&#160;            <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2380a3710f7dbe672519c3adda30f7cd">ProSHADE_internal_maths::isAxisUnique</a> ( CSymList, prosp.at(iter), axErr ) )</div>
<div class="line"><a name="l01617"></a><span class="lineno"> 1617</span>&#160;            {</div>
<div class="line"><a name="l01618"></a><span class="lineno"> 1618</span>&#160;                <span class="comment">//==================================== Add</span></div>
<div class="line"><a name="l01619"></a><span class="lineno"> 1619</span>&#160;                <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( possibilities, <span class="keyword">static_cast&lt;</span> proshade_unsign <span class="keyword">&gt;</span> ( CSymList-&gt;size() ) );</div>
<div class="line"><a name="l01620"></a><span class="lineno"> 1620</span>&#160;                <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a> ( CSymList, prosp.at(iter) );</div>
<div class="line"><a name="l01621"></a><span class="lineno"> 1621</span>&#160;            }</div>
<div class="line"><a name="l01622"></a><span class="lineno"> 1622</span>&#160;        }</div>
<div class="line"><a name="l01623"></a><span class="lineno"> 1623</span>&#160;        </div>
<div class="line"><a name="l01624"></a><span class="lineno"> 1624</span>&#160;        <span class="comment">//============================================ Done</span></div>
<div class="line"><a name="l01625"></a><span class="lineno"> 1625</span>&#160;        atLeastOne                                    = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01626"></a><span class="lineno"> 1626</span>&#160;        <span class="keywordflow">return</span>                                        ( atLeastOne );</div>
<div class="line"><a name="l01627"></a><span class="lineno"> 1627</span>&#160;    }</div>
<div class="line"><a name="l01628"></a><span class="lineno"> 1628</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l01629"></a><span class="lineno"> 1629</span>&#160;    {</div>
<div class="line"><a name="l01630"></a><span class="lineno"> 1630</span>&#160;        <span class="comment">//============================================ Delete the created, but not used axes</span></div>
<div class="line"><a name="l01631"></a><span class="lineno"> 1631</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign iter = <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( possibilities-&gt;size() ); iter &lt; <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( prosp.size() ); iter++ )</div>
<div class="line"><a name="l01632"></a><span class="lineno"> 1632</span>&#160;        {</div>
<div class="line"><a name="l01633"></a><span class="lineno"> 1633</span>&#160;            <span class="keyword">delete</span>[] prosp.at(iter);</div>
<div class="line"><a name="l01634"></a><span class="lineno"> 1634</span>&#160;        }</div>
<div class="line"><a name="l01635"></a><span class="lineno"> 1635</span>&#160;    }</div>
<div class="line"><a name="l01636"></a><span class="lineno"> 1636</span>&#160;    </div>
<div class="line"><a name="l01637"></a><span class="lineno"> 1637</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01638"></a><span class="lineno"> 1638</span>&#160;    <span class="keywordflow">return</span>                                            ( atLeastOne );</div>
<div class="line"><a name="l01639"></a><span class="lineno"> 1639</span>&#160;    </div>
<div class="line"><a name="l01640"></a><span class="lineno"> 1640</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae266053664eb7cf916aa5e2d282e35dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae266053664eb7cf916aa5e2d282e35dd">&#9670;&nbsp;</a></span>findMissingAxesTriple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_symmetry::findMissingAxesTriple </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>possibilities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>retGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>requiredNoAxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>noMatchesG1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>angle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>noMatchesG2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>angle2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>noMatchesG3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>angle3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tries to find a particular symmetry axis which would complete a group of symmetries with three different angle requirement to another group. </p>
<p>Assuming there is a group of symmetry axis, which have particular number of particular angles to each other, but some are missing, this function tries to find any such missing axes. This is a solution for the group of axes having three different angles to the other group members. For all newly detected group members, the average peak height and the uniqueness are both tested for.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">possibilities</td><td>A vector of already detected axis indices which should be extended. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>A list of already detected octahedral axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">retGroup</td><td>A vector of indices in the ret list which form the group to which new axes are compared to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">requiredNoAxes</td><td>Number of axes required for positive result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noMatchesG1</td><td>The number of axes from ret that need to be matched with angle1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle1</td><td>The angle with which noMatchesG1 axes need to be matched with the retGroup axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noMatchesG2</td><td>The number of axes from ret that need to be matched with angle2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle2</td><td>The angle with which noMatchesG2 axes need to be matched with the retGroup axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noMatchesG3</td><td>The number of axes from ret that need to be matched with angle3. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle3</td><td>The angle with which noMatchesG3 axes need to be matched with the retGroup axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fold</td><td>The fold of the searched for axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataObj</td><td>The full data holding object pointer - this is to get access to self-rotation function values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">atLeastOne</td><td>Boolean value speciying whether at least the minimum required number of axes was found. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l02607">2607</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02608"></a><span class="lineno"> 2608</span>&#160;{</div>
<div class="line"><a name="l02609"></a><span class="lineno"> 2609</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l02610"></a><span class="lineno"> 2610</span>&#160;    <span class="keywordtype">bool</span> atLeastOne                                   = <span class="keyword">false</span>;</div>
<div class="line"><a name="l02611"></a><span class="lineno"> 2611</span>&#160;    std::vector&lt; proshade_double* &gt; prosp;</div>
<div class="line"><a name="l02612"></a><span class="lineno"> 2612</span>&#160;    std::vector&lt; proshade_double &gt; sol;</div>
<div class="line"><a name="l02613"></a><span class="lineno"> 2613</span>&#160;    </div>
<div class="line"><a name="l02614"></a><span class="lineno"> 2614</span>&#160;    <span class="comment">//================================================ Proceed only if need be</span></div>
<div class="line"><a name="l02615"></a><span class="lineno"> 2615</span>&#160;    <span class="keywordflow">if</span> ( <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( possibilities-&gt;size() ) == requiredNoAxes ) { atLeastOne = <span class="keyword">true</span>; <span class="keywordflow">return</span> ( atLeastOne ); }</div>
<div class="line"><a name="l02616"></a><span class="lineno"> 2616</span>&#160;    </div>
<div class="line"><a name="l02617"></a><span class="lineno"> 2617</span>&#160;    <span class="comment">//================================================ Copy already found to prospective</span></div>
<div class="line"><a name="l02618"></a><span class="lineno"> 2618</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign prIt = 0; prIt &lt; static_cast&lt;proshade_unsign&gt; ( possibilities-&gt;size() ); prIt++ )</div>
<div class="line"><a name="l02619"></a><span class="lineno"> 2619</span>&#160;    {</div>
<div class="line"><a name="l02620"></a><span class="lineno"> 2620</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a262d9e21cd6b81b8bda35ec22eb363dd">ProSHADE_internal_symmetry::addAxisUnlessSame</a> ( <span class="keyword">static_cast&lt;</span> proshade_unsign <span class="keyword">&gt;</span> ( CSymList-&gt;at(possibilities-&gt;at(prIt))[0] ),</div>
<div class="line"><a name="l02621"></a><span class="lineno"> 2621</span>&#160;                                                        CSymList-&gt;at(possibilities-&gt;at(prIt))[1],</div>
<div class="line"><a name="l02622"></a><span class="lineno"> 2622</span>&#160;                                                        CSymList-&gt;at(possibilities-&gt;at(prIt))[2],</div>
<div class="line"><a name="l02623"></a><span class="lineno"> 2623</span>&#160;                                                        CSymList-&gt;at(possibilities-&gt;at(prIt))[3],</div>
<div class="line"><a name="l02624"></a><span class="lineno"> 2624</span>&#160;                                                        CSymList-&gt;at(possibilities-&gt;at(prIt))[5], &amp;prosp, axErr );</div>
<div class="line"><a name="l02625"></a><span class="lineno"> 2625</span>&#160;    }</div>
<div class="line"><a name="l02626"></a><span class="lineno"> 2626</span>&#160;    </div>
<div class="line"><a name="l02627"></a><span class="lineno"> 2627</span>&#160;    <span class="comment">//================================================ Start generating possible solutions</span></div>
<div class="line"><a name="l02628"></a><span class="lineno"> 2628</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign rgIt1 = 0; rgIt1 &lt; static_cast&lt;proshade_unsign&gt; ( retGroup-&gt;size() ); rgIt1++ )</div>
<div class="line"><a name="l02629"></a><span class="lineno"> 2629</span>&#160;    {</div>
<div class="line"><a name="l02630"></a><span class="lineno"> 2630</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign rgIt2 = 0; rgIt2 &lt; static_cast&lt;proshade_unsign&gt; ( retGroup-&gt;size() ); rgIt2++ )</div>
<div class="line"><a name="l02631"></a><span class="lineno"> 2631</span>&#160;        {</div>
<div class="line"><a name="l02632"></a><span class="lineno"> 2632</span>&#160;            <span class="comment">//======================================== Use unique combinations (order matters here!)</span></div>
<div class="line"><a name="l02633"></a><span class="lineno"> 2633</span>&#160;            <span class="keywordflow">if</span> ( rgIt1 == rgIt2 ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l02634"></a><span class="lineno"> 2634</span>&#160;            </div>
<div class="line"><a name="l02635"></a><span class="lineno"> 2635</span>&#160;            <span class="keywordflow">for</span> ( proshade_unsign rgIt3 = 0; rgIt3 &lt; static_cast&lt;proshade_unsign&gt; ( retGroup-&gt;size() ); rgIt3++ )</div>
<div class="line"><a name="l02636"></a><span class="lineno"> 2636</span>&#160;            {</div>
<div class="line"><a name="l02637"></a><span class="lineno"> 2637</span>&#160;                <span class="comment">//==================================== Use unique combinations (order matters here!)</span></div>
<div class="line"><a name="l02638"></a><span class="lineno"> 2638</span>&#160;                <span class="keywordflow">if</span> ( ( rgIt1 == rgIt3 ) || ( rgIt2 == rgIt3 ) ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l02639"></a><span class="lineno"> 2639</span>&#160;                </div>
<div class="line"><a name="l02640"></a><span class="lineno"> 2640</span>&#160;                <span class="comment">//==================================== Generate possible solution (1)</span></div>
<div class="line"><a name="l02641"></a><span class="lineno"> 2641</span>&#160;                sol                                   = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#ae9f376bb341b192fff008b9b4ef5c603">ProSHADE_internal_maths::findVectorFromThreeVAndThreeD</a> ( ret-&gt;at(rgIt1)[1], ret-&gt;at(rgIt1)[2], ret-&gt;at(rgIt1)[3],</div>
<div class="line"><a name="l02642"></a><span class="lineno"> 2642</span>&#160;                                                                                                                 ret-&gt;at(rgIt2)[1], ret-&gt;at(rgIt2)[2], ret-&gt;at(rgIt2)[3],</div>
<div class="line"><a name="l02643"></a><span class="lineno"> 2643</span>&#160;                                                                                                                 ret-&gt;at(rgIt3)[1], ret-&gt;at(rgIt3)[2], ret-&gt;at(rgIt3)[3], angle1, angle2, angle3 );</div>
<div class="line"><a name="l02644"></a><span class="lineno"> 2644</span>&#160;                </div>
<div class="line"><a name="l02645"></a><span class="lineno"> 2645</span>&#160;                <span class="comment">//==================================== Check if solution fits the group completely</span></div>
<div class="line"><a name="l02646"></a><span class="lineno"> 2646</span>&#160;                <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a194944b48a4b6b523ef251a2a03eab17">ProSHADE_internal_symmetry::checkFittingAxisTripleAndSave</a> ( retGroup, ret, fold, sol.at(0), sol.at(1), sol.at(2), &amp;prosp, axErr, noMatchesG1, angle1, noMatchesG2, angle2, noMatchesG3, angle3, dataObj );</div>
<div class="line"><a name="l02647"></a><span class="lineno"> 2647</span>&#160;                <span class="keywordflow">if</span> ( prosp.size() == requiredNoAxes ) { <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l02648"></a><span class="lineno"> 2648</span>&#160;                </div>
<div class="line"><a name="l02649"></a><span class="lineno"> 2649</span>&#160;                <span class="comment">//==================================== Generate possible solution (2)</span></div>
<div class="line"><a name="l02650"></a><span class="lineno"> 2650</span>&#160;                sol                                   = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#ae9f376bb341b192fff008b9b4ef5c603">ProSHADE_internal_maths::findVectorFromThreeVAndThreeD</a> ( ret-&gt;at(rgIt1)[1], ret-&gt;at(rgIt1)[2], ret-&gt;at(rgIt1)[3],</div>
<div class="line"><a name="l02651"></a><span class="lineno"> 2651</span>&#160;                                                                                                                 ret-&gt;at(rgIt2)[1], ret-&gt;at(rgIt2)[2], ret-&gt;at(rgIt2)[3],</div>
<div class="line"><a name="l02652"></a><span class="lineno"> 2652</span>&#160;                                                                                                                 ret-&gt;at(rgIt3)[1], ret-&gt;at(rgIt3)[2], ret-&gt;at(rgIt3)[3], -angle1, -angle2, -angle3 );</div>
<div class="line"><a name="l02653"></a><span class="lineno"> 2653</span>&#160;                </div>
<div class="line"><a name="l02654"></a><span class="lineno"> 2654</span>&#160;                <span class="comment">//==================================== Check if solution fits the group completely</span></div>
<div class="line"><a name="l02655"></a><span class="lineno"> 2655</span>&#160;                <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a194944b48a4b6b523ef251a2a03eab17">ProSHADE_internal_symmetry::checkFittingAxisTripleAndSave</a> ( retGroup, ret, fold, sol.at(0), sol.at(1), sol.at(2), &amp;prosp, axErr, noMatchesG1, angle1, noMatchesG2, angle2, noMatchesG3, angle3, dataObj );</div>
<div class="line"><a name="l02656"></a><span class="lineno"> 2656</span>&#160;                <span class="keywordflow">if</span> ( prosp.size() == requiredNoAxes ) { <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l02657"></a><span class="lineno"> 2657</span>&#160;            }</div>
<div class="line"><a name="l02658"></a><span class="lineno"> 2658</span>&#160;            </div>
<div class="line"><a name="l02659"></a><span class="lineno"> 2659</span>&#160;            <span class="keywordflow">if</span> ( prosp.size() == requiredNoAxes ) { <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l02660"></a><span class="lineno"> 2660</span>&#160;        }</div>
<div class="line"><a name="l02661"></a><span class="lineno"> 2661</span>&#160;        </div>
<div class="line"><a name="l02662"></a><span class="lineno"> 2662</span>&#160;        <span class="keywordflow">if</span> ( prosp.size() == requiredNoAxes ) { <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l02663"></a><span class="lineno"> 2663</span>&#160;    }</div>
<div class="line"><a name="l02664"></a><span class="lineno"> 2664</span>&#160;    </div>
<div class="line"><a name="l02665"></a><span class="lineno"> 2665</span>&#160;    <span class="comment">//================================================ Found all required axes</span></div>
<div class="line"><a name="l02666"></a><span class="lineno"> 2666</span>&#160;    <span class="keywordflow">if</span> ( prosp.size() == requiredNoAxes )</div>
<div class="line"><a name="l02667"></a><span class="lineno"> 2667</span>&#160;    {</div>
<div class="line"><a name="l02668"></a><span class="lineno"> 2668</span>&#160;        <span class="comment">//============================================ For each found missing axis</span></div>
<div class="line"><a name="l02669"></a><span class="lineno"> 2669</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign axIt = <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( possibilities-&gt;size() ); axIt &lt; <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( prosp.size() ); axIt++ )</div>
<div class="line"><a name="l02670"></a><span class="lineno"> 2670</span>&#160;        {</div>
<div class="line"><a name="l02671"></a><span class="lineno"> 2671</span>&#160;            <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2380a3710f7dbe672519c3adda30f7cd">ProSHADE_internal_maths::isAxisUnique</a> ( CSymList, prosp.at(axIt), axErr ) )</div>
<div class="line"><a name="l02672"></a><span class="lineno"> 2672</span>&#160;            {</div>
<div class="line"><a name="l02673"></a><span class="lineno"> 2673</span>&#160;                <span class="comment">//======================================== Add</span></div>
<div class="line"><a name="l02674"></a><span class="lineno"> 2674</span>&#160;                <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a> ( CSymList, prosp.at(axIt) );</div>
<div class="line"><a name="l02675"></a><span class="lineno"> 2675</span>&#160;                <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( possibilities, <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( CSymList-&gt;size()-1 ) );</div>
<div class="line"><a name="l02676"></a><span class="lineno"> 2676</span>&#160;            }</div>
<div class="line"><a name="l02677"></a><span class="lineno"> 2677</span>&#160;        }</div>
<div class="line"><a name="l02678"></a><span class="lineno"> 2678</span>&#160;        </div>
<div class="line"><a name="l02679"></a><span class="lineno"> 2679</span>&#160;        atLeastOne                                    = <span class="keyword">true</span>;</div>
<div class="line"><a name="l02680"></a><span class="lineno"> 2680</span>&#160;        <span class="keywordflow">return</span>                                        ( atLeastOne );</div>
<div class="line"><a name="l02681"></a><span class="lineno"> 2681</span>&#160;    }</div>
<div class="line"><a name="l02682"></a><span class="lineno"> 2682</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l02683"></a><span class="lineno"> 2683</span>&#160;    {</div>
<div class="line"><a name="l02684"></a><span class="lineno"> 2684</span>&#160;        <span class="comment">//============================================ Delete all found, but unnecessary axes</span></div>
<div class="line"><a name="l02685"></a><span class="lineno"> 2685</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign axIt = <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( possibilities-&gt;size() ); axIt &lt; <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( prosp.size() ); axIt++ )</div>
<div class="line"><a name="l02686"></a><span class="lineno"> 2686</span>&#160;        {</div>
<div class="line"><a name="l02687"></a><span class="lineno"> 2687</span>&#160;            <span class="keyword">delete</span>[] prosp.at(axIt);</div>
<div class="line"><a name="l02688"></a><span class="lineno"> 2688</span>&#160;        }</div>
<div class="line"><a name="l02689"></a><span class="lineno"> 2689</span>&#160;    }</div>
<div class="line"><a name="l02690"></a><span class="lineno"> 2690</span>&#160;    </div>
<div class="line"><a name="l02691"></a><span class="lineno"> 2691</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l02692"></a><span class="lineno"> 2692</span>&#160;    <span class="keywordflow">return</span>                                            ( atLeastOne );</div>
<div class="line"><a name="l02693"></a><span class="lineno"> 2693</span>&#160;    </div>
<div class="line"><a name="l02694"></a><span class="lineno"> 2694</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a465606e58df7d6a2238d40c6919b2e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a465606e58df7d6a2238d40c6919b2e58">&#9670;&nbsp;</a></span>findMissingAxisPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; proshade_double * &gt; ProSHADE_internal_symmetry::findMissingAxisPoints </td>
          <td>(</td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>xVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>yVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>zVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function searches for all the self-rotation map points conforming to the axis, returning their angles and heights. </p>
<p>This helper function searches the self-rotation map point by point for all points which represent the same rotation axis as required by the input parameters. For all such points, it records the angle they represent and the map height associated with them. Finally, it returns a vector of all detected points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xVal</td><td>The x-axis element of the axis to have the height detected. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yVal</td><td>The y-axis element of the axis to have the height detected. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zVal</td><td>The z-axis element of the axis to have the height detected. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataObj</td><td>The full data holding object pointer - this is to get access to self-rotation function values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">angVec</td><td>Vector containing all map points which conform to the required axis along with their heights. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00821">821</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;{</div>
<div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;    proshade_double euA, euB, euG, xPk, yPk, zPk, anglPk;</div>
<div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;    proshade_double* rotMat                           = <span class="keyword">new</span> proshade_double [9];</div>
<div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( rotMat, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;    proshade_unsign arrIndex;</div>
<div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;    std::vector&lt; proshade_double* &gt; angVec;</div>
<div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;    </div>
<div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;    <span class="comment">//================================================ Search the self-rotation map</span></div>
<div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign xIt = 0; xIt &lt; ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a152b43815a3d3debd4b60751d9c8afdd">getMaxBand</a>() * 2 ); xIt++ )</div>
<div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;    {</div>
<div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign yIt = 0; yIt &lt; ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a152b43815a3d3debd4b60751d9c8afdd">getMaxBand</a>() * 2 ); yIt++ )</div>
<div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;        {</div>
<div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;            <span class="keywordflow">for</span> ( proshade_unsign zIt = 0; zIt &lt; ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a152b43815a3d3debd4b60751d9c8afdd">getMaxBand</a>() * 2 ); zIt++ )</div>
<div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;            {</div>
<div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;                <span class="comment">//==================================== Get height and check against threshold</span></div>
<div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;                arrIndex                              = zIt  + ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a152b43815a3d3debd4b60751d9c8afdd">getMaxBand</a>() * 2 ) * ( yIt  + ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a152b43815a3d3debd4b60751d9c8afdd">getMaxBand</a>() * 2 ) * xIt );</div>
<div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;                </div>
<div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;                <span class="comment">//==================================== Get angle-axis values</span></div>
<div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;                <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#acf6c5376edac98e54ef0e418cd05d706">ProSHADE_internal_maths::getEulerZXZFromSOFTPosition</a> ( <span class="keyword">static_cast&lt;</span> proshade_signed <span class="keyword">&gt;</span> ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a152b43815a3d3debd4b60751d9c8afdd">getMaxBand</a>() ), <span class="keyword">static_cast&lt;</span> proshade_signed <span class="keyword">&gt;</span> ( xIt ),</div>
<div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;                                                                       <span class="keyword">static_cast&lt;</span> proshade_signed <span class="keyword">&gt;</span> ( yIt ), <span class="keyword">static_cast&lt;</span> proshade_signed <span class="keyword">&gt;</span> ( zIt ),</div>
<div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;                                                                       &amp;euA, &amp;euB, &amp;euG );</div>
<div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;                <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#abd9fe573a48f499dd7d1df4f779222f1">ProSHADE_internal_maths::getRotationMatrixFromEulerZXZAngles</a> ( euA, euB, euG, rotMat );</div>
<div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;                <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#aad5409074bece14a244fad191524a687">ProSHADE_internal_maths::getAxisAngleFromRotationMatrix</a> ( rotMat, &amp;xPk, &amp;yPk, &amp;zPk, &amp;anglPk );</div>
<div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;                </div>
<div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;                <span class="comment">//==================================== Set largest axis element to positive</span></div>
<div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;                <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; lhs1 ( std::max ( std::abs ( xPk ), std::max( std::abs ( yPk ), std::abs ( zPk ) ) ) );</div>
<div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;                <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; rhs1 ( std::abs ( xPk ));</div>
<div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;                <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; rhs2 ( std::abs ( yPk ) );</div>
<div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;                <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; rhs3 ( std::abs ( zPk ) );</div>
<div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;                <span class="keywordflow">if</span> ( ( lhs1.AlmostEquals ( rhs1 ) &amp;&amp; ( xPk &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;                     ( lhs1.AlmostEquals ( rhs2 ) &amp;&amp; ( yPk &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;                     ( lhs1.AlmostEquals ( rhs3 ) &amp;&amp; ( zPk &lt; 0.0 ) ) )</div>
<div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;                {</div>
<div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;                    xPk                              *= -1.0;</div>
<div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;                    yPk                              *= -1.0;</div>
<div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;                    zPk                              *= -1.0;</div>
<div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;                    anglPk                           *= -1.0;</div>
<div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;                }</div>
<div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;                </div>
<div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;                <span class="comment">//==================================== Does the peak match the required axis?</span></div>
<div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;                <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2b2f67cba1eea57f19fdaf062db74fde">ProSHADE_internal_maths::vectorOrientationSimilarity</a> ( xPk, yPk, zPk, xVal, yVal, zVal, axErr ) )</div>
<div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;                {</div>
<div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;                    <span class="comment">//================================ Matching map point - save it</span></div>
<div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;                    proshade_double* hlpArr           = <span class="keyword">new</span> proshade_double [2];</div>
<div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;                    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a> ( hlpArr, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;                    hlpArr[0]                         = anglPk + M_PI;</div>
<div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;                    hlpArr[1]                         = pow( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a2eb10989a2f8d46b849cdaf8410b68be">getInvSO3Coeffs</a>()[arrIndex][0], 2.0 ) +</div>
<div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;                                                        pow( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a2eb10989a2f8d46b849cdaf8410b68be">getInvSO3Coeffs</a>()[arrIndex][1], 2.0 );</div>
<div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;                    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a> ( &amp;angVec, hlpArr );</div>
<div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;                }</div>
<div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;            }</div>
<div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;        }</div>
<div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;    }</div>
<div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;    </div>
<div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;    <span class="comment">//================================================ Release memory</span></div>
<div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;    <span class="keyword">delete</span>[] rotMat;</div>
<div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;    </div>
<div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;    <span class="keywordflow">return</span>                                            ( angVec );</div>
<div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;    </div>
<div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a31e25079d4a20a0d6442c7fb36fdeaea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e25079d4a20a0d6442c7fb36fdeaea">&#9670;&nbsp;</a></span>findOcta3C4s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::findOcta3C4s </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>messageShift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes the list of C symmetries and finds the 3 C4 symmetries with perpendicular angles required for full octahedral symmetry. </p>
<p>This function is specific to detecting the octahedral symmetry. It should be called once octahedral symmetry is suspected (by detecting its dihedral angles) and it needs to be fully described. This function specifically searches for the three C4 symmetries which must all be detected in order to fully describe octahedral symmetry. If all three are found, the ret vector will contain these as its only four entries, while it will be empty if some of the C4 symmetries are not found. The missing symmetry axis detection is implemented as part of this function as well.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>The vector containing all axes required for the octahedral symmetry detected so far. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum average peak height for axis to be considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>How loud the announcments should be? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">messageShift</td><td>Are we in a subprocess, so that the log should be shifted for this function call? If so, by how much? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The threshold for peak height. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01331">1331</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01332"></a><span class="lineno"> 1332</span>&#160;{</div>
<div class="line"><a name="l01333"></a><span class="lineno"> 1333</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l01334"></a><span class="lineno"> 1334</span>&#160;    std::vector&lt; proshade_unsign &gt; C4PossibilitiesHlp;</div>
<div class="line"><a name="l01335"></a><span class="lineno"> 1335</span>&#160;    std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; C4Possibilities;</div>
<div class="line"><a name="l01336"></a><span class="lineno"> 1336</span>&#160;    <span class="keywordtype">bool</span> groupMatched;</div>
<div class="line"><a name="l01337"></a><span class="lineno"> 1337</span>&#160;    </div>
<div class="line"><a name="l01338"></a><span class="lineno"> 1338</span>&#160;    <span class="comment">//================================================ Report progress</span></div>
<div class="line"><a name="l01339"></a><span class="lineno"> 1339</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a4f98d32ed17424a1d8bf451a68370e20">ProSHADE_internal_messages::printProgressMessage</a>  ( verbose, 2, <span class="stringliteral">&quot;Starting detection of three C4 axes.&quot;</span>, messageShift );</div>
<div class="line"><a name="l01340"></a><span class="lineno"> 1340</span>&#160;    </div>
<div class="line"><a name="l01341"></a><span class="lineno"> 1341</span>&#160;    <span class="comment">//================================================ For all symmetries in the C symmetries list</span></div>
<div class="line"><a name="l01342"></a><span class="lineno"> 1342</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign cIt = 0; cIt &lt; static_cast&lt;proshade_unsign&gt; ( CSymList-&gt;size() ); cIt++ )</div>
<div class="line"><a name="l01343"></a><span class="lineno"> 1343</span>&#160;    {</div>
<div class="line"><a name="l01344"></a><span class="lineno"> 1344</span>&#160;        <span class="comment">//============================================ Search only using C4s</span></div>
<div class="line"><a name="l01345"></a><span class="lineno"> 1345</span>&#160;        <span class="keywordflow">if</span> ( CSymList-&gt;at(cIt)[0] != 4.0 || CSymList-&gt;at(cIt)[5] &lt; minPeakHeight ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l01346"></a><span class="lineno"> 1346</span>&#160; </div>
<div class="line"><a name="l01347"></a><span class="lineno"> 1347</span>&#160;        <span class="comment">//============================================ If second or more C4, check if it has the correct angle to all other already found C4s for each group</span></div>
<div class="line"><a name="l01348"></a><span class="lineno"> 1348</span>&#160;        groupMatched                                  = <span class="keyword">false</span>;</div>
<div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign gIt = 0; gIt &lt; static_cast&lt;proshade_unsign&gt; ( C4Possibilities.size() ); gIt++ )</div>
<div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160;        {</div>
<div class="line"><a name="l01351"></a><span class="lineno"> 1351</span>&#160;            <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad8c193e95c7069fafa78dccc1de1aaa4">ProSHADE_internal_symmetry::testGroupAgainstSymmetry</a> ( CSymList, &amp;C4Possibilities.at(gIt), CSymList-&gt;at(cIt), axErr, 0.0, <span class="keyword">true</span>, cIt ) ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C4Possibilities.at(gIt), cIt ); groupMatched = <span class="keyword">true</span>; <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160;        }</div>
<div class="line"><a name="l01353"></a><span class="lineno"> 1353</span>&#160; </div>
<div class="line"><a name="l01354"></a><span class="lineno"> 1354</span>&#160;        <span class="comment">//=========================================== If no group matched, create a new group</span></div>
<div class="line"><a name="l01355"></a><span class="lineno"> 1355</span>&#160;        <span class="keywordflow">if</span> ( !groupMatched ) { C4PossibilitiesHlp.clear(); <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C4PossibilitiesHlp, cIt ); <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a86e2bb172f766ab4a620df482d2fe481">ProSHADE_internal_misc::addToUnsignVectorVector</a> ( &amp;C4Possibilities, C4PossibilitiesHlp ); <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l01356"></a><span class="lineno"> 1356</span>&#160;    }</div>
<div class="line"><a name="l01357"></a><span class="lineno"> 1357</span>&#160; </div>
<div class="line"><a name="l01358"></a><span class="lineno"> 1358</span>&#160;    <span class="comment">//================================================ Test for missing symmetry axes, if need be</span></div>
<div class="line"><a name="l01359"></a><span class="lineno"> 1359</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af6093da290ce7b73a33e8b55f2c83491">ProSHADE_internal_symmetry::findMissingAxes</a>       ( &amp;C4Possibilities, CSymList, 3, axErr, 0.0, 4, dataObj, minPeakHeight );</div>
<div class="line"><a name="l01360"></a><span class="lineno"> 1360</span>&#160; </div>
<div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160;    <span class="comment">//================================================ Any group has 3 entries? If more such groups, take the one with highest average height.</span></div>
<div class="line"><a name="l01362"></a><span class="lineno"> 1362</span>&#160;    proshade_double maxHeight = 0.0; proshade_unsign maxGrp = 0;</div>
<div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; static_cast&lt;proshade_unsign&gt; ( C4Possibilities.size() ); iter++ ) { <span class="keywordflow">if</span> ( C4Possibilities.at(iter).size() == 3 ) { <span class="keywordflow">if</span> ( ( ( CSymList-&gt;at(C4Possibilities.at(iter).at(0))[5] + CSymList-&gt;at(C4Possibilities.at(iter).at(1))[5] + CSymList-&gt;at(C4Possibilities.at(iter).at(2))[5] ) / 3.0 ) &gt; maxHeight ) { maxHeight = ( ( CSymList-&gt;at(C4Possibilities.at(iter).at(0))[5] + CSymList-&gt;at(C4Possibilities.at(iter).at(1))[5] + CSymList-&gt;at(C4Possibilities.at(iter).at(2))[5] ) / 3.0 ); maxGrp = iter; } } }</div>
<div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160;    </div>
<div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160;    <span class="keywordflow">if</span> ( C4Possibilities.at(maxGrp).size() == 3 )</div>
<div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160;    {</div>
<div class="line"><a name="l01367"></a><span class="lineno"> 1367</span>&#160;        <span class="comment">//============================================ Success! Save and exit</span></div>
<div class="line"><a name="l01368"></a><span class="lineno"> 1368</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign it = 0; it &lt; static_cast&lt;proshade_unsign&gt; ( C4Possibilities.at(maxGrp).size() ); it++ ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a> ( ret, CSymList-&gt;at(C4Possibilities.at(maxGrp).at(it)) ); }</div>
<div class="line"><a name="l01369"></a><span class="lineno"> 1369</span>&#160;        </div>
<div class="line"><a name="l01370"></a><span class="lineno"> 1370</span>&#160;        <span class="comment">//============================================ Report progress</span></div>
<div class="line"><a name="l01371"></a><span class="lineno"> 1371</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a4f98d32ed17424a1d8bf451a68370e20">ProSHADE_internal_messages::printProgressMessage</a> ( verbose, 3, <span class="stringliteral">&quot;Detection of three C4 axes successfull.&quot;</span>, messageShift );</div>
<div class="line"><a name="l01372"></a><span class="lineno"> 1372</span>&#160;        </div>
<div class="line"><a name="l01373"></a><span class="lineno"> 1373</span>&#160;        <span class="comment">//============================================ Done</span></div>
<div class="line"><a name="l01374"></a><span class="lineno"> 1374</span>&#160;        return ;</div>
<div class="line"><a name="l01375"></a><span class="lineno"> 1375</span>&#160;    }</div>
<div class="line"><a name="l01376"></a><span class="lineno"> 1376</span>&#160;    </div>
<div class="line"><a name="l01377"></a><span class="lineno"> 1377</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01378"></a><span class="lineno"> 1378</span>&#160;    return ;</div>
<div class="line"><a name="l01379"></a><span class="lineno"> 1379</span>&#160;    </div>
<div class="line"><a name="l01380"></a><span class="lineno"> 1380</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1db775b80f6ce426bb98d87f8ba99d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db775b80f6ce426bb98d87f8ba99d72">&#9670;&nbsp;</a></span>findOcta4C3s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::findOcta4C3s </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>messageShift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes the list of C symmetries and finds the four C3 symmetries with correct angles required for full octahedral symmetry. </p>
<p>This function is specific to detecting the tetrahedral symmetry. It should be called once tetrahedral symmetry is suspected (by detecting its dihedral angles) and it needs to be fully described. This function specifically searches for the four C3 symmetries which must all be detected in order to fully describe octahedral symmetry. If all four are found, the ret vector will have these four axes added to the already present three C4 axes; alternatively, the ret array size will not change. In order not to replicate computations, if tetrahedral symmetry has already been detected, the four axes sought here are the same as the first four axes detected there, so simple copying is used instead of re-computing the results anew.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>The vector . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>How loud the announcments should be? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">messageShift</td><td>Are we in a subprocess, so that the log should be shifted for this function call? If so, by how much? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum average peak height for axis to be considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TetraSymList</td><td>A vector containing the already detected tetrahedral symmetries - this is to avoid the same search for four C3 symmetry axes. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01398">1398</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01399"></a><span class="lineno"> 1399</span>&#160;{</div>
<div class="line"><a name="l01400"></a><span class="lineno"> 1400</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l01401"></a><span class="lineno"> 1401</span>&#160;    std::vector&lt; proshade_unsign &gt; C4s, prospectiveC3s, C3PossibilitiesHlp;</div>
<div class="line"><a name="l01402"></a><span class="lineno"> 1402</span>&#160;    std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; C3Possibilities;</div>
<div class="line"><a name="l01403"></a><span class="lineno"> 1403</span>&#160;    proshade_double dotProd;</div>
<div class="line"><a name="l01404"></a><span class="lineno"> 1404</span>&#160;    <span class="keywordtype">bool</span> groupMatched;</div>
<div class="line"><a name="l01405"></a><span class="lineno"> 1405</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; 3; iter++ ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C4s, iter ); }</div>
<div class="line"><a name="l01406"></a><span class="lineno"> 1406</span>&#160;    </div>
<div class="line"><a name="l01407"></a><span class="lineno"> 1407</span>&#160;    <span class="comment">//================================================ Report progress</span></div>
<div class="line"><a name="l01408"></a><span class="lineno"> 1408</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a4f98d32ed17424a1d8bf451a68370e20">ProSHADE_internal_messages::printProgressMessage</a>  ( verbose, 2, <span class="stringliteral">&quot;Starting detection of four C3 axes.&quot;</span>, messageShift );</div>
<div class="line"><a name="l01409"></a><span class="lineno"> 1409</span>&#160;    </div>
<div class="line"><a name="l01410"></a><span class="lineno"> 1410</span>&#160;    <span class="comment">//================================================ For each C4</span></div>
<div class="line"><a name="l01411"></a><span class="lineno"> 1411</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign rIt = 0; rIt &lt; static_cast&lt;proshade_unsign&gt; ( ret-&gt;size() ); rIt++ )</div>
<div class="line"><a name="l01412"></a><span class="lineno"> 1412</span>&#160;    {</div>
<div class="line"><a name="l01413"></a><span class="lineno"> 1413</span>&#160;        <span class="comment">//============================================ For each C3, check it has angle ( acos( 1/sqrt(3) ) ) to the tested C4</span></div>
<div class="line"><a name="l01414"></a><span class="lineno"> 1414</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign cIt = 0; cIt &lt; static_cast&lt;proshade_unsign&gt; ( CSymList-&gt;size() ); cIt++ )</div>
<div class="line"><a name="l01415"></a><span class="lineno"> 1415</span>&#160;        {</div>
<div class="line"><a name="l01416"></a><span class="lineno"> 1416</span>&#160;            <span class="comment">//======================================== Search only using C3s</span></div>
<div class="line"><a name="l01417"></a><span class="lineno"> 1417</span>&#160;            <span class="keywordflow">if</span> ( CSymList-&gt;at(cIt)[0] != 3.0 || CSymList-&gt;at(cIt)[5] &lt; minPeakHeight ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l01418"></a><span class="lineno"> 1418</span>&#160;            </div>
<div class="line"><a name="l01419"></a><span class="lineno"> 1419</span>&#160;            <span class="comment">//======================================== Check the C3 axis to the C4 ( acos ( 1/sqrt(3) ) )</span></div>
<div class="line"><a name="l01420"></a><span class="lineno"> 1420</span>&#160;            dotProd = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> ( &amp;ret-&gt;at(rIt)[1], &amp;ret-&gt;at(rIt)[2], &amp;ret-&gt;at(rIt)[3], &amp;CSymList-&gt;at(cIt)[1], &amp;CSymList-&gt;at(cIt)[2], &amp;CSymList-&gt;at(cIt)[3] );</div>
<div class="line"><a name="l01421"></a><span class="lineno"> 1421</span>&#160;            </div>
<div class="line"><a name="l01422"></a><span class="lineno"> 1422</span>&#160;            <span class="keywordflow">if</span> ( ( std::abs ( dotProd ) &gt; ( ( 1.0 / sqrt(3.0) ) - axErr ) ) &amp;&amp; ( std::abs ( dotProd ) &lt; ( ( 1.0 / sqrt(3.0) ) + axErr ) ) ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;prospectiveC3s, cIt ); }</div>
<div class="line"><a name="l01423"></a><span class="lineno"> 1423</span>&#160;        }</div>
<div class="line"><a name="l01424"></a><span class="lineno"> 1424</span>&#160;    }</div>
<div class="line"><a name="l01425"></a><span class="lineno"> 1425</span>&#160;    </div>
<div class="line"><a name="l01426"></a><span class="lineno"> 1426</span>&#160;    <span class="comment">//================================================ Group the prospective C3s</span></div>
<div class="line"><a name="l01427"></a><span class="lineno"> 1427</span>&#160;    C3Possibilities.clear(); C3PossibilitiesHlp.clear();</div>
<div class="line"><a name="l01428"></a><span class="lineno"> 1428</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign cIt = 0; cIt &lt; static_cast&lt;proshade_unsign&gt; ( prospectiveC3s.size() ); cIt++ )</div>
<div class="line"><a name="l01429"></a><span class="lineno"> 1429</span>&#160;    {</div>
<div class="line"><a name="l01430"></a><span class="lineno"> 1430</span>&#160;        <span class="comment">//============================================ If second or more C3, check if it can be placed in any group with having acos (1/3) to all its members</span></div>
<div class="line"><a name="l01431"></a><span class="lineno"> 1431</span>&#160;        groupMatched                                  = <span class="keyword">false</span>;</div>
<div class="line"><a name="l01432"></a><span class="lineno"> 1432</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign gIt = 0; gIt &lt; static_cast&lt;proshade_unsign&gt; ( C3Possibilities.size() ); gIt++ )</div>
<div class="line"><a name="l01433"></a><span class="lineno"> 1433</span>&#160;        {</div>
<div class="line"><a name="l01434"></a><span class="lineno"> 1434</span>&#160;            <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad8c193e95c7069fafa78dccc1de1aaa4">ProSHADE_internal_symmetry::testGroupAgainstSymmetry</a> ( CSymList, &amp;C3Possibilities.at(gIt), CSymList-&gt;at(prospectiveC3s.at(cIt)), axErr, 1.0/3.0, <span class="keyword">true</span>, prospectiveC3s.at(cIt) ) ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C3Possibilities.at(gIt), prospectiveC3s.at(cIt) ); groupMatched = <span class="keyword">true</span>; <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l01435"></a><span class="lineno"> 1435</span>&#160;        }</div>
<div class="line"><a name="l01436"></a><span class="lineno"> 1436</span>&#160; </div>
<div class="line"><a name="l01437"></a><span class="lineno"> 1437</span>&#160;        <span class="comment">//============================================ If no group matched, create a new group</span></div>
<div class="line"><a name="l01438"></a><span class="lineno"> 1438</span>&#160;        <span class="keywordflow">if</span> ( !groupMatched ) { C3PossibilitiesHlp.clear(); <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C3PossibilitiesHlp, prospectiveC3s.at(cIt) ); <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a86e2bb172f766ab4a620df482d2fe481">ProSHADE_internal_misc::addToUnsignVectorVector</a> ( &amp;C3Possibilities, C3PossibilitiesHlp ); <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l01439"></a><span class="lineno"> 1439</span>&#160;    }</div>
<div class="line"><a name="l01440"></a><span class="lineno"> 1440</span>&#160; </div>
<div class="line"><a name="l01441"></a><span class="lineno"> 1441</span>&#160;    <span class="comment">//================================================ Find the best group or return empty</span></div>
<div class="line"><a name="l01442"></a><span class="lineno"> 1442</span>&#160;    <span class="keywordflow">while</span> ( C3Possibilities.size() != 0 )</div>
<div class="line"><a name="l01443"></a><span class="lineno"> 1443</span>&#160;    {</div>
<div class="line"><a name="l01444"></a><span class="lineno"> 1444</span>&#160;        <span class="comment">//============================================ Test for missing symmetry axes, if need be</span></div>
<div class="line"><a name="l01445"></a><span class="lineno"> 1445</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af6093da290ce7b73a33e8b55f2c83491">ProSHADE_internal_symmetry::findMissingAxes</a> ( &amp;C3Possibilities, CSymList, 4, axErr, 1.0/3.0, 3, dataObj, minPeakHeight );</div>
<div class="line"><a name="l01446"></a><span class="lineno"> 1446</span>&#160; </div>
<div class="line"><a name="l01447"></a><span class="lineno"> 1447</span>&#160;        <span class="comment">//============================================ Found four C3s?</span></div>
<div class="line"><a name="l01448"></a><span class="lineno"> 1448</span>&#160;        <span class="keywordflow">if</span> ( C3Possibilities.at(0).size() == 4 )</div>
<div class="line"><a name="l01449"></a><span class="lineno"> 1449</span>&#160;        {</div>
<div class="line"><a name="l01450"></a><span class="lineno"> 1450</span>&#160;            <span class="comment">//======================================== Success! Save and exit</span></div>
<div class="line"><a name="l01451"></a><span class="lineno"> 1451</span>&#160;            <span class="keywordflow">for</span> ( proshade_unsign it = 0; it &lt; 4; it++ ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a> ( ret, CSymList-&gt;at(C3Possibilities.at(0).at(it)) ); }</div>
<div class="line"><a name="l01452"></a><span class="lineno"> 1452</span>&#160; </div>
<div class="line"><a name="l01453"></a><span class="lineno"> 1453</span>&#160;            <span class="comment">//======================================== Report progress</span></div>
<div class="line"><a name="l01454"></a><span class="lineno"> 1454</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a4f98d32ed17424a1d8bf451a68370e20">ProSHADE_internal_messages::printProgressMessage</a> ( verbose, 3, <span class="stringliteral">&quot;Detection of four C3 axes successfull.&quot;</span>, messageShift );</div>
<div class="line"><a name="l01455"></a><span class="lineno"> 1455</span>&#160; </div>
<div class="line"><a name="l01456"></a><span class="lineno"> 1456</span>&#160;            <span class="comment">//======================================== Done</span></div>
<div class="line"><a name="l01457"></a><span class="lineno"> 1457</span>&#160;            return ;</div>
<div class="line"><a name="l01458"></a><span class="lineno"> 1458</span>&#160;        }</div>
<div class="line"><a name="l01459"></a><span class="lineno"> 1459</span>&#160;        <span class="keywordflow">else</span> { C3Possibilities.erase                  ( C3Possibilities.begin() ); }</div>
<div class="line"><a name="l01460"></a><span class="lineno"> 1460</span>&#160;    }</div>
<div class="line"><a name="l01461"></a><span class="lineno"> 1461</span>&#160; </div>
<div class="line"><a name="l01462"></a><span class="lineno"> 1462</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01463"></a><span class="lineno"> 1463</span>&#160;    return ;</div>
<div class="line"><a name="l01464"></a><span class="lineno"> 1464</span>&#160;    </div>
<div class="line"><a name="l01465"></a><span class="lineno"> 1465</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7f24f5b37a7810ce379fce1b71877a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f24f5b37a7810ce379fce1b71877a0e">&#9670;&nbsp;</a></span>findOcta6C2s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::findOcta6C2s </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>messageShift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes the list of C symmetries and finds the six C2 symmetries with correct angles required for full octahedral symmetry. </p>
<p>This function is specific to detecting the octahedral symmetry. It should be called once octahedral symmetry is suspected (by detecting its dihedral angles) and it needs to be fully described. This function specifically searches for the six C2 symmetries which must all be detected in order to fully describe octahedral symmetry. If all six are found, the ret vector will have these six axes added to the already present three C4 axes and the four C3 axes; alternatively, the ret array size will not change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>The vector containing the already detected axes to which newly detected axes (if any) will be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>How loud the announcments should be? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">messageShift</td><td>Are we in a subprocess, so that the log should be shifted for this function call? If so, by how much? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum average peak height for axis to be considered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01481">1481</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01482"></a><span class="lineno"> 1482</span>&#160;{</div>
<div class="line"><a name="l01483"></a><span class="lineno"> 1483</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l01484"></a><span class="lineno"> 1484</span>&#160;    std::vector&lt; proshade_unsign &gt; prospectiveC2s, retGrp;</div>
<div class="line"><a name="l01485"></a><span class="lineno"> 1485</span>&#160;    proshade_double dotProd;</div>
<div class="line"><a name="l01486"></a><span class="lineno"> 1486</span>&#160;    proshade_unsign noPerpendicular, noSqrtTwo;</div>
<div class="line"><a name="l01487"></a><span class="lineno"> 1487</span>&#160;    </div>
<div class="line"><a name="l01488"></a><span class="lineno"> 1488</span>&#160;    <span class="comment">//================================================ Report progress</span></div>
<div class="line"><a name="l01489"></a><span class="lineno"> 1489</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a4f98d32ed17424a1d8bf451a68370e20">ProSHADE_internal_messages::printProgressMessage</a>  ( verbose, 2, <span class="stringliteral">&quot;Starting detection of six C2 axes.&quot;</span>, messageShift );</div>
<div class="line"><a name="l01490"></a><span class="lineno"> 1490</span>&#160;    </div>
<div class="line"><a name="l01491"></a><span class="lineno"> 1491</span>&#160;    <span class="comment">//================================================ For each C2</span></div>
<div class="line"><a name="l01492"></a><span class="lineno"> 1492</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign cIt = 0; cIt &lt; static_cast&lt;proshade_unsign&gt; ( CSymList-&gt;size() ); cIt++ )</div>
<div class="line"><a name="l01493"></a><span class="lineno"> 1493</span>&#160;    {</div>
<div class="line"><a name="l01494"></a><span class="lineno"> 1494</span>&#160;        <span class="comment">//============================================ Use only C2s</span></div>
<div class="line"><a name="l01495"></a><span class="lineno"> 1495</span>&#160;        <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; lhs999 ( CSymList-&gt;at(cIt)[5] ), rhs999 ( <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( -999.9 ) );</div>
<div class="line"><a name="l01496"></a><span class="lineno"> 1496</span>&#160;        <span class="keywordflow">if</span> ( CSymList-&gt;at(cIt)[0] != 2.0 || ( ( CSymList-&gt;at(cIt)[5] &lt; minPeakHeight ) &amp;&amp; ! ( lhs999.AlmostEquals( rhs999 ) ) ) ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l01497"></a><span class="lineno"> 1497</span>&#160;        </div>
<div class="line"><a name="l01498"></a><span class="lineno"> 1498</span>&#160;        <span class="comment">//============================================ Check the C2 has acos ( 1/sqrt(2) ) to 2 C4s and acos ( 0.0 ) to the third C4</span></div>
<div class="line"><a name="l01499"></a><span class="lineno"> 1499</span>&#160;        noPerpendicular = 0; noSqrtTwo = 0;</div>
<div class="line"><a name="l01500"></a><span class="lineno"> 1500</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign rIt = 0; rIt &lt; 3; rIt++ )</div>
<div class="line"><a name="l01501"></a><span class="lineno"> 1501</span>&#160;        {</div>
<div class="line"><a name="l01502"></a><span class="lineno"> 1502</span>&#160;            dotProd                                   = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> ( &amp;ret-&gt;at(rIt)[1],</div>
<div class="line"><a name="l01503"></a><span class="lineno"> 1503</span>&#160;                                                                                                     &amp;ret-&gt;at(rIt)[2],</div>
<div class="line"><a name="l01504"></a><span class="lineno"> 1504</span>&#160;                                                                                                     &amp;ret-&gt;at(rIt)[3],</div>
<div class="line"><a name="l01505"></a><span class="lineno"> 1505</span>&#160;                                                                                                     &amp;CSymList-&gt;at(cIt)[1],</div>
<div class="line"><a name="l01506"></a><span class="lineno"> 1506</span>&#160;                                                                                                     &amp;CSymList-&gt;at(cIt)[2],</div>
<div class="line"><a name="l01507"></a><span class="lineno"> 1507</span>&#160;                                                                                                     &amp;CSymList-&gt;at(cIt)[3] );</div>
<div class="line"><a name="l01508"></a><span class="lineno"> 1508</span>&#160;            </div>
<div class="line"><a name="l01509"></a><span class="lineno"> 1509</span>&#160;            <span class="keywordflow">if</span> ( ( std::abs ( dotProd ) &gt; ( ( 1.0 / sqrt(2.0) ) - axErr ) ) &amp;&amp; ( std::abs ( dotProd ) &lt; ( ( 1.0 / sqrt(2.0) ) + axErr ) ) ) { noSqrtTwo       += 1; <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l01510"></a><span class="lineno"> 1510</span>&#160;            <span class="keywordflow">if</span> ( ( std::abs ( dotProd ) &gt; (   0.0               - axErr ) ) &amp;&amp; ( std::abs ( dotProd ) &lt; (   0.0               + axErr ) ) ) { noPerpendicular += 1; <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l01511"></a><span class="lineno"> 1511</span>&#160;        }</div>
<div class="line"><a name="l01512"></a><span class="lineno"> 1512</span>&#160;        </div>
<div class="line"><a name="l01513"></a><span class="lineno"> 1513</span>&#160;        <span class="comment">//============================================ If correct angles distribution is found, save the axis</span></div>
<div class="line"><a name="l01514"></a><span class="lineno"> 1514</span>&#160;        <span class="keywordflow">if</span> ( ( noSqrtTwo == 2 ) &amp;&amp; ( noPerpendicular == 1 ) )</div>
<div class="line"><a name="l01515"></a><span class="lineno"> 1515</span>&#160;        {</div>
<div class="line"><a name="l01516"></a><span class="lineno"> 1516</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;prospectiveC2s, cIt );</div>
<div class="line"><a name="l01517"></a><span class="lineno"> 1517</span>&#160;        }</div>
<div class="line"><a name="l01518"></a><span class="lineno"> 1518</span>&#160;    }</div>
<div class="line"><a name="l01519"></a><span class="lineno"> 1519</span>&#160;    </div>
<div class="line"><a name="l01520"></a><span class="lineno"> 1520</span>&#160;    <span class="comment">//================================================ Search for missing axes</span></div>
<div class="line"><a name="l01521"></a><span class="lineno"> 1521</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; 3; iter++ ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;retGrp, iter ); }</div>
<div class="line"><a name="l01522"></a><span class="lineno"> 1522</span>&#160;    <span class="keywordflow">if</span> ( !<a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a6d9f533a789bd5c6031fa77b9649ed3d">ProSHADE_internal_symmetry::findMissingAxesDual</a> ( &amp;prospectiveC2s, CSymList, ret, &amp;retGrp, 6, axErr, 1, 0.0, 2, 1/sqrt(2.0), 2, dataObj ) )</div>
<div class="line"><a name="l01523"></a><span class="lineno"> 1523</span>&#160;    {</div>
<div class="line"><a name="l01524"></a><span class="lineno"> 1524</span>&#160;        return ;</div>
<div class="line"><a name="l01525"></a><span class="lineno"> 1525</span>&#160;    }</div>
<div class="line"><a name="l01526"></a><span class="lineno"> 1526</span>&#160;    </div>
<div class="line"><a name="l01527"></a><span class="lineno"> 1527</span>&#160;    <span class="comment">//================================================ Found correct number of axes! Now save the</span></div>
<div class="line"><a name="l01528"></a><span class="lineno"> 1528</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; static_cast&lt;proshade_unsign&gt; ( prospectiveC2s.size() ); iter++ )</div>
<div class="line"><a name="l01529"></a><span class="lineno"> 1529</span>&#160;    {</div>
<div class="line"><a name="l01530"></a><span class="lineno"> 1530</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a>     ( ret, CSymList-&gt;at(prospectiveC2s.at(iter)) );</div>
<div class="line"><a name="l01531"></a><span class="lineno"> 1531</span>&#160;    }</div>
<div class="line"><a name="l01532"></a><span class="lineno"> 1532</span>&#160;    </div>
<div class="line"><a name="l01533"></a><span class="lineno"> 1533</span>&#160;    <span class="comment">//================================================ Report progress</span></div>
<div class="line"><a name="l01534"></a><span class="lineno"> 1534</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a4f98d32ed17424a1d8bf451a68370e20">ProSHADE_internal_messages::printProgressMessage</a>  ( verbose, 3, <span class="stringliteral">&quot;Detection of six C2 axes successfull.&quot;</span>, messageShift );</div>
<div class="line"><a name="l01535"></a><span class="lineno"> 1535</span>&#160;    </div>
<div class="line"><a name="l01536"></a><span class="lineno"> 1536</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01537"></a><span class="lineno"> 1537</span>&#160;    return ;</div>
<div class="line"><a name="l01538"></a><span class="lineno"> 1538</span>&#160;    </div>
<div class="line"><a name="l01539"></a><span class="lineno"> 1539</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a194544dbfe4daae5fe9300daeb98c779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194544dbfe4daae5fe9300daeb98c779">&#9670;&nbsp;</a></span>findPointFromTranslations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; proshade_double &gt; ProSHADE_internal_symmetry::findPointFromTranslations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>symStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; proshade_double &gt; &gt;&#160;</td>
          <td class="paramname"><em>symElems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_complex *&#160;</td>
          <td class="paramname"><em>origCoeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_complex *&#160;</td>
          <td class="paramname"><em>rotMapComplex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_complex *&#160;</td>
          <td class="paramname"><em>rotCoeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_plan&#160;</td>
          <td class="paramname"><em>planForwardFourierRot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_complex *&#160;</td>
          <td class="paramname"><em>trFuncCoeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_complex *&#160;</td>
          <td class="paramname"><em>trFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_plan&#160;</td>
          <td class="paramname"><em>planReverseFourierComb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes the average of optimal translations for a cyclic point group. </p>
<p>This function takes a single cyclic point group elements and proceeds to compute all optimal translations between the original map and map rotated by each point group element. The sum of these translations divided by the number of the point group elements (including the identity element) then gives a point that must lie on the symmetry axis.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">symStr</td><td>A ProSHADE_data structure containing the structure for which the line on which the centre of rotation lies is to be found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">symElems</td><td>Vector containing single symmetry element (rotaiton matrix) which is not identity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">origCoeffs</td><td>The Fourier coefficients of the original (non-rotated) map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotMapComplex</td><td>Array to which the rotated map will be saved and from which the Fourier transform plan (planForwardFourierRot) is prepared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotCoeffs</td><td>Array to which the result of the Fourier transform of the rotated map will be saved into by the supplied plan (planForwardFourierRot). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">planForwardFourierRot</td><td>FFTW3 plan for forward Fourier transform from rotMapComplex to rotCoeffs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trFuncCoeffs</td><td>The array to which the combined Fourier coefficients for translation function will be saved into and also for which the inverse Fourier transform plan (planReverseFourierComb) is prepared for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trFunc</td><td>The array to which the translation function will be saved into by the reverse Fourier transform planned by the plan (planReverseFourierComb). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">planReverseFourierComb</td><td>FFTW3 plan for reverse Fourier transform from the combined coefficients (trFuncCoeffs) to the translation function array (trFunc). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>How loud the function should be? </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pointOnLine</td><td>A vector specifying a point that lies on the symmetry axis (given by the averaged sum of the translations of the rotated maps). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l03935">3935</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03936"></a><span class="lineno"> 3936</span>&#160;{</div>
<div class="line"><a name="l03937"></a><span class="lineno"> 3937</span>&#160;    <span class="comment">//================================================ Initialise local variables</span></div>
<div class="line"><a name="l03938"></a><span class="lineno"> 3938</span>&#160;    std::vector&lt; proshade_double &gt; pointOnLine        ( 3, 0.0 );</div>
<div class="line"><a name="l03939"></a><span class="lineno"> 3939</span>&#160;    std::vector&lt; proshade_double &gt; identityMat        ( 9, 0.0 ); identityMat.at(0) = 1.0; identityMat.at(4) = 1.0; identityMat.at(8) = 1.0;</div>
<div class="line"><a name="l03940"></a><span class="lineno"> 3940</span>&#160;    </div>
<div class="line"><a name="l03941"></a><span class="lineno"> 3941</span>&#160;    <span class="comment">//================================================ For each symmetry element in this cyclic group</span></div>
<div class="line"><a name="l03942"></a><span class="lineno"> 3942</span>&#160;    <span class="keywordflow">for</span> ( <span class="keywordtype">size_t</span> gEl = 0; gEl &lt; symElems.size(); gEl++ )</div>
<div class="line"><a name="l03943"></a><span class="lineno"> 3943</span>&#160;    {</div>
<div class="line"><a name="l03944"></a><span class="lineno"> 3944</span>&#160;        <span class="comment">//============================================ Ignore identity element</span></div>
<div class="line"><a name="l03945"></a><span class="lineno"> 3945</span>&#160;        <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a4348a7a36275c9cea20b5c27093c9b7e">ProSHADE_internal_maths::rotationMatrixSimilarity</a> ( &amp;symElems.at(gEl), &amp;identityMat, 0.01 ) ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l03946"></a><span class="lineno"> 3946</span>&#160;        </div>
<div class="line"><a name="l03947"></a><span class="lineno"> 3947</span>&#160;        <span class="comment">//============================================ Find translation difference between rotated and original map</span></div>
<div class="line"><a name="l03948"></a><span class="lineno"> 3948</span>&#160;        std::vector&lt; proshade_double &gt; trsCenHlp      = <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a3ec1b87286193d7797b6afa2bed1ea33">ProSHADE_internal_symmetry::findTranslationBetweenRotatedAndOriginalMap</a> ( symStr,</div>
<div class="line"><a name="l03949"></a><span class="lineno"> 3949</span>&#160;                                                                                                                                  symElems.at(gEl),</div>
<div class="line"><a name="l03950"></a><span class="lineno"> 3950</span>&#160;                                                                                                                                  origCoeffs, rotMapComplex,</div>
<div class="line"><a name="l03951"></a><span class="lineno"> 3951</span>&#160;                                                                                                                                  rotCoeffs, planForwardFourierRot,</div>
<div class="line"><a name="l03952"></a><span class="lineno"> 3952</span>&#160;                                                                                                                                  trFuncCoeffs, trFunc,</div>
<div class="line"><a name="l03953"></a><span class="lineno"> 3953</span>&#160;                                                                                                                                  planReverseFourierComb );</div>
<div class="line"><a name="l03954"></a><span class="lineno"> 3954</span>&#160;        </div>
<div class="line"><a name="l03955"></a><span class="lineno"> 3955</span>&#160;        <span class="comment">//============================================ Sum translations over the whole axis</span></div>
<div class="line"><a name="l03956"></a><span class="lineno"> 3956</span>&#160;        pointOnLine.at(0)                            += trsCenHlp.at(0);</div>
<div class="line"><a name="l03957"></a><span class="lineno"> 3957</span>&#160;        pointOnLine.at(1)                            += trsCenHlp.at(1);</div>
<div class="line"><a name="l03958"></a><span class="lineno"> 3958</span>&#160;        pointOnLine.at(2)                            += trsCenHlp.at(2);</div>
<div class="line"><a name="l03959"></a><span class="lineno"> 3959</span>&#160;    }</div>
<div class="line"><a name="l03960"></a><span class="lineno"> 3960</span>&#160;    </div>
<div class="line"><a name="l03961"></a><span class="lineno"> 3961</span>&#160;    <span class="comment">//================================================ Average over all symmetry elements (including the identity one)</span></div>
<div class="line"><a name="l03962"></a><span class="lineno"> 3962</span>&#160;    pointOnLine.at(0)                                /= <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( symElems.size() );</div>
<div class="line"><a name="l03963"></a><span class="lineno"> 3963</span>&#160;    pointOnLine.at(1)                                /= <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( symElems.size() );</div>
<div class="line"><a name="l03964"></a><span class="lineno"> 3964</span>&#160;    pointOnLine.at(2)                                /= <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( symElems.size() );</div>
<div class="line"><a name="l03965"></a><span class="lineno"> 3965</span>&#160;    </div>
<div class="line"><a name="l03966"></a><span class="lineno"> 3966</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l03967"></a><span class="lineno"> 3967</span>&#160;    <span class="keywordflow">return</span>                                            ( pointOnLine );</div>
<div class="line"><a name="l03968"></a><span class="lineno"> 3968</span>&#160;    </div>
<div class="line"><a name="l03969"></a><span class="lineno"> 3969</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a33c650c19a6954800bba6b3a8f5842e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33c650c19a6954800bba6b3a8f5842e6">&#9670;&nbsp;</a></span>findPredictedAxesHeights()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::findPredictedAxesHeights </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__settings.html">ProSHADE_settings</a> *&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function finds the rotation function value for all axes supplied in the ret parameter. </p>
<p>This function supplements the polyhedral symmetry prediction functions, as these functions predict the symmetry axes, but do not find their peak heights. This function, then, firstly finds all the individual folds in the symmetry axes set and for each fold computes the appropriate angles. Next. it computes the sphere mappings of the rotation function for all detected angles and for each symmetry axes, it finds the rotation function average as well as the average for the whole symmetry (i.e. over all axes). Finally, the function attempts to locally optimise the detected symmetry group by searching for slightly rotated axes having higher rotation function average.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>The list of axes for which the heights are to be found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataObj</td><td>The structure object with computed rotation function in which the peaks are to be found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">settings</td><td><a class="el" href="class_pro_s_h_a_d_e__settings.html" title="This class stores all the settings and is passed to the executive classes instead of a multitude of p...">ProSHADE_settings</a> object containing all the settings for this run. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l03022">3022</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03023"></a><span class="lineno"> 3023</span>&#160;{</div>
<div class="line"><a name="l03024"></a><span class="lineno"> 3024</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l03025"></a><span class="lineno"> 3025</span>&#160;    std::vector &lt; proshade_unsign &gt; folds;</div>
<div class="line"><a name="l03026"></a><span class="lineno"> 3026</span>&#160;    std::vector &lt; proshade_double &gt; angs, applicableAngs;</div>
<div class="line"><a name="l03027"></a><span class="lineno"> 3027</span>&#160;    <span class="keywordtype">bool</span> alreadyFound = <span class="keyword">false</span>;</div>
<div class="line"><a name="l03028"></a><span class="lineno"> 3028</span>&#160;    <span class="keywordtype">size_t</span> corAngIt = 0;</div>
<div class="line"><a name="l03029"></a><span class="lineno"> 3029</span>&#160;    proshade_double lat = 0.0, lon = 0.0, radRange = 0.0, searchRangeInDeg = 0.0, axSum = 0.0, curSum = 0.0, maxSum = 0.0, bestXRot = 0.0, bestYRot = 0.0, bestZRot = 0.0, finXRotChan = 0.0, finYRotChan = 0.0, finZRotChan = 0.0;</div>
<div class="line"><a name="l03030"></a><span class="lineno"> 3030</span>&#160;    proshade_double latSamlUnit                       = ( 2.0 * M_PI ) / ( <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a367d0cd13e3d7a2648488980220ca69b">maxShellBand</a> ) * 2.0 );</div>
<div class="line"><a name="l03031"></a><span class="lineno"> 3031</span>&#160;    proshade_double lonSamlUnit                       = ( 1.0 * M_PI ) / ( <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a367d0cd13e3d7a2648488980220ca69b">maxShellBand</a> ) * 2.0 );</div>
<div class="line"><a name="l03032"></a><span class="lineno"> 3032</span>&#160;    </div>
<div class="line"><a name="l03033"></a><span class="lineno"> 3033</span>&#160;    <span class="comment">//================================================ Determine all the folds for which rotation function mapping will be required</span></div>
<div class="line"><a name="l03034"></a><span class="lineno"> 3034</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; static_cast &lt; proshade_unsign &gt; ( ret-&gt;size() ); iter++ )</div>
<div class="line"><a name="l03035"></a><span class="lineno"> 3035</span>&#160;    {</div>
<div class="line"><a name="l03036"></a><span class="lineno"> 3036</span>&#160;        alreadyFound                                  = <span class="keyword">false</span>;</div>
<div class="line"><a name="l03037"></a><span class="lineno"> 3037</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign it = 0; it &lt; static_cast &lt; proshade_unsign &gt; ( folds.size() ); it++ ) { <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; lhs1 ( <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( folds.at(it) ) ), rhs1 ( ret-&gt;at(iter)[0] ); <span class="keywordflow">if</span> ( lhs1.AlmostEquals ( rhs1 ) ) { alreadyFound = <span class="keyword">true</span>; <span class="keywordflow">break</span>; } }</div>
<div class="line"><a name="l03038"></a><span class="lineno"> 3038</span>&#160;        </div>
<div class="line"><a name="l03039"></a><span class="lineno"> 3039</span>&#160;        <span class="keywordflow">if</span> ( !alreadyFound ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;folds, <span class="keyword">static_cast&lt;</span> proshade_unsign <span class="keyword">&gt;</span> ( ret-&gt;at(iter)[0] ) ); }</div>
<div class="line"><a name="l03040"></a><span class="lineno"> 3040</span>&#160;    }</div>
<div class="line"><a name="l03041"></a><span class="lineno"> 3041</span>&#160;    </div>
<div class="line"><a name="l03042"></a><span class="lineno"> 3042</span>&#160;    <span class="comment">//================================================ Generate vector of all angles</span></div>
<div class="line"><a name="l03043"></a><span class="lineno"> 3043</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign foldIt = 0; foldIt &lt; static_cast &lt; proshade_unsign &gt; ( folds.size() ); foldIt++ ) { <span class="keywordflow">for</span> ( proshade_double angIt = 1.0; angIt &lt; static_cast&lt;proshade_double&gt; ( folds.at(foldIt) ); angIt += 1.0 ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a> ( &amp;angs, angIt * ( 2.0 * M_PI / <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( folds.at(foldIt) ) ) ); } }</div>
<div class="line"><a name="l03044"></a><span class="lineno"> 3044</span>&#160;    std::sort                                         ( angs.begin(), angs.end() );</div>
<div class="line"><a name="l03045"></a><span class="lineno"> 3045</span>&#160;    </div>
<div class="line"><a name="l03046"></a><span class="lineno"> 3046</span>&#160;    <span class="comment">//================================================ Remove redundant angles from the list</span></div>
<div class="line"><a name="l03047"></a><span class="lineno"> 3047</span>&#160;    <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> angIt = <span class="keyword">static_cast&lt;</span> <span class="keywordtype">int</span> <span class="keyword">&gt;</span> ( angs.size() - 2 ); angIt &gt;= 0; angIt-- ) { <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; lhs1 ( angs.at(<span class="keyword">static_cast&lt;</span> <span class="keywordtype">size_t</span> <span class="keyword">&gt;</span> ( angIt ) ) ), rhs1 ( angs.at(<span class="keyword">static_cast&lt;</span> <span class="keywordtype">size_t</span> <span class="keyword">&gt;</span> ( angIt + 1 ) ) ); <span class="keywordflow">if</span> ( lhs1.AlmostEquals ( rhs1 ) ) { angs.erase ( angs.begin() + (angIt+1) ); } }</div>
<div class="line"><a name="l03048"></a><span class="lineno"> 3048</span>&#160;    </div>
<div class="line"><a name="l03049"></a><span class="lineno"> 3049</span>&#160;    <span class="comment">//================================================ Generate all sphere mapped rotation function</span></div>
<div class="line"><a name="l03050"></a><span class="lineno"> 3050</span>&#160;    dataObj-&gt;sphereMappedRotFun.clear();</div>
<div class="line"><a name="l03051"></a><span class="lineno"> 3051</span>&#160;    <span class="keywordflow">for</span> ( <span class="keywordtype">size_t</span> angIt = 0; angIt &lt; angs.size(); angIt++ )</div>
<div class="line"><a name="l03052"></a><span class="lineno"> 3052</span>&#160;    {</div>
<div class="line"><a name="l03053"></a><span class="lineno"> 3053</span>&#160;        <span class="comment">//============================================ Decide the range in which the sphere operates</span></div>
<div class="line"><a name="l03054"></a><span class="lineno"> 3054</span>&#160;        <span class="keywordflow">if</span> ( ( angIt == 0 ) &amp;&amp; ( angs.size() &gt; 1 ) )  { radRange = ( angs.at(1) - angs.at(0) ) / 2; }</div>
<div class="line"><a name="l03055"></a><span class="lineno"> 3055</span>&#160;        <span class="keywordflow">else</span> { <span class="keywordflow">if</span> ( ( angIt == ( angs.size() - 1 ) ) &amp;&amp; ( angs.size() &gt; 1 ) ) { radRange = ( angs.at(angIt) - angs.at(angIt-1) ) / 2; }</div>
<div class="line"><a name="l03056"></a><span class="lineno"> 3056</span>&#160;               <span class="keywordflow">else</span> { <span class="keywordflow">if</span> ( angs.size() &gt; 2 ) { radRange = std::min ( ( angs.at(angIt) - angs.at(angIt-1) ) / 2, ( angs.at(angIt+1) - angs.at(angIt) ) / 2 ); }</div>
<div class="line"><a name="l03057"></a><span class="lineno"> 3057</span>&#160;                      <span class="keywordflow">else</span> { radRange = 0.5; } } }</div>
<div class="line"><a name="l03058"></a><span class="lineno"> 3058</span>&#160;        </div>
<div class="line"><a name="l03059"></a><span class="lineno"> 3059</span>&#160;        <span class="comment">//============================================ Create the sphere</span></div>
<div class="line"><a name="l03060"></a><span class="lineno"> 3060</span>&#160;        dataObj-&gt;sphereMappedRotFun.emplace_back      ( <span class="keyword">new</span> <a class="code" href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere.html">ProSHADE_internal_spheres::ProSHADE_rotFun_sphere</a> ( angs.at(angIt),</div>
<div class="line"><a name="l03061"></a><span class="lineno"> 3061</span>&#160;                                                                                                                radRange,</div>
<div class="line"><a name="l03062"></a><span class="lineno"> 3062</span>&#160;                                                                                                                dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a367d0cd13e3d7a2648488980220ca69b">maxShellBand</a> * 2,</div>
<div class="line"><a name="l03063"></a><span class="lineno"> 3063</span>&#160;                                                                                                                angs.at(angIt),</div>
<div class="line"><a name="l03064"></a><span class="lineno"> 3064</span>&#160;                                                                                                                <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( angIt ) ) );</div>
<div class="line"><a name="l03065"></a><span class="lineno"> 3065</span>&#160; </div>
<div class="line"><a name="l03066"></a><span class="lineno"> 3066</span>&#160;        <span class="comment">//=========================================== Interpolate rotation function onto the sphere</span></div>
<div class="line"><a name="l03067"></a><span class="lineno"> 3067</span>&#160;        dataObj-&gt;sphereMappedRotFun.at( <span class="keyword">static_cast &lt;</span> proshade_unsign <span class="keyword">&gt;</span> ( angIt ))-&gt;interpolateSphereValues ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a2eb10989a2f8d46b849cdaf8410b68be">getInvSO3Coeffs</a> ( ) );</div>
<div class="line"><a name="l03068"></a><span class="lineno"> 3068</span>&#160;    }</div>
<div class="line"><a name="l03069"></a><span class="lineno"> 3069</span>&#160;    </div>
<div class="line"><a name="l03070"></a><span class="lineno"> 3070</span>&#160;    <span class="comment">//================================================ Check for improved sum</span></div>
<div class="line"><a name="l03071"></a><span class="lineno"> 3071</span>&#160;    searchRangeInDeg                                  = 360.0 / ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a152b43815a3d3debd4b60751d9c8afdd">getMaxBand</a>() * 2.0 );</div>
<div class="line"><a name="l03072"></a><span class="lineno"> 3072</span>&#160;    proshade_double* rotMat, *newAxis;</div>
<div class="line"><a name="l03073"></a><span class="lineno"> 3073</span>&#160;    <span class="keywordflow">while</span> ( searchRangeInDeg &gt; 0.09 )</div>
<div class="line"><a name="l03074"></a><span class="lineno"> 3074</span>&#160;    {</div>
<div class="line"><a name="l03075"></a><span class="lineno"> 3075</span>&#160;        <span class="comment">//============================================ For change along each dimension</span></div>
<div class="line"><a name="l03076"></a><span class="lineno"> 3076</span>&#160;        <span class="keywordflow">for</span> ( proshade_double xChan = -searchRangeInDeg; xChan &lt; ( 1.5 * searchRangeInDeg ); xChan += searchRangeInDeg )</div>
<div class="line"><a name="l03077"></a><span class="lineno"> 3077</span>&#160;        {</div>
<div class="line"><a name="l03078"></a><span class="lineno"> 3078</span>&#160;            <span class="keywordflow">for</span> ( proshade_double yChan = -searchRangeInDeg; yChan &lt; ( 1.5 * searchRangeInDeg ); yChan += searchRangeInDeg )</div>
<div class="line"><a name="l03079"></a><span class="lineno"> 3079</span>&#160;            {</div>
<div class="line"><a name="l03080"></a><span class="lineno"> 3080</span>&#160;                <span class="keywordflow">for</span> ( proshade_double zChan = -searchRangeInDeg; zChan &lt; ( 1.5 * searchRangeInDeg ); zChan += searchRangeInDeg )</div>
<div class="line"><a name="l03081"></a><span class="lineno"> 3081</span>&#160;                {</div>
<div class="line"><a name="l03082"></a><span class="lineno"> 3082</span>&#160;                    <span class="comment">//================================ Initialise local variables</span></div>
<div class="line"><a name="l03083"></a><span class="lineno"> 3083</span>&#160;                    curSum                            = 0.0;</div>
<div class="line"><a name="l03084"></a><span class="lineno"> 3084</span>&#160;                    </div>
<div class="line"><a name="l03085"></a><span class="lineno"> 3085</span>&#160;                    <span class="comment">//================================ Find the rotation matrix of the appropriate rotation</span></div>
<div class="line"><a name="l03086"></a><span class="lineno"> 3086</span>&#160;                    rotMat                            = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a12a5f7b87baedbe1cd37ad588d3fca92">ProSHADE_internal_maths::build3x3MatrixFromXYZRotations</a> ( xChan + finXRotChan, yChan + finYRotChan, zChan + finZRotChan );</div>
<div class="line"><a name="l03087"></a><span class="lineno"> 3087</span>&#160;                    </div>
<div class="line"><a name="l03088"></a><span class="lineno"> 3088</span>&#160;                    <span class="comment">//================================ For each axis, find new position and its RF value</span></div>
<div class="line"><a name="l03089"></a><span class="lineno"> 3089</span>&#160;                    <span class="keywordflow">for</span> ( proshade_unsign axIt = 0; axIt &lt; static_cast&lt; proshade_unsign &gt; ( ret-&gt;size() ); axIt++ )</div>
<div class="line"><a name="l03090"></a><span class="lineno"> 3090</span>&#160;                    {</div>
<div class="line"><a name="l03091"></a><span class="lineno"> 3091</span>&#160;                        <span class="comment">//============================ Find rotated axis</span></div>
<div class="line"><a name="l03092"></a><span class="lineno"> 3092</span>&#160;                        newAxis                       = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2f9c7716f6ab682e8548ab77efcdc444">ProSHADE_internal_maths::compute3x3MatrixVectorMultiplication</a> ( rotMat, ret-&gt;at(axIt)[1], ret-&gt;at(axIt)[2], ret-&gt;at(axIt)[3] );</div>
<div class="line"><a name="l03093"></a><span class="lineno"> 3093</span>&#160;                        </div>
<div class="line"><a name="l03094"></a><span class="lineno"> 3094</span>&#160;                        <span class="comment">//============================ Convert XYZ to lat and lon INDICES</span></div>
<div class="line"><a name="l03095"></a><span class="lineno"> 3095</span>&#160;                        lat                           = ( std::atan2( newAxis[1], newAxis[0] ) / latSamlUnit );</div>
<div class="line"><a name="l03096"></a><span class="lineno"> 3096</span>&#160;                        lon                           = ( std::acos ( newAxis[2] ) / lonSamlUnit );</div>
<div class="line"><a name="l03097"></a><span class="lineno"> 3097</span>&#160; </div>
<div class="line"><a name="l03098"></a><span class="lineno"> 3098</span>&#160;                        <span class="keywordflow">if</span> ( lat &lt; 0.0 )                  { lat += ( <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a367d0cd13e3d7a2648488980220ca69b">maxShellBand</a> ) * 2.0 ); }</div>
<div class="line"><a name="l03099"></a><span class="lineno"> 3099</span>&#160;                        <span class="keywordflow">if</span> ( lon &lt; 0.0 )                  { lon += ( <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a367d0cd13e3d7a2648488980220ca69b">maxShellBand</a> ) * 2.0 ); }</div>
<div class="line"><a name="l03100"></a><span class="lineno"> 3100</span>&#160; </div>
<div class="line"><a name="l03101"></a><span class="lineno"> 3101</span>&#160;                        <span class="comment">//============================ Generate all angles for this fold</span></div>
<div class="line"><a name="l03102"></a><span class="lineno"> 3102</span>&#160;                        applicableAngs.clear          ( );</div>
<div class="line"><a name="l03103"></a><span class="lineno"> 3103</span>&#160;                        <span class="keywordflow">for</span> ( proshade_double angIt = 1.0; angIt &lt; ret-&gt;at(axIt)[0]; angIt += 1.0 ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a> ( &amp;applicableAngs, angIt * ( 2.0 * M_PI / ret-&gt;at(axIt)[0] ) ); }</div>
<div class="line"><a name="l03104"></a><span class="lineno"> 3104</span>&#160; </div>
<div class="line"><a name="l03105"></a><span class="lineno"> 3105</span>&#160;                        <span class="comment">//============================ For each shpere with the correct angle, average the peak heights</span></div>
<div class="line"><a name="l03106"></a><span class="lineno"> 3106</span>&#160;                        axSum                         = 1.0;</div>
<div class="line"><a name="l03107"></a><span class="lineno"> 3107</span>&#160;                        <span class="keywordflow">for</span> ( <span class="keywordtype">size_t</span> angIt = 0; angIt &lt; angs.size(); angIt++ )</div>
<div class="line"><a name="l03108"></a><span class="lineno"> 3108</span>&#160;                        {</div>
<div class="line"><a name="l03109"></a><span class="lineno"> 3109</span>&#160;                            <span class="comment">//======================== Find the correct sphere</span></div>
<div class="line"><a name="l03110"></a><span class="lineno"> 3110</span>&#160;                            alreadyFound              = <span class="keyword">false</span>;</div>
<div class="line"><a name="l03111"></a><span class="lineno"> 3111</span>&#160;                            <span class="keywordflow">for</span> ( <span class="keywordtype">size_t</span> aIt = 0; aIt &lt; applicableAngs.size(); aIt++ ) { <span class="keywordflow">if</span> ( alreadyFound ) { <span class="keywordflow">break</span>; } <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; lhs1 ( angs.at(angIt) ), rhs1 ( applicableAngs.at(aIt) ); <span class="keywordflow">if</span> ( lhs1.AlmostEquals ( rhs1 ) ) { alreadyFound = <span class="keyword">true</span>; corAngIt = angIt; } }</div>
<div class="line"><a name="l03112"></a><span class="lineno"> 3112</span>&#160; </div>
<div class="line"><a name="l03113"></a><span class="lineno"> 3113</span>&#160;                            <span class="keywordflow">if</span> ( !alreadyFound ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l03114"></a><span class="lineno"> 3114</span>&#160; </div>
<div class="line"><a name="l03115"></a><span class="lineno"> 3115</span>&#160;                            <span class="comment">//======================== Get its peak height for the longitude and latitude</span></div>
<div class="line"><a name="l03116"></a><span class="lineno"> 3116</span>&#160;                            axSum                    += dataObj-&gt;sphereMappedRotFun.at(corAngIt)-&gt;getSphereLatLonLinearInterpolationPos ( lat, lon );</div>
<div class="line"><a name="l03117"></a><span class="lineno"> 3117</span>&#160;                        }</div>
<div class="line"><a name="l03118"></a><span class="lineno"> 3118</span>&#160; </div>
<div class="line"><a name="l03119"></a><span class="lineno"> 3119</span>&#160;                        <span class="comment">//============================ And average the peak heights over the axis</span></div>
<div class="line"><a name="l03120"></a><span class="lineno"> 3120</span>&#160;                        axSum                        /= ret-&gt;at(axIt)[0];</div>
<div class="line"><a name="l03121"></a><span class="lineno"> 3121</span>&#160;                        curSum                       += axSum;</div>
<div class="line"><a name="l03122"></a><span class="lineno"> 3122</span>&#160;                        </div>
<div class="line"><a name="l03123"></a><span class="lineno"> 3123</span>&#160;                        <span class="comment">//============================ Release memory</span></div>
<div class="line"><a name="l03124"></a><span class="lineno"> 3124</span>&#160;                        <span class="keyword">delete</span>[] newAxis;</div>
<div class="line"><a name="l03125"></a><span class="lineno"> 3125</span>&#160;                    }</div>
<div class="line"><a name="l03126"></a><span class="lineno"> 3126</span>&#160;                    </div>
<div class="line"><a name="l03127"></a><span class="lineno"> 3127</span>&#160;                    <span class="comment">//================================ And average the peak heights over all axes</span></div>
<div class="line"><a name="l03128"></a><span class="lineno"> 3128</span>&#160;                    curSum                           /= <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( ret-&gt;size() );</div>
<div class="line"><a name="l03129"></a><span class="lineno"> 3129</span>&#160;            </div>
<div class="line"><a name="l03130"></a><span class="lineno"> 3130</span>&#160;                    <span class="comment">//================================ If improved, save</span></div>
<div class="line"><a name="l03131"></a><span class="lineno"> 3131</span>&#160;                    <span class="keywordflow">if</span> ( curSum &gt;  maxSum )</div>
<div class="line"><a name="l03132"></a><span class="lineno"> 3132</span>&#160;                    {</div>
<div class="line"><a name="l03133"></a><span class="lineno"> 3133</span>&#160;                        maxSum                        = curSum;</div>
<div class="line"><a name="l03134"></a><span class="lineno"> 3134</span>&#160;                        bestXRot                      = xChan;</div>
<div class="line"><a name="l03135"></a><span class="lineno"> 3135</span>&#160;                        bestYRot                      = yChan;</div>
<div class="line"><a name="l03136"></a><span class="lineno"> 3136</span>&#160;                        bestZRot                      = zChan;</div>
<div class="line"><a name="l03137"></a><span class="lineno"> 3137</span>&#160;                    }</div>
<div class="line"><a name="l03138"></a><span class="lineno"> 3138</span>&#160;                    </div>
<div class="line"><a name="l03139"></a><span class="lineno"> 3139</span>&#160;                    <span class="comment">//================================ Release memory</span></div>
<div class="line"><a name="l03140"></a><span class="lineno"> 3140</span>&#160;                    <span class="keyword">delete</span>[] rotMat;</div>
<div class="line"><a name="l03141"></a><span class="lineno"> 3141</span>&#160;                    </div>
<div class="line"><a name="l03142"></a><span class="lineno"> 3142</span>&#160;                    </div>
<div class="line"><a name="l03143"></a><span class="lineno"> 3143</span>&#160;                }</div>
<div class="line"><a name="l03144"></a><span class="lineno"> 3144</span>&#160;            }</div>
<div class="line"><a name="l03145"></a><span class="lineno"> 3145</span>&#160;        }</div>
<div class="line"><a name="l03146"></a><span class="lineno"> 3146</span>&#160;    </div>
<div class="line"><a name="l03147"></a><span class="lineno"> 3147</span>&#160;        <span class="comment">//============================================ Prepare for next iteration</span></div>
<div class="line"><a name="l03148"></a><span class="lineno"> 3148</span>&#160;        searchRangeInDeg                             /= 2.0;</div>
<div class="line"><a name="l03149"></a><span class="lineno"> 3149</span>&#160;        finXRotChan                                  += bestXRot;</div>
<div class="line"><a name="l03150"></a><span class="lineno"> 3150</span>&#160;        finYRotChan                                  += bestYRot;</div>
<div class="line"><a name="l03151"></a><span class="lineno"> 3151</span>&#160;        finZRotChan                                  += bestZRot;</div>
<div class="line"><a name="l03152"></a><span class="lineno"> 3152</span>&#160;        bestXRot                                      = 0.0;</div>
<div class="line"><a name="l03153"></a><span class="lineno"> 3153</span>&#160;        bestYRot                                      = 0.0;</div>
<div class="line"><a name="l03154"></a><span class="lineno"> 3154</span>&#160;        bestZRot                                      = 0.0;</div>
<div class="line"><a name="l03155"></a><span class="lineno"> 3155</span>&#160;    }</div>
<div class="line"><a name="l03156"></a><span class="lineno"> 3156</span>&#160;    </div>
<div class="line"><a name="l03157"></a><span class="lineno"> 3157</span>&#160;    <span class="comment">//================================================ Apply the optimisation</span></div>
<div class="line"><a name="l03158"></a><span class="lineno"> 3158</span>&#160;    rotMat                                            = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a12a5f7b87baedbe1cd37ad588d3fca92">ProSHADE_internal_maths::build3x3MatrixFromXYZRotations</a> ( finXRotChan, finYRotChan, finZRotChan );</div>
<div class="line"><a name="l03159"></a><span class="lineno"> 3159</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign axIt = 0; axIt &lt; static_cast&lt; proshade_unsign &gt; ( ret-&gt;size() ); axIt++ )</div>
<div class="line"><a name="l03160"></a><span class="lineno"> 3160</span>&#160;    {</div>
<div class="line"><a name="l03161"></a><span class="lineno"> 3161</span>&#160;        <span class="comment">//============================================ Find the rotated axis</span></div>
<div class="line"><a name="l03162"></a><span class="lineno"> 3162</span>&#160;        newAxis                                       = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2f9c7716f6ab682e8548ab77efcdc444">ProSHADE_internal_maths::compute3x3MatrixVectorMultiplication</a> ( rotMat, ret-&gt;at(axIt)[1], ret-&gt;at(axIt)[2], ret-&gt;at(axIt)[3] );</div>
<div class="line"><a name="l03163"></a><span class="lineno"> 3163</span>&#160;        </div>
<div class="line"><a name="l03164"></a><span class="lineno"> 3164</span>&#160;        <span class="comment">//============================================ Change axes</span></div>
<div class="line"><a name="l03165"></a><span class="lineno"> 3165</span>&#160;        ret-&gt;at(axIt)[1]                              = newAxis[0];</div>
<div class="line"><a name="l03166"></a><span class="lineno"> 3166</span>&#160;        ret-&gt;at(axIt)[2]                              = newAxis[1];</div>
<div class="line"><a name="l03167"></a><span class="lineno"> 3167</span>&#160;        ret-&gt;at(axIt)[3]                              = newAxis[2];</div>
<div class="line"><a name="l03168"></a><span class="lineno"> 3168</span>&#160;    }</div>
<div class="line"><a name="l03169"></a><span class="lineno"> 3169</span>&#160;    </div>
<div class="line"><a name="l03170"></a><span class="lineno"> 3170</span>&#160;    <span class="comment">//================================================ Release memory</span></div>
<div class="line"><a name="l03171"></a><span class="lineno"> 3171</span>&#160;    <span class="keyword">delete</span>[] rotMat;</div>
<div class="line"><a name="l03172"></a><span class="lineno"> 3172</span>&#160;    </div>
<div class="line"><a name="l03173"></a><span class="lineno"> 3173</span>&#160;    <span class="comment">//================================================ For each ret axis, compute predicted position</span></div>
<div class="line"><a name="l03174"></a><span class="lineno"> 3174</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign axIt = 0; axIt &lt; static_cast&lt; proshade_unsign &gt; ( ret-&gt;size() ); axIt++ )</div>
<div class="line"><a name="l03175"></a><span class="lineno"> 3175</span>&#160;    {</div>
<div class="line"><a name="l03176"></a><span class="lineno"> 3176</span>&#160;        <span class="comment">//============================================ Convert XYZ to lat and lon INDICES</span></div>
<div class="line"><a name="l03177"></a><span class="lineno"> 3177</span>&#160;        lat                                           = std::atan2( ret-&gt;at(axIt)[2], ret-&gt;at(axIt)[1] ) / latSamlUnit;</div>
<div class="line"><a name="l03178"></a><span class="lineno"> 3178</span>&#160;        lon                                           = std::acos ( ret-&gt;at(axIt)[3] ) / lonSamlUnit;</div>
<div class="line"><a name="l03179"></a><span class="lineno"> 3179</span>&#160; </div>
<div class="line"><a name="l03180"></a><span class="lineno"> 3180</span>&#160;        <span class="keywordflow">if</span> ( lat &lt; 0.0 )                              { lat += ( <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a367d0cd13e3d7a2648488980220ca69b">maxShellBand</a> ) * 2.0 ); }</div>
<div class="line"><a name="l03181"></a><span class="lineno"> 3181</span>&#160;        <span class="keywordflow">if</span> ( lon &lt; 0.0 )                              { lon += ( <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a367d0cd13e3d7a2648488980220ca69b">maxShellBand</a> ) * 2.0 ); }</div>
<div class="line"><a name="l03182"></a><span class="lineno"> 3182</span>&#160; </div>
<div class="line"><a name="l03183"></a><span class="lineno"> 3183</span>&#160;        <span class="comment">//============================================ Generate all angles for this fold</span></div>
<div class="line"><a name="l03184"></a><span class="lineno"> 3184</span>&#160;        applicableAngs.clear                          ( );</div>
<div class="line"><a name="l03185"></a><span class="lineno"> 3185</span>&#160;        <span class="keywordflow">for</span> ( proshade_double angIt = 1.0; angIt &lt; ret-&gt;at(axIt)[0]; angIt += 1.0 ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a> ( &amp;applicableAngs, angIt * ( 2.0 * M_PI / ret-&gt;at(axIt)[0] ) ); }</div>
<div class="line"><a name="l03186"></a><span class="lineno"> 3186</span>&#160;        </div>
<div class="line"><a name="l03187"></a><span class="lineno"> 3187</span>&#160;        <span class="comment">//============================================ For each shpere with the correct angle, average the peak heights</span></div>
<div class="line"><a name="l03188"></a><span class="lineno"> 3188</span>&#160;        ret-&gt;at(axIt)[5]                              = 0.0;</div>
<div class="line"><a name="l03189"></a><span class="lineno"> 3189</span>&#160;        <span class="keywordflow">for</span> ( <span class="keywordtype">size_t</span> angIt = 0; angIt &lt; angs.size(); angIt++ )</div>
<div class="line"><a name="l03190"></a><span class="lineno"> 3190</span>&#160;        {</div>
<div class="line"><a name="l03191"></a><span class="lineno"> 3191</span>&#160;            <span class="comment">//======================================== Find the correct sphere</span></div>
<div class="line"><a name="l03192"></a><span class="lineno"> 3192</span>&#160;            alreadyFound                              = <span class="keyword">false</span>;</div>
<div class="line"><a name="l03193"></a><span class="lineno"> 3193</span>&#160;            <span class="keywordflow">for</span> ( <span class="keywordtype">size_t</span> aIt = 0; aIt &lt; applicableAngs.size(); aIt++ ) { <span class="keywordflow">if</span> ( alreadyFound ) { <span class="keywordflow">break</span>; } <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; lhs1 ( angs.at(angIt) ), rhs1 ( applicableAngs.at(aIt) ); <span class="keywordflow">if</span> ( lhs1.AlmostEquals ( rhs1 ) ) { alreadyFound = <span class="keyword">true</span>; corAngIt = angIt; } }</div>
<div class="line"><a name="l03194"></a><span class="lineno"> 3194</span>&#160;            </div>
<div class="line"><a name="l03195"></a><span class="lineno"> 3195</span>&#160;            <span class="keywordflow">if</span> ( !alreadyFound ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l03196"></a><span class="lineno"> 3196</span>&#160;            </div>
<div class="line"><a name="l03197"></a><span class="lineno"> 3197</span>&#160;            <span class="comment">//======================================== Get its peak height for the longitude and latitude</span></div>
<div class="line"><a name="l03198"></a><span class="lineno"> 3198</span>&#160;            ret-&gt;at(axIt)[5]                         += dataObj-&gt;sphereMappedRotFun.at(corAngIt)-&gt;getSphereLatLonLinearInterpolationPos ( lat, lon );</div>
<div class="line"><a name="l03199"></a><span class="lineno"> 3199</span>&#160;        }</div>
<div class="line"><a name="l03200"></a><span class="lineno"> 3200</span>&#160;        </div>
<div class="line"><a name="l03201"></a><span class="lineno"> 3201</span>&#160;        <span class="comment">//============================================ And average the peak heights over the axis</span></div>
<div class="line"><a name="l03202"></a><span class="lineno"> 3202</span>&#160;        ret-&gt;at(axIt)[5]                             /= ( ret-&gt;at(axIt)[0] - 1.0 );</div>
<div class="line"><a name="l03203"></a><span class="lineno"> 3203</span>&#160;        maxSum                                       += ret-&gt;at(axIt)[5];</div>
<div class="line"><a name="l03204"></a><span class="lineno"> 3204</span>&#160;    }</div>
<div class="line"><a name="l03205"></a><span class="lineno"> 3205</span>&#160;    </div>
<div class="line"><a name="l03206"></a><span class="lineno"> 3206</span>&#160;    <span class="comment">//================================================ Report progress</span></div>
<div class="line"><a name="l03207"></a><span class="lineno"> 3207</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a4f98d32ed17424a1d8bf451a68370e20">ProSHADE_internal_messages::printProgressMessage</a>  ( settings-&gt;<a class="code" href="class_pro_s_h_a_d_e__settings.html#a89094c73ae033812d4df0bd846e03442">verbose</a>, 3, <span class="stringliteral">&quot;Peak height detection and rotation optimisation complete.&quot;</span>, settings-&gt;<a class="code" href="class_pro_s_h_a_d_e__settings.html#a286453ecf4904c2957e792a24567af6b">messageShift</a> );</div>
<div class="line"><a name="l03208"></a><span class="lineno"> 3208</span>&#160;    </div>
<div class="line"><a name="l03209"></a><span class="lineno"> 3209</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l03210"></a><span class="lineno"> 3210</span>&#160;    return ;</div>
<div class="line"><a name="l03211"></a><span class="lineno"> 3211</span>&#160;    </div>
<div class="line"><a name="l03212"></a><span class="lineno"> 3212</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a58c00659b5f6abf315fb5a426c45810c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c00659b5f6abf315fb5a426c45810c">&#9670;&nbsp;</a></span>findPredictedSingleAxisHeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">proshade_double ProSHADE_internal_symmetry::findPredictedSingleAxisHeight </td>
          <td>(</td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__settings.html">ProSHADE_settings</a> *&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function finds the rotation function value for a single axis. </p>
<p>This function is a simplified version of the findPredictedAxesHeights, except this one searches for the density map peak height for a single supplied axis (with the format of the array being x = [0], y = [1] and z = [2] and the fold being supplied separately).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">axis</td><td>A single axis for which the height is to be found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fold</td><td>The fold the axis should have. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataObj</td><td>The structure object with computed rotation function in which the peaks are to be found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">settings</td><td><a class="el" href="class_pro_s_h_a_d_e__settings.html" title="This class stores all the settings and is passed to the executive classes instead of a multitude of p...">ProSHADE_settings</a> object containing all the settings for this run. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">height</td><td>The height for this axis. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l03367">3367</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03368"></a><span class="lineno"> 3368</span>&#160;{</div>
<div class="line"><a name="l03369"></a><span class="lineno"> 3369</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l03370"></a><span class="lineno"> 3370</span>&#160;    proshade_double height                            = 0.0;</div>
<div class="line"><a name="l03371"></a><span class="lineno"> 3371</span>&#160;    proshade_double lat, lon;</div>
<div class="line"><a name="l03372"></a><span class="lineno"> 3372</span>&#160;    proshade_double latSamlUnit                       = ( 2.0 * M_PI ) / ( <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a367d0cd13e3d7a2648488980220ca69b">maxShellBand</a> ) * 2.0 );</div>
<div class="line"><a name="l03373"></a><span class="lineno"> 3373</span>&#160;    proshade_double lonSamlUnit                       = ( 1.0 * M_PI ) / ( <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a367d0cd13e3d7a2648488980220ca69b">maxShellBand</a> ) * 2.0 );</div>
<div class="line"><a name="l03374"></a><span class="lineno"> 3374</span>&#160;    </div>
<div class="line"><a name="l03375"></a><span class="lineno"> 3375</span>&#160;    <span class="comment">//================================================ Make sure we have a clean start</span></div>
<div class="line"><a name="l03376"></a><span class="lineno"> 3376</span>&#160;    dataObj-&gt;sphereMappedRotFun.clear                 ( );</div>
<div class="line"><a name="l03377"></a><span class="lineno"> 3377</span>&#160;    </div>
<div class="line"><a name="l03378"></a><span class="lineno"> 3378</span>&#160;    <span class="comment">//================================================ Convert rotation function to only the required angle-axis space spheres and find all peaks</span></div>
<div class="line"><a name="l03379"></a><span class="lineno"> 3379</span>&#160;    <span class="keywordflow">for</span> ( proshade_double angIt = 1.0; angIt &lt; fold; angIt += 1.0 )</div>
<div class="line"><a name="l03380"></a><span class="lineno"> 3380</span>&#160;    {</div>
<div class="line"><a name="l03381"></a><span class="lineno"> 3381</span>&#160;        <span class="comment">//============================================ Create the angle-axis sphere with correct radius (angle)</span></div>
<div class="line"><a name="l03382"></a><span class="lineno"> 3382</span>&#160;        dataObj-&gt;sphereMappedRotFun.emplace_back      ( <span class="keyword">new</span> <a class="code" href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere.html">ProSHADE_internal_spheres::ProSHADE_rotFun_sphere</a> ( angIt * ( 2.0 * M_PI / fold ),</div>
<div class="line"><a name="l03383"></a><span class="lineno"> 3383</span>&#160;                                                                                                                M_PI / fold,</div>
<div class="line"><a name="l03384"></a><span class="lineno"> 3384</span>&#160;                                                                                                                dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a367d0cd13e3d7a2648488980220ca69b">maxShellBand</a> * 2,</div>
<div class="line"><a name="l03385"></a><span class="lineno"> 3385</span>&#160;                                                                                                                angIt * ( 2.0 * M_PI / fold ),</div>
<div class="line"><a name="l03386"></a><span class="lineno"> 3386</span>&#160;                                                                                                                <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( angIt - 1.0 ) ) );</div>
<div class="line"><a name="l03387"></a><span class="lineno"> 3387</span>&#160;        </div>
<div class="line"><a name="l03388"></a><span class="lineno"> 3388</span>&#160;        <span class="comment">//============================================ Interpolate rotation function onto the sphere</span></div>
<div class="line"><a name="l03389"></a><span class="lineno"> 3389</span>&#160;        dataObj-&gt;sphereMappedRotFun.at( <span class="keyword">static_cast &lt;</span> proshade_unsign <span class="keyword">&gt;</span> ( angIt - 1.0 ))-&gt;interpolateSphereValues ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a2eb10989a2f8d46b849cdaf8410b68be">getInvSO3Coeffs</a> ( ) );</div>
<div class="line"><a name="l03390"></a><span class="lineno"> 3390</span>&#160;    }</div>
<div class="line"><a name="l03391"></a><span class="lineno"> 3391</span>&#160;    </div>
<div class="line"><a name="l03392"></a><span class="lineno"> 3392</span>&#160;    <span class="comment">//================================================ Convert XYZ to lat and lon INDICES</span></div>
<div class="line"><a name="l03393"></a><span class="lineno"> 3393</span>&#160;    lat                                               = std::atan2( axis[1], axis[0] ) / latSamlUnit;</div>
<div class="line"><a name="l03394"></a><span class="lineno"> 3394</span>&#160;    lon                                               = std::acos ( axis[2] ) / lonSamlUnit;</div>
<div class="line"><a name="l03395"></a><span class="lineno"> 3395</span>&#160;    </div>
<div class="line"><a name="l03396"></a><span class="lineno"> 3396</span>&#160;    <span class="keywordflow">if</span> ( lat &lt; 0.0 ) { lat += ( <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a367d0cd13e3d7a2648488980220ca69b">maxShellBand</a> ) * 2.0 ); }</div>
<div class="line"><a name="l03397"></a><span class="lineno"> 3397</span>&#160;    <span class="keywordflow">if</span> ( lon &lt; 0.0 ) { lon += ( <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( dataObj-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a367d0cd13e3d7a2648488980220ca69b">maxShellBand</a> ) * 2.0 ); }</div>
<div class="line"><a name="l03398"></a><span class="lineno"> 3398</span>&#160;    </div>
<div class="line"><a name="l03399"></a><span class="lineno"> 3399</span>&#160;    lat                                               = std::round ( lat );</div>
<div class="line"><a name="l03400"></a><span class="lineno"> 3400</span>&#160;    lon                                               = std::round ( lon );</div>
<div class="line"><a name="l03401"></a><span class="lineno"> 3401</span>&#160;    </div>
<div class="line"><a name="l03402"></a><span class="lineno"> 3402</span>&#160;    <span class="comment">//================================================ Initialise the peak group</span></div>
<div class="line"><a name="l03403"></a><span class="lineno"> 3403</span>&#160;    <a class="code" href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere_peak_group.html">ProSHADE_internal_spheres::ProSHADE_rotFun_spherePeakGroup</a>* grp = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l03404"></a><span class="lineno"> 3404</span>&#160;    </div>
<div class="line"><a name="l03405"></a><span class="lineno"> 3405</span>&#160;    <span class="comment">//================================================ Construct a peak group with entry from each sphere with the axis as the peak</span></div>
<div class="line"><a name="l03406"></a><span class="lineno"> 3406</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign sphIt = 0; sphIt &lt; static_cast&lt;proshade_unsign&gt; ( dataObj-&gt;sphereMappedRotFun.size() ); sphIt++ )</div>
<div class="line"><a name="l03407"></a><span class="lineno"> 3407</span>&#160;    {</div>
<div class="line"><a name="l03408"></a><span class="lineno"> 3408</span>&#160;        <span class="keywordflow">if</span> ( sphIt == 0 )</div>
<div class="line"><a name="l03409"></a><span class="lineno"> 3409</span>&#160;        {</div>
<div class="line"><a name="l03410"></a><span class="lineno"> 3410</span>&#160;            <span class="comment">//======================================== If first sphere, create the peak group</span></div>
<div class="line"><a name="l03411"></a><span class="lineno"> 3411</span>&#160;            grp                                       = <span class="keyword">new</span> <a class="code" href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere_peak_group.html">ProSHADE_internal_spheres::ProSHADE_rotFun_spherePeakGroup</a> ( lat, lon, sphIt, dataObj-&gt;sphereMappedRotFun.at(sphIt)-&gt;getAngularDim() );</div>
<div class="line"><a name="l03412"></a><span class="lineno"> 3412</span>&#160;        }</div>
<div class="line"><a name="l03413"></a><span class="lineno"> 3413</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l03414"></a><span class="lineno"> 3414</span>&#160;        {</div>
<div class="line"><a name="l03415"></a><span class="lineno"> 3415</span>&#160;            <span class="comment">//======================================== Add to the existing object</span></div>
<div class="line"><a name="l03416"></a><span class="lineno"> 3416</span>&#160;            grp-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere_peak_group.html#a3b9036c0e6a0aee55a7b480f216db845">checkIfPeakBelongs</a>                   ( lat, lon, sphIt, settings-&gt;<a class="code" href="class_pro_s_h_a_d_e__settings.html#a4627b03c4064d3de15efb3ebbf57ed78">axisErrTolerance</a>, settings-&gt;<a class="code" href="class_pro_s_h_a_d_e__settings.html#a89094c73ae033812d4df0bd846e03442">verbose</a>, settings-&gt;<a class="code" href="class_pro_s_h_a_d_e__settings.html#a286453ecf4904c2957e792a24567af6b">messageShift</a> );</div>
<div class="line"><a name="l03417"></a><span class="lineno"> 3417</span>&#160;        }</div>
<div class="line"><a name="l03418"></a><span class="lineno"> 3418</span>&#160;    }</div>
<div class="line"><a name="l03419"></a><span class="lineno"> 3419</span>&#160;    </div>
<div class="line"><a name="l03420"></a><span class="lineno"> 3420</span>&#160;    <span class="comment">//================================================ Find the peak height</span></div>
<div class="line"><a name="l03421"></a><span class="lineno"> 3421</span>&#160;    std::vector &lt; proshade_double* &gt; detectedAxis;</div>
<div class="line"><a name="l03422"></a><span class="lineno"> 3422</span>&#160;    grp-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere_peak_group.html#a5632fb5fe86d3be126f37936568efbcf">findCyclicPointGroupsGivenFold</a>               ( dataObj-&gt;sphereMappedRotFun, &amp;detectedAxis, settings-&gt;<a class="code" href="class_pro_s_h_a_d_e__settings.html#afb183823a47a73d459a5bae16042bf4e">useBiCubicInterpolationOnPeaks</a>, <span class="keyword">static_cast&lt;</span> proshade_unsign <span class="keyword">&gt;</span> ( fold ), settings-&gt;<a class="code" href="class_pro_s_h_a_d_e__settings.html#a89094c73ae033812d4df0bd846e03442">verbose</a>, settings-&gt;<a class="code" href="class_pro_s_h_a_d_e__settings.html#a286453ecf4904c2957e792a24567af6b">messageShift</a> );</div>
<div class="line"><a name="l03423"></a><span class="lineno"> 3423</span>&#160;    </div>
<div class="line"><a name="l03424"></a><span class="lineno"> 3424</span>&#160;    <span class="comment">//================================================ Save it!</span></div>
<div class="line"><a name="l03425"></a><span class="lineno"> 3425</span>&#160;    <span class="keywordflow">if</span> ( detectedAxis.size() &gt; 0 )                    { height = detectedAxis.at(0)[5]; }</div>
<div class="line"><a name="l03426"></a><span class="lineno"> 3426</span>&#160;    <span class="keywordflow">else</span>                                              { height = 0.0; }</div>
<div class="line"><a name="l03427"></a><span class="lineno"> 3427</span>&#160;    </div>
<div class="line"><a name="l03428"></a><span class="lineno"> 3428</span>&#160;    <span class="comment">//================================================ Release memory</span></div>
<div class="line"><a name="l03429"></a><span class="lineno"> 3429</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign i = 0; i &lt; static_cast &lt; proshade_unsign &gt; ( detectedAxis.size() ); i++ ) { <span class="keyword">delete</span> detectedAxis.at(i); }</div>
<div class="line"><a name="l03430"></a><span class="lineno"> 3430</span>&#160;    <span class="keyword">delete</span> grp;</div>
<div class="line"><a name="l03431"></a><span class="lineno"> 3431</span>&#160;    </div>
<div class="line"><a name="l03432"></a><span class="lineno"> 3432</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l03433"></a><span class="lineno"> 3433</span>&#160;    <span class="keywordflow">return</span>                                            ( height );</div>
<div class="line"><a name="l03434"></a><span class="lineno"> 3434</span>&#160;    </div>
<div class="line"><a name="l03435"></a><span class="lineno"> 3435</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a29b1e5bdc80f63a47d0abff4b66ee6b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29b1e5bdc80f63a47d0abff4b66ee6b2">&#9670;&nbsp;</a></span>findReliableUnphasedSymmetries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; proshade_unsign &gt; ProSHADE_internal_symmetry::findReliableUnphasedSymmetries </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; proshade_double &gt; &gt; *&#160;</td>
          <td class="paramname"><em>allCs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>messageShift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks the list of detected axes (presumably from phaseless symmetry detection) and returns the best dihedral (or cyclic, if no dihedral is found) point group, or empty vector if nothing is found. </p>
<p>This function starts by computing a stringent rotation function height threshold and proceeds to search for orthogonal pair of axes with at least this threshold RF value. If more than one pair is found, the pair with the highest sum of RF value and FSC value is chosen and returned, while if no pair is found, a single axis passing the threshold (and with the highest RF + FSC value sum) is returned. If no axis passes, empty vector is returned.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function is intended to be used internally and specifically with phase-less symmetry detection, but it does not check for these conditions to be met!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allCs</td><td>A list of all detected symmetries in the phase-less map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>How loud the function should be in the standard output? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">messageShift</td><td>Are we in a subprocess, so that the log should be shifted for this function call? If so, by how much? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>What is the tolerance on the perpendicularity of two axes in terms of the dot product? </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>A vector containing a) zero entries if no reliable symmetry axis was found, b) a single symmetry axis index if only a reliable cyclic symmetry axis was found or c) two axes indices in the case where two perpendicular reliable axes were detected. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l03674">3674</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03675"></a><span class="lineno"> 3675</span>&#160;{</div>
<div class="line"><a name="l03676"></a><span class="lineno"> 3676</span>&#160;    <span class="comment">//================================================ Report progress</span></div>
<div class="line"><a name="l03677"></a><span class="lineno"> 3677</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a4f98d32ed17424a1d8bf451a68370e20">ProSHADE_internal_messages::printProgressMessage</a>  ( verbose, 2, <span class="stringliteral">&quot;Deciding whether any axis(es) is/are reliable.&quot;</span>, messageShift );</div>
<div class="line"><a name="l03678"></a><span class="lineno"> 3678</span>&#160;    </div>
<div class="line"><a name="l03679"></a><span class="lineno"> 3679</span>&#160;    <span class="comment">//================================================ Initialise local variables</span></div>
<div class="line"><a name="l03680"></a><span class="lineno"> 3680</span>&#160;    std::vector&lt; proshade_unsign &gt; ret;</div>
<div class="line"><a name="l03681"></a><span class="lineno"> 3681</span>&#160;    </div>
<div class="line"><a name="l03682"></a><span class="lineno"> 3682</span>&#160;    <span class="comment">//================================================ Find the threshold</span></div>
<div class="line"><a name="l03683"></a><span class="lineno"> 3683</span>&#160;    proshade_double bestHistPeakStart                 = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a26fa82e82a6a4af696cfae0581785446">ProSHADE_internal_maths::findTopGroupSmooth</a> ( allCs, 5, 0.01, 0.03, 5 );</div>
<div class="line"><a name="l03684"></a><span class="lineno"> 3684</span>&#160;    proshade_double bestFSCPeakStart                  = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a26fa82e82a6a4af696cfae0581785446">ProSHADE_internal_maths::findTopGroupSmooth</a> ( allCs, 6, 0.01, 0.005, 5, 0.94 );</div>
<div class="line"><a name="l03685"></a><span class="lineno"> 3685</span>&#160;    <span class="keywordflow">if</span> ( bestHistPeakStart &gt; 0.9 ) { bestHistPeakStart = 0.9; }</div>
<div class="line"><a name="l03686"></a><span class="lineno"> 3686</span>&#160;    </div>
<div class="line"><a name="l03687"></a><span class="lineno"> 3687</span>&#160;    <span class="comment">//================================================ Are any axes orthogonal</span></div>
<div class="line"><a name="l03688"></a><span class="lineno"> 3688</span>&#160;    proshade_double dotProduct, maxOrtSum = 0.0, curOrtSum = 0.0;</div>
<div class="line"><a name="l03689"></a><span class="lineno"> 3689</span>&#160;    proshade_unsign maxOrtAx1 = 0, maxOrtAx2 = 0;</div>
<div class="line"><a name="l03690"></a><span class="lineno"> 3690</span>&#160;    <span class="keywordflow">for</span> ( <span class="keywordtype">size_t</span> relAx1 = 0; relAx1 &lt; allCs-&gt;size(); relAx1++ )</div>
<div class="line"><a name="l03691"></a><span class="lineno"> 3691</span>&#160;    {</div>
<div class="line"><a name="l03692"></a><span class="lineno"> 3692</span>&#160;        <span class="comment">//============================================ Consider only reliable axes</span></div>
<div class="line"><a name="l03693"></a><span class="lineno"> 3693</span>&#160;        <span class="keywordflow">if</span> ( allCs-&gt;at(relAx1)[5] &lt; bestHistPeakStart ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l03694"></a><span class="lineno"> 3694</span>&#160;        <span class="keywordflow">if</span> ( allCs-&gt;at(relAx1)[6] &lt; bestFSCPeakStart  ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l03695"></a><span class="lineno"> 3695</span>&#160;        </div>
<div class="line"><a name="l03696"></a><span class="lineno"> 3696</span>&#160;        <span class="keywordflow">for</span> ( <span class="keywordtype">size_t</span> relAx2 = 1; relAx2 &lt; allCs-&gt;size(); relAx2++ )</div>
<div class="line"><a name="l03697"></a><span class="lineno"> 3697</span>&#160;        {</div>
<div class="line"><a name="l03698"></a><span class="lineno"> 3698</span>&#160;            <span class="comment">//======================================== Ignore same axes</span></div>
<div class="line"><a name="l03699"></a><span class="lineno"> 3699</span>&#160;            <span class="keywordflow">if</span> ( relAx1 &gt;= relAx2 ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l03700"></a><span class="lineno"> 3700</span>&#160;            </div>
<div class="line"><a name="l03701"></a><span class="lineno"> 3701</span>&#160;            <span class="comment">//======================================== Consider only reliable axes</span></div>
<div class="line"><a name="l03702"></a><span class="lineno"> 3702</span>&#160;            <span class="keywordflow">if</span> ( allCs-&gt;at(relAx2)[5] &lt; bestHistPeakStart ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l03703"></a><span class="lineno"> 3703</span>&#160;            <span class="keywordflow">if</span> ( allCs-&gt;at(relAx2)[6] &lt; bestFSCPeakStart  ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l03704"></a><span class="lineno"> 3704</span>&#160; </div>
<div class="line"><a name="l03705"></a><span class="lineno"> 3705</span>&#160;            <span class="comment">//======================================== Are the two axes orthogonal?</span></div>
<div class="line"><a name="l03706"></a><span class="lineno"> 3706</span>&#160;            dotProduct                                = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> ( &amp;allCs-&gt;at(relAx1)[1], &amp;allCs-&gt;at(relAx1)[2],</div>
<div class="line"><a name="l03707"></a><span class="lineno"> 3707</span>&#160;                                                                                                     &amp;allCs-&gt;at(relAx1)[3], &amp;allCs-&gt;at(relAx2)[1],</div>
<div class="line"><a name="l03708"></a><span class="lineno"> 3708</span>&#160;                                                                                                     &amp;allCs-&gt;at(relAx2)[2], &amp;allCs-&gt;at(relAx2)[3] );</div>
<div class="line"><a name="l03709"></a><span class="lineno"> 3709</span>&#160;            </div>
<div class="line"><a name="l03710"></a><span class="lineno"> 3710</span>&#160;            <span class="comment">//======================================== If close to zero, these two axes are perpendicular</span></div>
<div class="line"><a name="l03711"></a><span class="lineno"> 3711</span>&#160;            <span class="keywordflow">if</span> ( std::abs( dotProduct ) &lt; tolerance )</div>
<div class="line"><a name="l03712"></a><span class="lineno"> 3712</span>&#160;            {</div>
<div class="line"><a name="l03713"></a><span class="lineno"> 3713</span>&#160;                <span class="comment">//==================================== Find sum</span></div>
<div class="line"><a name="l03714"></a><span class="lineno"> 3714</span>&#160;                curOrtSum                             = allCs-&gt;at(relAx1)[5] + allCs-&gt;at(relAx1)[6] + allCs-&gt;at(relAx2)[5] + allCs-&gt;at(relAx2)[6];</div>
<div class="line"><a name="l03715"></a><span class="lineno"> 3715</span>&#160; </div>
<div class="line"><a name="l03716"></a><span class="lineno"> 3716</span>&#160;                <span class="comment">//==================================== If best, save it</span></div>
<div class="line"><a name="l03717"></a><span class="lineno"> 3717</span>&#160;                <span class="keywordflow">if</span> ( curOrtSum &gt; maxOrtSum )</div>
<div class="line"><a name="l03718"></a><span class="lineno"> 3718</span>&#160;                {</div>
<div class="line"><a name="l03719"></a><span class="lineno"> 3719</span>&#160;                    maxOrtSum                         = curOrtSum;</div>
<div class="line"><a name="l03720"></a><span class="lineno"> 3720</span>&#160;                    maxOrtAx1                         = <span class="keyword">static_cast&lt;</span> proshade_unsign <span class="keyword">&gt;</span> ( relAx1 );</div>
<div class="line"><a name="l03721"></a><span class="lineno"> 3721</span>&#160;                    maxOrtAx2                         = <span class="keyword">static_cast&lt;</span> proshade_unsign <span class="keyword">&gt;</span> ( relAx2 );</div>
<div class="line"><a name="l03722"></a><span class="lineno"> 3722</span>&#160;                }</div>
<div class="line"><a name="l03723"></a><span class="lineno"> 3723</span>&#160;            }</div>
<div class="line"><a name="l03724"></a><span class="lineno"> 3724</span>&#160;        }</div>
<div class="line"><a name="l03725"></a><span class="lineno"> 3725</span>&#160;    }</div>
<div class="line"><a name="l03726"></a><span class="lineno"> 3726</span>&#160;    </div>
<div class="line"><a name="l03727"></a><span class="lineno"> 3727</span>&#160;    <span class="comment">//================================================ If any orthogonal pair was found, return it</span></div>
<div class="line"><a name="l03728"></a><span class="lineno"> 3728</span>&#160;    <span class="keywordflow">if</span> ( maxOrtAx2 != 0 )</div>
<div class="line"><a name="l03729"></a><span class="lineno"> 3729</span>&#160;    {</div>
<div class="line"><a name="l03730"></a><span class="lineno"> 3730</span>&#160;        <span class="comment">//================================================ Report progress</span></div>
<div class="line"><a name="l03731"></a><span class="lineno"> 3731</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a>     ( &amp;ret, maxOrtAx1 );</div>
<div class="line"><a name="l03732"></a><span class="lineno"> 3732</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a>     ( &amp;ret, maxOrtAx2 );</div>
<div class="line"><a name="l03733"></a><span class="lineno"> 3733</span>&#160;        <span class="keywordflow">return</span>                                        ( ret );</div>
<div class="line"><a name="l03734"></a><span class="lineno"> 3734</span>&#160;    }</div>
<div class="line"><a name="l03735"></a><span class="lineno"> 3735</span>&#160;    </div>
<div class="line"><a name="l03736"></a><span class="lineno"> 3736</span>&#160;    <span class="comment">//================================================ Well, no orthogonal axes. Is there at least one good axis?</span></div>
<div class="line"><a name="l03737"></a><span class="lineno"> 3737</span>&#160;    curOrtSum = 0.0; maxOrtSum = 0.0;</div>
<div class="line"><a name="l03738"></a><span class="lineno"> 3738</span>&#160;    <span class="keywordflow">for</span> ( <span class="keywordtype">size_t</span> relAx1 = 0; relAx1 &lt; allCs-&gt;size(); relAx1++ )</div>
<div class="line"><a name="l03739"></a><span class="lineno"> 3739</span>&#160;    {</div>
<div class="line"><a name="l03740"></a><span class="lineno"> 3740</span>&#160;        <span class="comment">//============================================ Consider only reliable axes in terms of RF</span></div>
<div class="line"><a name="l03741"></a><span class="lineno"> 3741</span>&#160;        <span class="keywordflow">if</span> ( allCs-&gt;at(relAx1)[5] &lt; bestHistPeakStart ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l03742"></a><span class="lineno"> 3742</span>&#160;        </div>
<div class="line"><a name="l03743"></a><span class="lineno"> 3743</span>&#160;        <span class="comment">//============================================ Consider only reasonable axes in terms of FSC</span></div>
<div class="line"><a name="l03744"></a><span class="lineno"> 3744</span>&#160;        <span class="keywordflow">if</span> ( allCs-&gt;at(relAx1)[6] &lt; 0.3 ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l03745"></a><span class="lineno"> 3745</span>&#160;        </div>
<div class="line"><a name="l03746"></a><span class="lineno"> 3746</span>&#160;        <span class="comment">//============================================ Get the sum</span></div>
<div class="line"><a name="l03747"></a><span class="lineno"> 3747</span>&#160;        curOrtSum                                     = allCs-&gt;at(relAx1)[5] + allCs-&gt;at(relAx1)[6];</div>
<div class="line"><a name="l03748"></a><span class="lineno"> 3748</span>&#160;        </div>
<div class="line"><a name="l03749"></a><span class="lineno"> 3749</span>&#160;        <span class="comment">//============================================ If highest sum, save</span></div>
<div class="line"><a name="l03750"></a><span class="lineno"> 3750</span>&#160;        <span class="keywordflow">if</span> ( curOrtSum &gt; maxOrtSum )</div>
<div class="line"><a name="l03751"></a><span class="lineno"> 3751</span>&#160;        {</div>
<div class="line"><a name="l03752"></a><span class="lineno"> 3752</span>&#160;            maxOrtSum                                 = curOrtSum;</div>
<div class="line"><a name="l03753"></a><span class="lineno"> 3753</span>&#160;            maxOrtAx1                                 = <span class="keyword">static_cast&lt;</span> proshade_unsign <span class="keyword">&gt;</span> ( relAx1 );</div>
<div class="line"><a name="l03754"></a><span class="lineno"> 3754</span>&#160;        }</div>
<div class="line"><a name="l03755"></a><span class="lineno"> 3755</span>&#160;    }</div>
<div class="line"><a name="l03756"></a><span class="lineno"> 3756</span>&#160;    </div>
<div class="line"><a name="l03757"></a><span class="lineno"> 3757</span>&#160;    <span class="comment">//================================================ If anything was found, save it</span></div>
<div class="line"><a name="l03758"></a><span class="lineno"> 3758</span>&#160;    <span class="keywordflow">if</span> ( maxOrtSum &gt; 0.1 )</div>
<div class="line"><a name="l03759"></a><span class="lineno"> 3759</span>&#160;    {</div>
<div class="line"><a name="l03760"></a><span class="lineno"> 3760</span>&#160;        <span class="comment">//============================================ Report progress</span></div>
<div class="line"><a name="l03761"></a><span class="lineno"> 3761</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a4f98d32ed17424a1d8bf451a68370e20">ProSHADE_internal_messages::printProgressMessage</a>  ( verbose, 3, <span class="stringliteral">&quot;Found single reliable axis.&quot;</span>, messageShift );</div>
<div class="line"><a name="l03762"></a><span class="lineno"> 3762</span>&#160;        </div>
<div class="line"><a name="l03763"></a><span class="lineno"> 3763</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a>     ( &amp;ret, maxOrtAx1 );</div>
<div class="line"><a name="l03764"></a><span class="lineno"> 3764</span>&#160;    }</div>
<div class="line"><a name="l03765"></a><span class="lineno"> 3765</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l03766"></a><span class="lineno"> 3766</span>&#160;    {</div>
<div class="line"><a name="l03767"></a><span class="lineno"> 3767</span>&#160;        <span class="comment">//================================================ Report progress</span></div>
<div class="line"><a name="l03768"></a><span class="lineno"> 3768</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a4f98d32ed17424a1d8bf451a68370e20">ProSHADE_internal_messages::printProgressMessage</a>  ( verbose, 3, <span class="stringliteral">&quot;Found no reliable axis.&quot;</span>, messageShift );</div>
<div class="line"><a name="l03769"></a><span class="lineno"> 3769</span>&#160;    }</div>
<div class="line"><a name="l03770"></a><span class="lineno"> 3770</span>&#160;    </div>
<div class="line"><a name="l03771"></a><span class="lineno"> 3771</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l03772"></a><span class="lineno"> 3772</span>&#160;    <span class="keywordflow">return</span>                                            ( ret );</div>
<div class="line"><a name="l03773"></a><span class="lineno"> 3773</span>&#160;    </div>
<div class="line"><a name="l03774"></a><span class="lineno"> 3774</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5e5d3ccec33e4cf7204124a5647fe5c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5d3ccec33e4cf7204124a5647fe5c9">&#9670;&nbsp;</a></span>findTetra3C2s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::findTetra3C2s </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>messageShift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes the list of C symmetries and finds the 3 C2 symmetries with correct angles required for full tetrahedral symmetry. </p>
<p>This is a specific helper function for detecting three C2 symmetries perpendicular to each other hand having a specific angle ( acos(0.5) ) to one of the already detected C3 symmetries of the sought after tetrahedral symmetry. It firstly finds all C2s and tests these for having the acos(0.5) angle to the already found C3s. From this list of passing C2s, it then tries to find three mutually perpendicular axes, including searching for missing axes. If no such axes are found, the ret array will still have 4 entries, while if they are found, the ret array will have these added to the total of 7 entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>The vector . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verobse</td><td>How loud the announcments should be? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">messageShift</td><td>Are we in a subprocess, so that the log should be shifted for this function call? If so, by how much? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum average peak height for axis to be considered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01076">1076</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;{</div>
<div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;    std::vector&lt; proshade_unsign &gt; C3s, prospectiveC2s, C2PossibilitiesHlp;</div>
<div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;    std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; C2Possibilities;</div>
<div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;    proshade_double dotProd;</div>
<div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;    <span class="keywordtype">bool</span> groupMatched;</div>
<div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; 4; iter++ ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C3s, iter ); }</div>
<div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;    </div>
<div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;    <span class="comment">//================================================ Report progress</span></div>
<div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a4f98d32ed17424a1d8bf451a68370e20">ProSHADE_internal_messages::printProgressMessage</a>  ( verbose, 2, <span class="stringliteral">&quot;Starting detection of three C2 axes.&quot;</span>, messageShift );</div>
<div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;    </div>
<div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;    <span class="comment">//================================================ For each C3</span></div>
<div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign rIt = 0; rIt &lt; static_cast&lt;proshade_unsign&gt; ( ret-&gt;size() ); rIt++ )</div>
<div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;    {</div>
<div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;        <span class="comment">//============================================ For each C2, check it has angle ( acos(0.5) ) to the tested C3</span></div>
<div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign cIt = 0; cIt &lt; static_cast&lt;proshade_unsign&gt; ( CSymList-&gt;size() ); cIt++ )</div>
<div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;        {</div>
<div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;            <span class="comment">//======================================== Search only using C2s</span></div>
<div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;            <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; lhs999 ( CSymList-&gt;at(cIt)[5] ), rhs999 ( <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( -999.9 ) );</div>
<div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;            <span class="keywordflow">if</span> ( CSymList-&gt;at(cIt)[0] != 2.0 || ( ( CSymList-&gt;at(cIt)[5] &lt; minPeakHeight ) &amp;&amp; !( lhs999.AlmostEquals( rhs999 ) ) ) ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;            </div>
<div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;            <span class="comment">//======================================== Check the C2 axis to the C3 ( acos ( 0.5 ) )</span></div>
<div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;            dotProd = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> ( &amp;ret-&gt;at(rIt)[1], &amp;ret-&gt;at(rIt)[2], &amp;ret-&gt;at(rIt)[3],</div>
<div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;                                                                   &amp;CSymList-&gt;at(cIt)[1], &amp;CSymList-&gt;at(cIt)[2], &amp;CSymList-&gt;at(cIt)[3] );</div>
<div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;            </div>
<div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;            <span class="keywordflow">if</span> ( ( std::abs ( dotProd ) &gt; ( 0.5 - axErr ) ) &amp;&amp; ( std::abs ( dotProd ) &lt; ( 0.5 + axErr ) ) ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;prospectiveC2s, cIt ); }</div>
<div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;        }</div>
<div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;    }</div>
<div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;        </div>
<div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;    <span class="comment">//================================================ Group the prospective C2s</span></div>
<div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;    C2Possibilities.clear(); C2PossibilitiesHlp.clear();</div>
<div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign cIt = 0; cIt &lt; static_cast&lt;proshade_unsign&gt; ( prospectiveC2s.size() ); cIt++ )</div>
<div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;    {</div>
<div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;        <span class="comment">//============================================ If second or more C2, check if it can be placed in any group with being perpendicular to all its members</span></div>
<div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;        groupMatched                                  = <span class="keyword">false</span>;</div>
<div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign gIt = 0; gIt &lt; static_cast&lt;proshade_unsign&gt; ( C2Possibilities.size() ); gIt++ )</div>
<div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;        {</div>
<div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;            <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad8c193e95c7069fafa78dccc1de1aaa4">ProSHADE_internal_symmetry::testGroupAgainstSymmetry</a> ( CSymList, &amp;C2Possibilities.at(gIt), CSymList-&gt;at(prospectiveC2s.at(cIt)), axErr, 0.0, <span class="keyword">true</span>, prospectiveC2s.at(cIt) ) ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C2Possibilities.at(gIt), prospectiveC2s.at(cIt) ); groupMatched = <span class="keyword">true</span>; <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;        }</div>
<div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;        </div>
<div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;        <span class="comment">//============================================ If no group matched, create a new group</span></div>
<div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;        <span class="keywordflow">if</span> ( !groupMatched ) { C2PossibilitiesHlp.clear(); <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C2PossibilitiesHlp, prospectiveC2s.at(cIt) ); <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a86e2bb172f766ab4a620df482d2fe481">ProSHADE_internal_misc::addToUnsignVectorVector</a> ( &amp;C2Possibilities, C2PossibilitiesHlp ); <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;    }</div>
<div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;    </div>
<div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;    <span class="comment">//================================================ Find the best group or return empty</span></div>
<div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;    <span class="keywordflow">while</span> ( C2Possibilities.size() != 0 )</div>
<div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;    {</div>
<div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;        <span class="comment">//============================================ Test for missing symmetry axes, if need be</span></div>
<div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af6093da290ce7b73a33e8b55f2c83491">ProSHADE_internal_symmetry::findMissingAxes</a>   ( &amp;C2Possibilities, CSymList, 3, axErr, 0.0, 2, dataObj, minPeakHeight );</div>
<div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;        </div>
<div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;        <span class="comment">//============================================ Found 3 C2s?</span></div>
<div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;        <span class="keywordflow">if</span> ( C2Possibilities.at(0).size() == 3 )</div>
<div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;        {</div>
<div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;            <span class="comment">//======================================== Success! Save and exit</span></div>
<div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;            <span class="keywordflow">for</span> ( proshade_unsign it = 0; it &lt; 3; it++ ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a> ( ret, CSymList-&gt;at(C2Possibilities.at(0).at(it)) ); }</div>
<div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;            </div>
<div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;            <span class="comment">//======================================== Report progress</span></div>
<div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a4f98d32ed17424a1d8bf451a68370e20">ProSHADE_internal_messages::printProgressMessage</a> ( verbose, 3, <span class="stringliteral">&quot;Detection of three C2 axes successfull.&quot;</span>, messageShift );</div>
<div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;            </div>
<div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;            <span class="comment">//======================================== Done</span></div>
<div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;            return ;</div>
<div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;        }</div>
<div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;        <span class="keywordflow">else</span> { C2Possibilities.erase ( C2Possibilities.begin() ); }</div>
<div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;    }</div>
<div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;  </div>
<div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;    return ;</div>
<div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;    </div>
<div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5d4e5e34da6e4a9ed4a67cca16491c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d4e5e34da6e4a9ed4a67cca16491c17">&#9670;&nbsp;</a></span>findTetra4C3s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::findTetra4C3s </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>messageShift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes the list of C symmetries and finds the 4 C3 symmetries with correct angles required for full tetrahedral symmetry. </p>
<p>This function is specific to detecting the tetrahedral symmetry. It should be called once tetrahedral symmetry is suspected (by detecting its dihedral angles) and it needs to be fully described. This function specifically searches for the four C3 symmetries which must all be detected in order to fully describe tetrahedral symmetry. If all four are found, the ret vector will contain these as its only four entries, while it will be empty if some of the C3 symmetries are not found. The missing symmetry axis detection is implemented as part of this function as well.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>The vector . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>How loud the announcments should be? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">messageShift</td><td>Are we in a subprocess, so that the log should be shifted for this function call? If so, by how much? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum average peak height for axis to be considered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00539">539</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;{</div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;    std::vector&lt; proshade_unsign &gt; C3PossibilitiesHlp;</div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;    std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; C3Possibilities;</div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;    <span class="keywordtype">bool</span> groupMatched;</div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;    </div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;    <span class="comment">//================================================ Report progress</span></div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a4f98d32ed17424a1d8bf451a68370e20">ProSHADE_internal_messages::printProgressMessage</a> ( verbose, 2, <span class="stringliteral">&quot;Starting detection of four C3 axes.&quot;</span>, messageShift );</div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;    </div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;    <span class="comment">//================================================ For all symmetries in the C symmetries list</span></div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign cIt = 0; cIt &lt; static_cast&lt;proshade_unsign&gt; ( CSymList-&gt;size() ); cIt++ )</div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;    {</div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;        <span class="comment">//============================================ Search only using C3s</span></div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;        <span class="keywordflow">if</span> ( CSymList-&gt;at(cIt)[0] != 3.0 || CSymList-&gt;at(cIt)[0] &lt; minPeakHeight ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;        </div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;        <span class="comment">//============================================ If this is the first C3, then just save it to the first group of the temporary holder</span></div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;        <span class="keywordflow">if</span> ( C3Possibilities.size() == 0 ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C3PossibilitiesHlp, cIt ); <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a86e2bb172f766ab4a620df482d2fe481">ProSHADE_internal_misc::addToUnsignVectorVector</a> ( &amp;C3Possibilities, C3PossibilitiesHlp ); <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;        </div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;        <span class="comment">//============================================ If second or more C3, check if it has the correct angle to all other already found C3s for each group</span></div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;        groupMatched                                  = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign gIt = 0; gIt &lt; static_cast&lt;proshade_unsign&gt; ( C3Possibilities.size() ); gIt++ )</div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;        {</div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;            <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad8c193e95c7069fafa78dccc1de1aaa4">ProSHADE_internal_symmetry::testGroupAgainstSymmetry</a> ( CSymList, &amp;C3Possibilities.at(gIt), CSymList-&gt;at(cIt), axErr, 1.0/3.0, <span class="keyword">true</span>, cIt ) ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C3Possibilities.at(gIt), cIt ); groupMatched = <span class="keyword">true</span>; <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;        }</div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;        </div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;        <span class="comment">//============================================ If no group matched, create a new group</span></div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;        <span class="keywordflow">if</span> ( !groupMatched ) { C3PossibilitiesHlp.clear(); <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a> ( &amp;C3PossibilitiesHlp, cIt ); <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a86e2bb172f766ab4a620df482d2fe481">ProSHADE_internal_misc::addToUnsignVectorVector</a> ( &amp;C3Possibilities, C3PossibilitiesHlp ); <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;    }</div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;    </div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;    <span class="comment">//================================================ Test for missing symmetry axes, if need be</span></div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af6093da290ce7b73a33e8b55f2c83491">ProSHADE_internal_symmetry::findMissingAxes</a>       ( &amp;C3Possibilities, CSymList, 4, axErr, 1.0/3.0, 3, dataObj, minPeakHeight );</div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;    </div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;    <span class="comment">//================================================ Any group has 4 entries? If more such groups, take the one with highest average height.</span></div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;    proshade_double maxHeight = 0.0; proshade_unsign maxGrp = 0;</div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; static_cast&lt;proshade_unsign&gt; ( C3Possibilities.size() ); iter++ ) { <span class="keywordflow">if</span> ( C3Possibilities.at(iter).size() == 4 ) { <span class="keywordflow">if</span> ( ( ( CSymList-&gt;at(C3Possibilities.at(iter).at(0))[5] + CSymList-&gt;at(C3Possibilities.at(iter).at(1))[5] + CSymList-&gt;at(C3Possibilities.at(iter).at(2))[5] + CSymList-&gt;at(C3Possibilities.at(iter).at(3))[5] ) / 4.0 ) &gt; maxHeight ) { maxHeight = ( ( CSymList-&gt;at(C3Possibilities.at(iter).at(0))[5] + CSymList-&gt;at(C3Possibilities.at(iter).at(1))[5] + CSymList-&gt;at(C3Possibilities.at(iter).at(2))[5] + CSymList-&gt;at(C3Possibilities.at(iter).at(3))[5] ) / 4.0 ); maxGrp = iter; } } }</div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;    </div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;    <span class="keywordflow">if</span> ( C3Possibilities.at(maxGrp).size() == 4 )</div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;    {</div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;        <span class="comment">//============================================ Success! Save and exit</span></div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign it = 0; it &lt; static_cast&lt;proshade_unsign&gt; ( C3Possibilities.at(maxGrp).size() ); it++ ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a> ( ret, CSymList-&gt;at(C3Possibilities.at(maxGrp).at(it)) ); }</div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;        </div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;        <span class="comment">//============================================ Report progress</span></div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__messages.html#a4f98d32ed17424a1d8bf451a68370e20">ProSHADE_internal_messages::printProgressMessage</a> ( verbose, 3, <span class="stringliteral">&quot;Detection of four C3 axes successfull.&quot;</span>, messageShift );</div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;        </div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;        <span class="comment">//============================================ Done</span></div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;        return ;</div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;    }</div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;    </div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;    return ;</div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;    </div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3ec1b87286193d7797b6afa2bed1ea33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec1b87286193d7797b6afa2bed1ea33">&#9670;&nbsp;</a></span>findTranslationBetweenRotatedAndOriginalMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; proshade_double &gt; ProSHADE_internal_symmetry::findTranslationBetweenRotatedAndOriginalMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>symStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double &gt;&#160;</td>
          <td class="paramname"><em>symElem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_complex *&#160;</td>
          <td class="paramname"><em>origCoeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_complex *&#160;</td>
          <td class="paramname"><em>rotMapComplex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_complex *&#160;</td>
          <td class="paramname"><em>rotCoeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_plan&#160;</td>
          <td class="paramname"><em>planForwardFourierRot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_complex *&#160;</td>
          <td class="paramname"><em>trFuncCoeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_complex *&#160;</td>
          <td class="paramname"><em>trFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_plan&#160;</td>
          <td class="paramname"><em>planReverseFourierComb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes a single rotation matrix and procceds to compute the optimal translation between the original map and a map rotated by the supplied rotation matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">symStr</td><td>A ProSHADE_data structure containing the structure for which the line on which the centre of rotation lies is to be found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">symElems</td><td>Vector containing single symmetry element (rotaiton matrix) which is not identity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">origCoeffs</td><td>The Fourier coefficients of the original (non-rotated) map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotMapComplex</td><td>Array to which the rotated map will be saved and from which the Fourier transform plan (planForwardFourierRot) is prepared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotCoeffs</td><td>Array to which the result of the Fourier transform of the rotated map will be saved into by the supplied plan (planForwardFourierRot). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">planForwardFourierRot</td><td>FFTW3 plan for forward Fourier transform from rotMapComplex to rotCoeffs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trFuncCoeffs</td><td>The array to which the combined Fourier coefficients for translation function will be saved into and also for which the inverse Fourier transform plan (planReverseFourierComb) is prepared for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trFunc</td><td>The array to which the translation function will be saved into by the reverse Fourier transform planned by the plan (planReverseFourierComb). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">planReverseFourierComb</td><td>FFTW3 plan for reverse Fourier transform from the combined coefficients (trFuncCoeffs) to the translation function array (trFunc). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">trsVec</td><td>A vector containing the optimal translation between the original and the rotated maps in Angstroms. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l03869">3869</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03870"></a><span class="lineno"> 3870</span>&#160;{</div>
<div class="line"><a name="l03871"></a><span class="lineno"> 3871</span>&#160;    <span class="comment">//================================================ Initialise local variables</span></div>
<div class="line"><a name="l03872"></a><span class="lineno"> 3872</span>&#160;    proshade_double axX, axY, axZ, axAng, mapPeak, trsX, trsY, trsZ;</div>
<div class="line"><a name="l03873"></a><span class="lineno"> 3873</span>&#160;    std::vector&lt; proshade_double &gt; trsVec;</div>
<div class="line"><a name="l03874"></a><span class="lineno"> 3874</span>&#160;    </div>
<div class="line"><a name="l03875"></a><span class="lineno"> 3875</span>&#160;    <span class="comment">//=============================================== Rotate the map by the rotation matrix</span></div>
<div class="line"><a name="l03876"></a><span class="lineno"> 3876</span>&#160;    proshade_double *rotMap;</div>
<div class="line"><a name="l03877"></a><span class="lineno"> 3877</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#aad5409074bece14a244fad191524a687">ProSHADE_internal_maths::getAxisAngleFromRotationMatrix</a> ( &amp;symElem, &amp;axX, &amp;axY, &amp;axZ, &amp;axAng );</div>
<div class="line"><a name="l03878"></a><span class="lineno"> 3878</span>&#160;    symStr-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a22caf254dfc11e52890f79a161493e6e">rotateMapRealSpace</a>                        ( axX, axY, axZ, axAng, rotMap );</div>
<div class="line"><a name="l03879"></a><span class="lineno"> 3879</span>&#160;    </div>
<div class="line"><a name="l03880"></a><span class="lineno"> 3880</span>&#160;    <span class="comment">//================================================ Convert rotated map to Fourier space</span></div>
<div class="line"><a name="l03881"></a><span class="lineno"> 3881</span>&#160;    <span class="keywordflow">for</span> ( <span class="keywordtype">size_t</span> it = 0; it &lt; static_cast&lt; size_t &gt; ( symStr-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a3bc44913222e67ab861dd1e5838c1ae1">getXDim</a>() * symStr-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a50c884973add562558803a45991bbf19">getYDim</a>() * symStr-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a034af93b9152fb2db675d5632a4ebc6d">getZDim</a>() ); it++ ) { rotMapComplex[it][0] = rotMap[it]; rotMapComplex[it][1] = 0.0; }</div>
<div class="line"><a name="l03882"></a><span class="lineno"> 3882</span>&#160;    fftw_execute                                      ( planForwardFourierRot );</div>
<div class="line"><a name="l03883"></a><span class="lineno"> 3883</span>&#160; </div>
<div class="line"><a name="l03884"></a><span class="lineno"> 3884</span>&#160;    <span class="comment">//================================================ Combine coeffs for translation function</span></div>
<div class="line"><a name="l03885"></a><span class="lineno"> 3885</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a64ba4ba55d58078eeea8b70311e4ab49">ProSHADE_internal_maths::combineFourierForTranslation</a> ( origCoeffs, rotCoeffs, trFuncCoeffs, symStr-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a3bc44913222e67ab861dd1e5838c1ae1">getXDim</a>(), symStr-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a50c884973add562558803a45991bbf19">getYDim</a>(), symStr-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a034af93b9152fb2db675d5632a4ebc6d">getZDim</a>() );</div>
<div class="line"><a name="l03886"></a><span class="lineno"> 3886</span>&#160; </div>
<div class="line"><a name="l03887"></a><span class="lineno"> 3887</span>&#160;    <span class="comment">//================================================ Compute translation function</span></div>
<div class="line"><a name="l03888"></a><span class="lineno"> 3888</span>&#160;    fftw_execute                                      ( planReverseFourierComb );</div>
<div class="line"><a name="l03889"></a><span class="lineno"> 3889</span>&#160; </div>
<div class="line"><a name="l03890"></a><span class="lineno"> 3890</span>&#160;    <span class="comment">//================================================ Find peak</span></div>
<div class="line"><a name="l03891"></a><span class="lineno"> 3891</span>&#160;    mapPeak                                           = 0.0;</div>
<div class="line"><a name="l03892"></a><span class="lineno"> 3892</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a7caf87603d759cb0de1b0bd834ae8f6d">ProSHADE_internal_maths::findHighestValueInMap</a>    ( trFunc, symStr-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a3bc44913222e67ab861dd1e5838c1ae1">getXDim</a>(), symStr-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a50c884973add562558803a45991bbf19">getYDim</a>(), symStr-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a034af93b9152fb2db675d5632a4ebc6d">getZDim</a>(), &amp;trsX, &amp;trsY, &amp;trsZ, &amp;mapPeak );</div>
<div class="line"><a name="l03893"></a><span class="lineno"> 3893</span>&#160;    </div>
<div class="line"><a name="l03894"></a><span class="lineno"> 3894</span>&#160;    <span class="comment">//================================================ Convert to Angstroms</span></div>
<div class="line"><a name="l03895"></a><span class="lineno"> 3895</span>&#160;    trsX                                             *= <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( symStr-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a51d7b9d87d536ef0c48d820872bc9185">getXDimSize</a>() / symStr-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a3bc44913222e67ab861dd1e5838c1ae1">getXDim</a>() );</div>
<div class="line"><a name="l03896"></a><span class="lineno"> 3896</span>&#160;    trsY                                             *= <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( symStr-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#ae477e3c0d7b866e6069d8603950afe51">getYDimSize</a>() / symStr-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a50c884973add562558803a45991bbf19">getYDim</a>() );</div>
<div class="line"><a name="l03897"></a><span class="lineno"> 3897</span>&#160;    trsZ                                             *= <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( symStr-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#af4d641d62864e4adf67c1365b0960970">getZDimSize</a>() / symStr-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a034af93b9152fb2db675d5632a4ebc6d">getZDim</a>() );</div>
<div class="line"><a name="l03898"></a><span class="lineno"> 3898</span>&#160;    </div>
<div class="line"><a name="l03899"></a><span class="lineno"> 3899</span>&#160;    <span class="comment">//================================================ Do not translate over half</span></div>
<div class="line"><a name="l03900"></a><span class="lineno"> 3900</span>&#160;    <span class="keywordflow">if</span> ( trsX &gt; ( <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( symStr-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a51d7b9d87d536ef0c48d820872bc9185">getXDimSize</a>() ) / 2.0 ) ) { trsX = trsX - <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( symStr-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a51d7b9d87d536ef0c48d820872bc9185">getXDimSize</a>() ); }</div>
<div class="line"><a name="l03901"></a><span class="lineno"> 3901</span>&#160;    <span class="keywordflow">if</span> ( trsY &gt; ( <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( symStr-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#ae477e3c0d7b866e6069d8603950afe51">getYDimSize</a>() ) / 2.0 ) ) { trsY = trsY - <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( symStr-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#ae477e3c0d7b866e6069d8603950afe51">getYDimSize</a>() ); }</div>
<div class="line"><a name="l03902"></a><span class="lineno"> 3902</span>&#160;    <span class="keywordflow">if</span> ( trsZ &gt; ( <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( symStr-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#af4d641d62864e4adf67c1365b0960970">getZDimSize</a>() ) / 2.0 ) ) { trsZ = trsZ - <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( symStr-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#af4d641d62864e4adf67c1365b0960970">getZDimSize</a>() ); }</div>
<div class="line"><a name="l03903"></a><span class="lineno"> 3903</span>&#160; </div>
<div class="line"><a name="l03904"></a><span class="lineno"> 3904</span>&#160;    <span class="comment">//================================================ Save line point</span></div>
<div class="line"><a name="l03905"></a><span class="lineno"> 3905</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a>         ( &amp;trsVec, trsX );</div>
<div class="line"><a name="l03906"></a><span class="lineno"> 3906</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a>         ( &amp;trsVec, trsY );</div>
<div class="line"><a name="l03907"></a><span class="lineno"> 3907</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a>         ( &amp;trsVec, trsZ );</div>
<div class="line"><a name="l03908"></a><span class="lineno"> 3908</span>&#160;    </div>
<div class="line"><a name="l03909"></a><span class="lineno"> 3909</span>&#160;    <span class="comment">//================================================ Release memory</span></div>
<div class="line"><a name="l03910"></a><span class="lineno"> 3910</span>&#160;    <span class="keyword">delete</span>[] rotMap;</div>
<div class="line"><a name="l03911"></a><span class="lineno"> 3911</span>&#160; </div>
<div class="line"><a name="l03912"></a><span class="lineno"> 3912</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l03913"></a><span class="lineno"> 3913</span>&#160;    <span class="keywordflow">return</span>                                            ( trsVec );</div>
<div class="line"><a name="l03914"></a><span class="lineno"> 3914</span>&#160;    </div>
<div class="line"><a name="l03915"></a><span class="lineno"> 3915</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad977c265833d6466598cceb406a085db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad977c265833d6466598cceb406a085db">&#9670;&nbsp;</a></span>isSymmetrySame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_symmetry::isSymmetrySame </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>simThres</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed *&#160;</td>
          <td class="paramname"><em>matchedPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if a very similar symmetry is not already saved. </p>
<p>This is a simple function comparing a single double array of 6 to a vector of these, returning whether the vector already contains a very similar entry to the rested one. If the new has better height, replacement will take place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>This is the variable where the tested array will be saved if passed. It is a vector of double[6] arrays with the following meaning: [0] = fold, [1] = x-axis, [2] = y-axis, [3] = z-axis, [4] = angle, [5] = average peak height. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sym</td><td>This is a double array of 6 which is to be compared to all the vector entries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">simThres</td><td>The threshold for dot product comparison similarity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matchedPos</td><td>Pointer to variable where the matched position (if any axis is matched) is saved, or -1 is written. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>Boolean value stating whether a similar entry has been found (true = it was, false = it was not). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00200">200</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;{</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;    proshade_double dotProduct                        = 0.0;</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;   *matchedPos                                        = -1;</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    </div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    <span class="comment">//================================================ Check</span></div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign symIt = 0; symIt &lt; static_cast&lt;proshade_unsign&gt; ( ret-&gt;size() ); symIt++ )</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    {</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;        <span class="comment">//============================================ Minor speed-up =&gt; only test for same folds</span></div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;        <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; lhs ( ret-&gt;at(symIt)[0] ), rhs ( sym[0] );</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;        <span class="keywordflow">if</span> ( lhs.AlmostEquals ( rhs ) )</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;        {</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;            <span class="comment">//======================================== Is axis the same?</span></div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;            dotProduct                                = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> ( &amp;ret-&gt;at(symIt)[1], &amp;ret-&gt;at(symIt)[2],</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;                                                                                                     &amp;ret-&gt;at(symIt)[3], &amp;sym[1], &amp;sym[2], &amp;sym[3] );</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;            <span class="keywordflow">if</span> ( ( ( 1.0 &gt; ( dotProduct - simThres ) ) &amp;&amp; ( 1.0 &lt; ( dotProduct + simThres ) ) ) || ( ( -1.0 &gt; ( dotProduct - simThres ) ) &amp;&amp; ( -1.0 &lt; ( dotProduct + simThres ) ) ) )</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;            {</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;                <span class="comment">//==================================== Matched. Save the index</span></div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;               *matchedPos                            = <span class="keyword">static_cast&lt;</span> proshade_signed <span class="keyword">&gt;</span> ( symIt );</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;                </div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;                <span class="comment">//==================================== Does the already saved have higher height?</span></div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;                <span class="keywordflow">if</span> ( ret-&gt;at(symIt)[5] &gt;= sym[5] ) { <span class="keywordflow">return</span> ( <span class="keyword">true</span> ); }</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;                </div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;                <span class="comment">//==================================== In this case, new is better than old - sort it out</span></div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;                ret-&gt;at(symIt)[1]                     = sym[1];</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;                ret-&gt;at(symIt)[2]                     = sym[2];</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;                ret-&gt;at(symIt)[3]                     = sym[3];</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;                ret-&gt;at(symIt)[5]                     = sym[5];</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;                <span class="keywordflow">return</span>                                ( <span class="keyword">true</span> );</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;            }</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;        }</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    }</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;    </div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;    <span class="comment">//================================================ Done - no matches found</span></div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    <span class="keywordflow">return</span>                                            ( <span class="keyword">false</span> );</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;    </div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a10af3702dc9022c3afcaf72b049779f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10af3702dc9022c3afcaf72b049779f3">&#9670;&nbsp;</a></span>isSymmetrySame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_symmetry::isSymmetrySame </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>simThres</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed *&#160;</td>
          <td class="paramname"><em>matchedPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>fscVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if a very similar symmetry is not already saved. </p>
<p>This is a simple function comparing a single double array of 6 to a vector of these, returning whether the vector already contains a very similar entry to the rested one. If the new has better height, replacement will take place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>This is the variable where the tested array will be saved if passed. It is a vector of double[6] arrays with the following meaning: [0] = fold, [1] = x-axis, [2] = y-axis, [3] = z-axis, [4] = angle, [5] = average peak height. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sym</td><td>This is a double array of 6 which is to be compared to all the vector entries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">simThres</td><td>The threshold for dot product comparison similarity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matchedPos</td><td>Pointer to variable where the matched position (if any axis is matched) is saved, or -1 is written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fscVal</td><td>Value to be used as FSC in case of a match. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>Boolean value stating whether a similar entry has been found (true = it was, false = it was not). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00251">251</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;{</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;    proshade_double dotProduct                        = 0.0;</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;   *matchedPos                                        = -1;</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;    </div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;    <span class="comment">//================================================ Check</span></div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign symIt = 0; symIt &lt; static_cast&lt;proshade_unsign&gt; ( ret-&gt;size() ); symIt++ )</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;    {</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;        <span class="comment">//============================================ Minor speed-up =&gt; only test for same folds</span></div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;        <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; lhs ( ret-&gt;at(symIt)[0] ), rhs ( sym[0] );</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;        <span class="keywordflow">if</span> ( lhs.AlmostEquals ( rhs ) )</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;        {</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;            <span class="comment">//======================================== Is axis the same?</span></div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;            dotProduct                                = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> ( &amp;ret-&gt;at(symIt)[1], &amp;ret-&gt;at(symIt)[2],</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;                                                                                                     &amp;ret-&gt;at(symIt)[3], &amp;sym[1], &amp;sym[2], &amp;sym[3] );</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;            <span class="keywordflow">if</span> ( ( ( 1.0 &gt; ( dotProduct - simThres ) ) &amp;&amp; ( 1.0 &lt; ( dotProduct + simThres ) ) ) || ( ( -1.0 &gt; ( dotProduct - simThres ) ) &amp;&amp; ( -1.0 &lt; ( dotProduct + simThres ) ) ) )</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;            {</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;                <span class="comment">//==================================== Matched. Save the index</span></div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;               *matchedPos                            = <span class="keyword">static_cast&lt;</span> proshade_signed <span class="keyword">&gt;</span> ( symIt );</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;                </div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;                <span class="comment">//==================================== Does the already saved have higher height?</span></div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;                <span class="keywordflow">if</span> ( ret-&gt;at(symIt)[5] &gt;= sym[5] ) { <span class="keywordflow">return</span> ( <span class="keyword">true</span> ); }</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;                </div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;                <span class="comment">//==================================== In this case, new is better than old - sort it out</span></div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;                ret-&gt;at(symIt)[1]                     = sym[1];</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;                ret-&gt;at(symIt)[2]                     = sym[2];</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;                ret-&gt;at(symIt)[3]                     = sym[3];</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;                ret-&gt;at(symIt)[5]                     = sym[5];</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;                ret-&gt;at(symIt)[6]                     = fscVal;</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;                <span class="keywordflow">return</span>                                ( <span class="keyword">true</span> );</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;            }</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;        }</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;    }</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;    </div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;    <span class="comment">//================================================ Done - no matches found</span></div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    <span class="keywordflow">return</span>                                            ( <span class="keyword">false</span> );</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;    </div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad44ed609e8a3d59674b2b2256aec41f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad44ed609e8a3d59674b2b2256aec41f8">&#9670;&nbsp;</a></span>missingAxisHeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">proshade_double ProSHADE_internal_symmetry::missingAxisHeight </td>
          <td>(</td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>xVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>yVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>zVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function searches for the highest peaks average that would produce the required axis and fold. </p>
<p>This function starts by finding all self-rotation map points with corresponding axis and recording the angle and map heights of these points. It then sorts these and searches for a combination of fold points separated by the 2pi/fold distance with the highest average map height. In this way, the highest average symmetry height is determined for any axis. This does not, however, check if such symmetry does indeed exist!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xVal</td><td>The x-axis element of the axis to have the height detected. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yVal</td><td>The y-axis element of the axis to have the height detected. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zVal</td><td>The z-axis element of the axis to have the height detected. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataObj</td><td>The full data holding object pointer - this is to get access to self-rotation function values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fold</td><td>The fold of the searched for axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>The highest height value found for the axis with the given fold. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00757">757</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;{</div>
<div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;    proshade_double ret                               = 0.0;</div>
<div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;    proshade_double curSum                            = 0.0;</div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;    proshade_double maxVal                            = 0.0;</div>
<div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;    proshade_double angStep                           = std::acos ( 1.0 - axErr ) / 2;</div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;    std::vector&lt; proshade_double* &gt; angVec;</div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;    </div>
<div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;    <span class="comment">//================================================ Find map points conforming to the axis</span></div>
<div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;    angVec                                            = <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a465606e58df7d6a2238d40c6919b2e58">ProSHADE_internal_symmetry::findMissingAxisPoints</a> ( xVal, yVal, zVal, dataObj, axErr );</div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;    </div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;    <span class="comment">//================================================ Sort points by angle</span></div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;    std::sort                                         ( angVec.begin(), angVec.end(), <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a68d576f90449b7d3fcf5ae4d3114c268">ProSHADE_internal_symmetry::sortArrVecHlp</a> );</div>
<div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;    </div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;    <span class="comment">//================================================ Find the best X peaks with correct distances</span></div>
<div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; static_cast&lt;proshade_unsign&gt; ( std::floor ( ( 2.0 * M_PI / angStep ) / <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( fold ) ) ); iter++ )</div>
<div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;    {</div>
<div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;        <span class="comment">//============================================ Initialise new ang group iteration</span></div>
<div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;        curSum                                        = 0.0;</div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;        </div>
<div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;        <span class="comment">//============================================ For each of the fold times</span></div>
<div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign angCmb = 0; angCmb &lt; static_cast&lt;proshade_unsign&gt; ( fold ); angCmb++ )</div>
<div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;        {</div>
<div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;            <span class="comment">//======================================== Initialise</span></div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;            maxVal                                    = 0.0;</div>
<div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;            </div>
<div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;            <span class="comment">//======================================== Search</span></div>
<div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;            <span class="keywordflow">for</span> ( proshade_unsign angIt = 0; angIt &lt; static_cast&lt;proshade_unsign&gt; ( angVec.size() ); angIt++ )</div>
<div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;            {</div>
<div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;                <span class="keywordflow">if</span> ( angVec.at(angIt)[0] &lt; ( ( <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( iter ) * angStep ) +</div>
<div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;                                             ( ( 2.0 * M_PI / <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( fold ) ) * <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( angCmb ) ) ) ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;                <span class="keywordflow">if</span> ( angVec.at(angIt)[0] &gt; ( ( ( <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( iter ) + 1.0 ) * angStep ) +</div>
<div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;                                             ( ( 2.0 * M_PI / <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( fold ) ) * <span class="keyword">static_cast&lt;</span> proshade_double <span class="keyword">&gt;</span> ( angCmb ) ) ) ) { <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160; </div>
<div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;                <span class="keywordflow">if</span> ( angVec.at(angIt)[1] &gt; maxVal ) { maxVal = angVec.at(angIt)[1]; }</div>
<div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;            }</div>
<div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;            curSum                                   += maxVal;</div>
<div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;        }</div>
<div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;        curSum                                      /= <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( fold );</div>
<div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;        <span class="keywordflow">if</span> ( ret &lt; curSum ) { ret = curSum; }</div>
<div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;    }</div>
<div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;    </div>
<div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;    <span class="comment">//================================================ Release memory</span></div>
<div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; static_cast&lt;proshade_unsign&gt; ( angVec.size() ); iter++ ) { <span class="keyword">delete</span>[] angVec.at(iter); }</div>
<div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;    </div>
<div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;    <span class="keywordflow">return</span>                                            ( ret );</div>
<div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;    </div>
<div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae4e9966655e7cfbf988ef38d4653bd69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e9966655e7cfbf988ef38d4653bd69">&#9670;&nbsp;</a></span>optimiseDGroupAngleFromAxesHeights() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::optimiseDGroupAngleFromAxesHeights </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; proshade_double &gt; &gt; *&#160;</td>
          <td class="paramname"><em>allCs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt;&#160;</td>
          <td class="paramname"><em>selection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__settings.html">ProSHADE_settings</a> *&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes two axes with almost dihedral angle and optimises their relative positions as well as orientation with respect to the optimal angle and the rotation function. </p>
<p>This function is basically a wrapper to the overloaded function with the same name. It starts with converting the axes list and index vector to a single vactor containing the axes in the correct format and then it proceeds to call the overloaded version of this function to do the actual work. Once it completes, this function saves the results into the original input vector and terminates itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allCs</td><td>The list of axes for a subset of which the optimisation is to be done. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">selection</td><td>A vector of two indices (of the allCs vector) specifying which axes to optimise. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataObj</td><td>The structure object with computed rotation function in which the peaks are to be found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">settings</td><td><a class="el" href="class_pro_s_h_a_d_e__settings.html" title="This class stores all the settings and is passed to the executive classes instead of a multitude of p...">ProSHADE_settings</a> object containing all the settings for this run. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l03324">3324</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03325"></a><span class="lineno"> 3325</span>&#160;{</div>
<div class="line"><a name="l03326"></a><span class="lineno"> 3326</span>&#160;    <span class="comment">//================================================ Initialise local variables</span></div>
<div class="line"><a name="l03327"></a><span class="lineno"> 3327</span>&#160;    std::vector &lt; std::vector&lt; proshade_double &gt; &gt; ortPair;</div>
<div class="line"><a name="l03328"></a><span class="lineno"> 3328</span>&#160;    std::vector&lt; proshade_double &gt; hlpVec;</div>
<div class="line"><a name="l03329"></a><span class="lineno"> 3329</span>&#160;    </div>
<div class="line"><a name="l03330"></a><span class="lineno"> 3330</span>&#160;    <span class="comment">//================================================ Convert the indices and the list into a single vector containing only the axes to be optimised.</span></div>
<div class="line"><a name="l03331"></a><span class="lineno"> 3331</span>&#160;    hlpVec.push_back ( allCs-&gt;at(selection.at(0))[0] ); hlpVec.push_back ( allCs-&gt;at(selection.at(0))[1] ); hlpVec.push_back ( allCs-&gt;at(selection.at(0))[2] );</div>
<div class="line"><a name="l03332"></a><span class="lineno"> 3332</span>&#160;    hlpVec.push_back ( allCs-&gt;at(selection.at(0))[3] ); hlpVec.push_back ( allCs-&gt;at(selection.at(0))[4] ); hlpVec.push_back ( allCs-&gt;at(selection.at(0))[5] );</div>
<div class="line"><a name="l03333"></a><span class="lineno"> 3333</span>&#160;    hlpVec.push_back ( allCs-&gt;at(selection.at(0))[6] );</div>
<div class="line"><a name="l03334"></a><span class="lineno"> 3334</span>&#160;    ortPair.push_back ( hlpVec ); hlpVec.clear ( );</div>
<div class="line"><a name="l03335"></a><span class="lineno"> 3335</span>&#160;    hlpVec.push_back ( allCs-&gt;at(selection.at(1))[0] ); hlpVec.push_back ( allCs-&gt;at(selection.at(1))[1] ); hlpVec.push_back ( allCs-&gt;at(selection.at(1))[2] );</div>
<div class="line"><a name="l03336"></a><span class="lineno"> 3336</span>&#160;    hlpVec.push_back ( allCs-&gt;at(selection.at(1))[3] ); hlpVec.push_back ( allCs-&gt;at(selection.at(1))[4] ); hlpVec.push_back ( allCs-&gt;at(selection.at(1))[5] );</div>
<div class="line"><a name="l03337"></a><span class="lineno"> 3337</span>&#160;    hlpVec.push_back ( allCs-&gt;at(selection.at(1))[6] );</div>
<div class="line"><a name="l03338"></a><span class="lineno"> 3338</span>&#160;    ortPair.push_back ( hlpVec );</div>
<div class="line"><a name="l03339"></a><span class="lineno"> 3339</span>&#160;    </div>
<div class="line"><a name="l03340"></a><span class="lineno"> 3340</span>&#160;    <span class="comment">//================================================ Run the optimisation proper</span></div>
<div class="line"><a name="l03341"></a><span class="lineno"> 3341</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a8b39de1c901703986cb476d8cb8cf9dc">optimiseDGroupAngleFromAxesHeights</a>                ( &amp;ortPair, dataObj, settings );</div>
<div class="line"><a name="l03342"></a><span class="lineno"> 3342</span>&#160;    </div>
<div class="line"><a name="l03343"></a><span class="lineno"> 3343</span>&#160;    <span class="comment">//================================================ Save the results back to the vector</span></div>
<div class="line"><a name="l03344"></a><span class="lineno"> 3344</span>&#160;    allCs-&gt;at(selection.at(0))[1] = ortPair.at(0).at(1); allCs-&gt;at(selection.at(0))[2] = ortPair.at(0).at(2); allCs-&gt;at(selection.at(0))[3] = ortPair.at(0).at(3);</div>
<div class="line"><a name="l03345"></a><span class="lineno"> 3345</span>&#160;    allCs-&gt;at(selection.at(0))[5] = ortPair.at(0).at(5); allCs-&gt;at(selection.at(0))[6] = ortPair.at(0).at(6);</div>
<div class="line"><a name="l03346"></a><span class="lineno"> 3346</span>&#160;    </div>
<div class="line"><a name="l03347"></a><span class="lineno"> 3347</span>&#160;    allCs-&gt;at(selection.at(1))[1] = ortPair.at(1).at(1); allCs-&gt;at(selection.at(1))[2] = ortPair.at(1).at(2); allCs-&gt;at(selection.at(1))[3] = ortPair.at(1).at(3);</div>
<div class="line"><a name="l03348"></a><span class="lineno"> 3348</span>&#160;    allCs-&gt;at(selection.at(1))[5] = ortPair.at(1).at(5); allCs-&gt;at(selection.at(1))[6] = ortPair.at(1).at(6);</div>
<div class="line"><a name="l03349"></a><span class="lineno"> 3349</span>&#160;    </div>
<div class="line"><a name="l03350"></a><span class="lineno"> 3350</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l03351"></a><span class="lineno"> 3351</span>&#160;    return ;</div>
<div class="line"><a name="l03352"></a><span class="lineno"> 3352</span>&#160;    </div>
<div class="line"><a name="l03353"></a><span class="lineno"> 3353</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8b39de1c901703986cb476d8cb8cf9dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b39de1c901703986cb476d8cb8cf9dc">&#9670;&nbsp;</a></span>optimiseDGroupAngleFromAxesHeights() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::optimiseDGroupAngleFromAxesHeights </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; proshade_double &gt; &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__settings.html">ProSHADE_settings</a> *&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes two axes with almost dihedral angle and optimises their relative positions as well as orientation with respect to the optimal angle and the rotation function. </p>
<p>This function has two parts. Firstly, it makes the assumption that the two axes supplied are almost perpendicular, but that there may be an error. To correct for this, the function will find the vector perpendicular to the plane formed by the two supplied axes and then it will find a vector perpendicular to the plane between this new vector and the axis with higher rotation function value. The resulting new vector is perpendicular to the axis with higher rotation function value and replaces the axis vector with the lower rotation function values (after normalisation).</p>
<p>Secondly, this function supplies the two axes to the <a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a33c650c19a6954800bba6b3a8f5842e6" title="This function finds the rotation function value for all axes supplied in the ret parameter.">findPredictedAxesHeights()</a> function, which does the maximisation of the rotation function values for both supplied axes at the same time. The resulting optimised axes are then returned in place of the inputted axes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>The list of axes for which the optimisation is to be done. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataObj</td><td>The structure object with computed rotation function in which the peaks are to be found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">settings</td><td><a class="el" href="class_pro_s_h_a_d_e__settings.html" title="This class stores all the settings and is passed to the executive classes instead of a multitude of p...">ProSHADE_settings</a> object containing all the settings for this run. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l03227">3227</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03228"></a><span class="lineno"> 3228</span>&#160;{</div>
<div class="line"><a name="l03229"></a><span class="lineno"> 3229</span>&#160;    <span class="comment">//================================================ Sanity check</span></div>
<div class="line"><a name="l03230"></a><span class="lineno"> 3230</span>&#160;    <span class="keywordflow">if</span> ( ret-&gt;size() != 2 )</div>
<div class="line"><a name="l03231"></a><span class="lineno"> 3231</span>&#160;    {</div>
<div class="line"><a name="l03232"></a><span class="lineno"> 3232</span>&#160;        <span class="keywordflow">throw</span> <a class="code" href="class_pro_s_h_a_d_e__exception.html">ProSHADE_exception</a> ( <span class="stringliteral">&quot;Attempted to optimise less than two axes for dihedral\n                    : group.&quot;</span>, <span class="stringliteral">&quot;ES00070&quot;</span>, __FILE__, __LINE__, __func__, <span class="stringliteral">&quot;The function for optimisation of dihedral angle of D\n                    : group was called on group with less than two axes. This\n                    : seems like a programming bug and should not happen - \n                    : contact author if you ever see this.&quot;</span> );</div>
<div class="line"><a name="l03233"></a><span class="lineno"> 3233</span>&#160;    }</div>
<div class="line"><a name="l03234"></a><span class="lineno"> 3234</span>&#160;    </div>
<div class="line"><a name="l03235"></a><span class="lineno"> 3235</span>&#160;    <span class="comment">//================================================ Set the angle to the correct dihedral group position - i.e. 90 deg</span></div>
<div class="line"><a name="l03236"></a><span class="lineno"> 3236</span>&#160;    proshade_double *crossProd, *perpVec, normFactor;</div>
<div class="line"><a name="l03237"></a><span class="lineno"> 3237</span>&#160;    <span class="keywordtype">size_t</span> higherRFIndex                              = 0;</div>
<div class="line"><a name="l03238"></a><span class="lineno"> 3238</span>&#160;    </div>
<div class="line"><a name="l03239"></a><span class="lineno"> 3239</span>&#160;    <span class="comment">// ... Find vector perperndicular to the plane given by the two axes</span></div>
<div class="line"><a name="l03240"></a><span class="lineno"> 3240</span>&#160;    crossProd                                         = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a61807efeb86ea021f3d17ac531911c3c">ProSHADE_internal_maths::computeCrossProduct</a> ( &amp;ret-&gt;at(0).at(1), &amp;ret-&gt;at(0).at(2), &amp;ret-&gt;at(0).at(3), &amp;ret-&gt;at(1).at(1), &amp;ret-&gt;at(1).at(2), &amp;ret-&gt;at(1).at(3) );</div>
<div class="line"><a name="l03241"></a><span class="lineno"> 3241</span>&#160;    </div>
<div class="line"><a name="l03242"></a><span class="lineno"> 3242</span>&#160;    <span class="comment">// ... Find a vector perpendicular to the plane between the new vector and the vector with higher rotation function value</span></div>
<div class="line"><a name="l03243"></a><span class="lineno"> 3243</span>&#160;    <span class="keywordflow">if</span> ( ret-&gt;at(1).at(5) &gt; ret-&gt;at(0).at(5) ) { higherRFIndex = 1; }</div>
<div class="line"><a name="l03244"></a><span class="lineno"> 3244</span>&#160;    perpVec                                           = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a61807efeb86ea021f3d17ac531911c3c">ProSHADE_internal_maths::computeCrossProduct</a> ( &amp;ret-&gt;at(higherRFIndex).at(1), &amp;ret-&gt;at(higherRFIndex).at(2), &amp;ret-&gt;at(higherRFIndex).at(3), &amp;crossProd[0], &amp;crossProd[1], &amp;crossProd[2] );</div>
<div class="line"><a name="l03245"></a><span class="lineno"> 3245</span>&#160;    </div>
<div class="line"><a name="l03246"></a><span class="lineno"> 3246</span>&#160;    <span class="comment">// ... Normalise the new vector</span></div>
<div class="line"><a name="l03247"></a><span class="lineno"> 3247</span>&#160;    normFactor                                        = std::sqrt ( pow ( perpVec[0], 2.0 ) + pow ( perpVec[1], 2.0 ) + pow ( perpVec[2], 2.0 ) );</div>
<div class="line"><a name="l03248"></a><span class="lineno"> 3248</span>&#160;    perpVec[0] /= normFactor; perpVec[1] /= normFactor; perpVec[2] /= normFactor;</div>
<div class="line"><a name="l03249"></a><span class="lineno"> 3249</span>&#160;    </div>
<div class="line"><a name="l03250"></a><span class="lineno"> 3250</span>&#160;    <span class="comment">// ... Which vector are we to over-write?</span></div>
<div class="line"><a name="l03251"></a><span class="lineno"> 3251</span>&#160;    <span class="keywordflow">if</span> ( higherRFIndex == 0 ) { higherRFIndex = 1; }</div>
<div class="line"><a name="l03252"></a><span class="lineno"> 3252</span>&#160;    <span class="keywordflow">else</span>                      { higherRFIndex = 0; }</div>
<div class="line"><a name="l03253"></a><span class="lineno"> 3253</span>&#160;    </div>
<div class="line"><a name="l03254"></a><span class="lineno"> 3254</span>&#160;    <span class="comment">// ... Set largest axis element to positive</span></div>
<div class="line"><a name="l03255"></a><span class="lineno"> 3255</span>&#160;    <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; lhs1 ( std::max ( std::abs ( perpVec[0] ), std::max( std::abs ( perpVec[1] ), std::abs ( perpVec[2] ) ) ) );</div>
<div class="line"><a name="l03256"></a><span class="lineno"> 3256</span>&#160;    <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; rhs1 ( std::abs ( perpVec[0] ));</div>
<div class="line"><a name="l03257"></a><span class="lineno"> 3257</span>&#160;    <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; rhs2 ( std::abs ( perpVec[1] ) );</div>
<div class="line"><a name="l03258"></a><span class="lineno"> 3258</span>&#160;    <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; rhs3 ( std::abs ( perpVec[2] ) );</div>
<div class="line"><a name="l03259"></a><span class="lineno"> 3259</span>&#160;    <span class="keywordflow">if</span> ( ( lhs1.AlmostEquals ( rhs1 ) &amp;&amp; ( perpVec[0] &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l03260"></a><span class="lineno"> 3260</span>&#160;         ( lhs1.AlmostEquals ( rhs2 ) &amp;&amp; ( perpVec[1] &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l03261"></a><span class="lineno"> 3261</span>&#160;         ( lhs1.AlmostEquals ( rhs3 ) &amp;&amp; ( perpVec[2] &lt; 0.0 ) ) )</div>
<div class="line"><a name="l03262"></a><span class="lineno"> 3262</span>&#160;    {</div>
<div class="line"><a name="l03263"></a><span class="lineno"> 3263</span>&#160;        perpVec[0]                                   *= -1.0;</div>
<div class="line"><a name="l03264"></a><span class="lineno"> 3264</span>&#160;        perpVec[1]                                   *= -1.0;</div>
<div class="line"><a name="l03265"></a><span class="lineno"> 3265</span>&#160;        perpVec[2]                                   *= -1.0;</div>
<div class="line"><a name="l03266"></a><span class="lineno"> 3266</span>&#160;    }</div>
<div class="line"><a name="l03267"></a><span class="lineno"> 3267</span>&#160;    </div>
<div class="line"><a name="l03268"></a><span class="lineno"> 3268</span>&#160;    <span class="comment">// ... Over-write the old vector with the better one</span></div>
<div class="line"><a name="l03269"></a><span class="lineno"> 3269</span>&#160;    ret-&gt;at(higherRFIndex).at(1) = perpVec[0]; ret-&gt;at(higherRFIndex).at(2) = perpVec[1]; ret-&gt;at(higherRFIndex).at(3) = perpVec[2];</div>
<div class="line"><a name="l03270"></a><span class="lineno"> 3270</span>&#160;    </div>
<div class="line"><a name="l03271"></a><span class="lineno"> 3271</span>&#160;    <span class="comment">// ... Release memory</span></div>
<div class="line"><a name="l03272"></a><span class="lineno"> 3272</span>&#160;    <span class="keyword">delete</span>[] perpVec;</div>
<div class="line"><a name="l03273"></a><span class="lineno"> 3273</span>&#160;    <span class="keyword">delete</span>[] crossProd;</div>
<div class="line"><a name="l03274"></a><span class="lineno"> 3274</span>&#160;    </div>
<div class="line"><a name="l03275"></a><span class="lineno"> 3275</span>&#160;    <span class="comment">//================================================ Convert input to pointers</span></div>
<div class="line"><a name="l03276"></a><span class="lineno"> 3276</span>&#160;    std::vector&lt; proshade_double* &gt; convVec;</div>
<div class="line"><a name="l03277"></a><span class="lineno"> 3277</span>&#160;    <span class="keywordflow">for</span> ( <span class="keywordtype">size_t</span> axIt = 0; axIt &lt; 2; axIt++ )</div>
<div class="line"><a name="l03278"></a><span class="lineno"> 3278</span>&#160;    {</div>
<div class="line"><a name="l03279"></a><span class="lineno"> 3279</span>&#160;        <span class="comment">//============================================ Allocate memory</span></div>
<div class="line"><a name="l03280"></a><span class="lineno"> 3280</span>&#160;        proshade_double* axVals                       = <span class="keyword">new</span> proshade_double[7];</div>
<div class="line"><a name="l03281"></a><span class="lineno"> 3281</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a> ( axVals, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l03282"></a><span class="lineno"> 3282</span>&#160;        </div>
<div class="line"><a name="l03283"></a><span class="lineno"> 3283</span>&#160;        <span class="comment">//============================================ Copy values</span></div>
<div class="line"><a name="l03284"></a><span class="lineno"> 3284</span>&#160;        <span class="keywordflow">for</span> ( <span class="keywordtype">size_t</span> elIt = 0; elIt &lt; 7; elIt++ )</div>
<div class="line"><a name="l03285"></a><span class="lineno"> 3285</span>&#160;        {</div>
<div class="line"><a name="l03286"></a><span class="lineno"> 3286</span>&#160;            axVals[elIt]                              = ret-&gt;at(axIt).at(elIt);</div>
<div class="line"><a name="l03287"></a><span class="lineno"> 3287</span>&#160;        }</div>
<div class="line"><a name="l03288"></a><span class="lineno"> 3288</span>&#160;        </div>
<div class="line"><a name="l03289"></a><span class="lineno"> 3289</span>&#160;        <span class="comment">//============================================ Save</span></div>
<div class="line"><a name="l03290"></a><span class="lineno"> 3290</span>&#160;        convVec.push_back                             ( axVals );</div>
<div class="line"><a name="l03291"></a><span class="lineno"> 3291</span>&#160;    }</div>
<div class="line"><a name="l03292"></a><span class="lineno"> 3292</span>&#160;    </div>
<div class="line"><a name="l03293"></a><span class="lineno"> 3293</span>&#160;    <span class="comment">//================================================ Run normal optimisation</span></div>
<div class="line"><a name="l03294"></a><span class="lineno"> 3294</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a33c650c19a6954800bba6b3a8f5842e6">ProSHADE_internal_symmetry::findPredictedAxesHeights</a> ( &amp;convVec, dataObj, settings );</div>
<div class="line"><a name="l03295"></a><span class="lineno"> 3295</span>&#160;    </div>
<div class="line"><a name="l03296"></a><span class="lineno"> 3296</span>&#160;    <span class="comment">//================================================ Convert back and release memory</span></div>
<div class="line"><a name="l03297"></a><span class="lineno"> 3297</span>&#160;    <span class="keywordflow">for</span> ( <span class="keywordtype">size_t</span> axIt = 0; axIt &lt; 2; axIt++ )</div>
<div class="line"><a name="l03298"></a><span class="lineno"> 3298</span>&#160;    {</div>
<div class="line"><a name="l03299"></a><span class="lineno"> 3299</span>&#160;        <span class="comment">//============================================ Copy values</span></div>
<div class="line"><a name="l03300"></a><span class="lineno"> 3300</span>&#160;        <span class="keywordflow">for</span> ( <span class="keywordtype">size_t</span> elIt = 0; elIt &lt; 7; elIt++ )</div>
<div class="line"><a name="l03301"></a><span class="lineno"> 3301</span>&#160;        {</div>
<div class="line"><a name="l03302"></a><span class="lineno"> 3302</span>&#160;            ret-&gt;at(axIt).at(elIt)                     = convVec.at(axIt)[elIt];</div>
<div class="line"><a name="l03303"></a><span class="lineno"> 3303</span>&#160;        }</div>
<div class="line"><a name="l03304"></a><span class="lineno"> 3304</span>&#160;        </div>
<div class="line"><a name="l03305"></a><span class="lineno"> 3305</span>&#160;        <span class="comment">//============================================ Release memory</span></div>
<div class="line"><a name="l03306"></a><span class="lineno"> 3306</span>&#160;        <span class="keyword">delete</span>[] convVec.at(axIt);</div>
<div class="line"><a name="l03307"></a><span class="lineno"> 3307</span>&#160;    }</div>
<div class="line"><a name="l03308"></a><span class="lineno"> 3308</span>&#160;    </div>
<div class="line"><a name="l03309"></a><span class="lineno"> 3309</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l03310"></a><span class="lineno"> 3310</span>&#160;    return ;</div>
<div class="line"><a name="l03311"></a><span class="lineno"> 3311</span>&#160;    </div>
<div class="line"><a name="l03312"></a><span class="lineno"> 3312</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a16d3cf24f73eafc1d5b8ef9e204aaf8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d3cf24f73eafc1d5b8ef9e204aaf8d">&#9670;&nbsp;</a></span>predictIcosAxes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::predictIcosAxes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; proshade_double * &gt; &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function predicts all possible icosahedral point groups symmetry axes from the cyclic point groups list. </p>
<p>This function starts by finding the rotation matrix corresponding to the angle between the predicted C5 axis and the C5 axis found in the pre-computed Icosahedron model available in the ProSHADE_precomputedValues file. It then proceeds to use this rotation matrix to rotate the pre-computed model C3 axis to now be in the correct orientation to the detected C5 axis.</p>
<p>Next, the function computes the rotation matrix corresponding to rotation along the detected C5 axis about the angle between the rotated pre-computed model C3 axis and the detected C3 axis. Finally, when these two rotation matrices are combined, the resulting rotation matrix is the optimal match rotation between the pre-computed model and the detected axes positions. This final rotation matrix is then used to rotate the model axes and these rotated model axes are then the predicted axes in the structre.</p>
<p>Please note that the peak heights are set to 0.0 for all predicted axes, as they were not detected in the structure, but were only predicted.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function assumes that the <a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a4f09b90de1f15b345ee7998ff31327f3" title="This function takes the list of C symmetries and decides whether basic requirements for isosahedral s...">detectIcosahedralSymmetry()</a> function has successfully run (i.e. returned true).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>The vector containing all the axes forming icosahedral group or empty vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum average peak height for axis to be considered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l02154">2154</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02155"></a><span class="lineno"> 2155</span>&#160;{</div>
<div class="line"><a name="l02156"></a><span class="lineno"> 2156</span>&#160;    <span class="comment">//================================================ Find the best axis combination with dihedral angle and correct folds</span></div>
<div class="line"><a name="l02157"></a><span class="lineno"> 2157</span>&#160;    std::vector &lt; std::pair&lt; proshade_unsign, proshade_unsign &gt; &gt; initAxes = <a class="code" href="_pro_s_h_a_d_e__symmetry_8cpp.html#a16b3a0c170d01be9b4fad682f90025a5">findBestIcosDihedralPair</a> ( CSymList, minPeakHeight, axErr );</div>
<div class="line"><a name="l02158"></a><span class="lineno"> 2158</span>&#160;    </div>
<div class="line"><a name="l02159"></a><span class="lineno"> 2159</span>&#160;    <span class="comment">//================================================ For each pair of possible axis combinations</span></div>
<div class="line"><a name="l02160"></a><span class="lineno"> 2160</span>&#160;    <span class="keywordflow">for</span> ( <span class="keywordtype">size_t</span> pIt = 0; pIt &lt; initAxes.size(); pIt++ )</div>
<div class="line"><a name="l02161"></a><span class="lineno"> 2161</span>&#160;    {</div>
<div class="line"><a name="l02162"></a><span class="lineno"> 2162</span>&#160;        <span class="comment">//============================================ Create the tetrahedronAxes object</span></div>
<div class="line"><a name="l02163"></a><span class="lineno"> 2163</span>&#160;        <a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1icosahedron_axes.html">ProSHADE_internal_precomputedVals::icosahedronAxes</a> *icoAx = <span class="keyword">new</span> <a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1icosahedron_axes.html">ProSHADE_internal_precomputedVals::icosahedronAxes</a> ( );</div>
<div class="line"><a name="l02164"></a><span class="lineno"> 2164</span>&#160;        </div>
<div class="line"><a name="l02165"></a><span class="lineno"> 2165</span>&#160;        <span class="comment">//============================================ Find rotation between the detected C5 and the model C5 axes.</span></div>
<div class="line"><a name="l02166"></a><span class="lineno"> 2166</span>&#160;        proshade_double* rotMat                       = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2b17617f8b3c42c5199948828cd1a57b">ProSHADE_internal_maths::findRotMatMatchingVectors</a> ( icoAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1icosahedron_axes.html#aeec201a53ee1f3aeaf69cc956b43bb30">getValue</a> ( 0, 1 ),</div>
<div class="line"><a name="l02167"></a><span class="lineno"> 2167</span>&#160;                                                                                                             icoAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1icosahedron_axes.html#aeec201a53ee1f3aeaf69cc956b43bb30">getValue</a> ( 0, 2 ),</div>
<div class="line"><a name="l02168"></a><span class="lineno"> 2168</span>&#160;                                                                                                             icoAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1icosahedron_axes.html#aeec201a53ee1f3aeaf69cc956b43bb30">getValue</a> ( 0, 3 ),</div>
<div class="line"><a name="l02169"></a><span class="lineno"> 2169</span>&#160;                                                                                                             CSymList-&gt;at(initAxes.at(pIt).first)[1],</div>
<div class="line"><a name="l02170"></a><span class="lineno"> 2170</span>&#160;                                                                                                             CSymList-&gt;at(initAxes.at(pIt).first)[2],</div>
<div class="line"><a name="l02171"></a><span class="lineno"> 2171</span>&#160;                                                                                                             CSymList-&gt;at(initAxes.at(pIt).first)[3] );</div>
<div class="line"><a name="l02172"></a><span class="lineno"> 2172</span>&#160;        </div>
<div class="line"><a name="l02173"></a><span class="lineno"> 2173</span>&#160;        <span class="comment">//============================================ Rotate the model C3 to the correct orientation relative to the detected C5 axis.</span></div>
<div class="line"><a name="l02174"></a><span class="lineno"> 2174</span>&#160;        proshade_double* rotModelC3                   = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2f9c7716f6ab682e8548ab77efcdc444">ProSHADE_internal_maths::compute3x3MatrixVectorMultiplication</a> ( rotMat,</div>
<div class="line"><a name="l02175"></a><span class="lineno"> 2175</span>&#160;                                                                                                                        icoAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1icosahedron_axes.html#aeec201a53ee1f3aeaf69cc956b43bb30">getValue</a> ( 6, 1 ),</div>
<div class="line"><a name="l02176"></a><span class="lineno"> 2176</span>&#160;                                                                                                                        icoAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1icosahedron_axes.html#aeec201a53ee1f3aeaf69cc956b43bb30">getValue</a> ( 6, 2 ),</div>
<div class="line"><a name="l02177"></a><span class="lineno"> 2177</span>&#160;                                                                                                                        icoAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1icosahedron_axes.html#aeec201a53ee1f3aeaf69cc956b43bb30">getValue</a> ( 6, 3 ) );</div>
<div class="line"><a name="l02178"></a><span class="lineno"> 2178</span>&#160;        </div>
<div class="line"><a name="l02179"></a><span class="lineno"> 2179</span>&#160;        <span class="comment">//============================================ Find the angle betwen the rotated model C3 and the detected C3 axes along the detected C5 axis.</span></div>
<div class="line"><a name="l02180"></a><span class="lineno"> 2180</span>&#160;        proshade_double bestAng = 0.0, curAngDist, bestAngDist = 999.9;</div>
<div class="line"><a name="l02181"></a><span class="lineno"> 2181</span>&#160;        proshade_double* rotMatHlp                    = <span class="keyword">new</span> proshade_double[9];</div>
<div class="line"><a name="l02182"></a><span class="lineno"> 2182</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a> ( rotMatHlp, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l02183"></a><span class="lineno"> 2183</span>&#160;        <span class="keywordflow">for</span> ( proshade_double ang = 0.0; ang &lt; ( M_PI * 2.0 ); ang += 0.002 )</div>
<div class="line"><a name="l02184"></a><span class="lineno"> 2184</span>&#160;        {</div>
<div class="line"><a name="l02185"></a><span class="lineno"> 2185</span>&#160;            <span class="comment">//============================================ Compute rotation matrix for this angle value</span></div>
<div class="line"><a name="l02186"></a><span class="lineno"> 2186</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a39eafef902a49cc0816a2ed675c14a49">ProSHADE_internal_maths::getRotationMatrixFromAngleAxis</a> ( rotMatHlp, CSymList-&gt;at(initAxes.at(pIt).first)[1], CSymList-&gt;at(initAxes.at(pIt).first)[2], CSymList-&gt;at(initAxes.at(pIt).first)[3], ang );</div>
<div class="line"><a name="l02187"></a><span class="lineno"> 2187</span>&#160; </div>
<div class="line"><a name="l02188"></a><span class="lineno"> 2188</span>&#160;            <span class="comment">//======================================== Rotate the rotated C2 by the matrix</span></div>
<div class="line"><a name="l02189"></a><span class="lineno"> 2189</span>&#160;            proshade_double* rotRotModelC3            = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2f9c7716f6ab682e8548ab77efcdc444">ProSHADE_internal_maths::compute3x3MatrixVectorMultiplication</a> ( rotMatHlp,</div>
<div class="line"><a name="l02190"></a><span class="lineno"> 2190</span>&#160;                                                                                                                        rotModelC3[0],</div>
<div class="line"><a name="l02191"></a><span class="lineno"> 2191</span>&#160;                                                                                                                        rotModelC3[1],</div>
<div class="line"><a name="l02192"></a><span class="lineno"> 2192</span>&#160;                                                                                                                        rotModelC3[2] );</div>
<div class="line"><a name="l02193"></a><span class="lineno"> 2193</span>&#160; </div>
<div class="line"><a name="l02194"></a><span class="lineno"> 2194</span>&#160;            <span class="comment">//======================================== Find distance</span></div>
<div class="line"><a name="l02195"></a><span class="lineno"> 2195</span>&#160;            curAngDist                                = std::sqrt ( std::pow ( rotRotModelC3[0] - CSymList-&gt;at(initAxes.at(pIt).second)[1], 2.0 ) +</div>
<div class="line"><a name="l02196"></a><span class="lineno"> 2196</span>&#160;                                                                    std::pow ( rotRotModelC3[1] - CSymList-&gt;at(initAxes.at(pIt).second)[2], 2.0 ) +</div>
<div class="line"><a name="l02197"></a><span class="lineno"> 2197</span>&#160;                                                                    std::pow ( rotRotModelC3[2] - CSymList-&gt;at(initAxes.at(pIt).second)[3], 2.0 ) );</div>
<div class="line"><a name="l02198"></a><span class="lineno"> 2198</span>&#160; </div>
<div class="line"><a name="l02199"></a><span class="lineno"> 2199</span>&#160;            <span class="comment">//======================================== Save best angle</span></div>
<div class="line"><a name="l02200"></a><span class="lineno"> 2200</span>&#160;            <span class="keywordflow">if</span> ( curAngDist &lt; bestAngDist ) { bestAngDist = curAngDist; bestAng = ang; }</div>
<div class="line"><a name="l02201"></a><span class="lineno"> 2201</span>&#160; </div>
<div class="line"><a name="l02202"></a><span class="lineno"> 2202</span>&#160;            <span class="comment">//======================================== Release memory</span></div>
<div class="line"><a name="l02203"></a><span class="lineno"> 2203</span>&#160;            <span class="keyword">delete</span>[] rotRotModelC3;</div>
<div class="line"><a name="l02204"></a><span class="lineno"> 2204</span>&#160;        }</div>
<div class="line"><a name="l02205"></a><span class="lineno"> 2205</span>&#160;        </div>
<div class="line"><a name="l02206"></a><span class="lineno"> 2206</span>&#160;        <span class="comment">//============================================ Release memory</span></div>
<div class="line"><a name="l02207"></a><span class="lineno"> 2207</span>&#160;        <span class="keyword">delete</span>[] rotMatHlp;</div>
<div class="line"><a name="l02208"></a><span class="lineno"> 2208</span>&#160;        </div>
<div class="line"><a name="l02209"></a><span class="lineno"> 2209</span>&#160;        <span class="comment">//============================================ For the rotation matrix along the detected C5 axis with the same anlge as is between the rotated model C3 and the detected C3 axes.</span></div>
<div class="line"><a name="l02210"></a><span class="lineno"> 2210</span>&#160;        proshade_double* rotMat2                      = <span class="keyword">new</span> proshade_double[9];</div>
<div class="line"><a name="l02211"></a><span class="lineno"> 2211</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a> ( rotMat2, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l02212"></a><span class="lineno"> 2212</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a39eafef902a49cc0816a2ed675c14a49">ProSHADE_internal_maths::getRotationMatrixFromAngleAxis</a> ( rotMat2, CSymList-&gt;at(initAxes.at(pIt).first)[1], CSymList-&gt;at(initAxes.at(pIt).first)[2], CSymList-&gt;at(initAxes.at(pIt).first)[3], bestAng );</div>
<div class="line"><a name="l02213"></a><span class="lineno"> 2213</span>&#160;        </div>
<div class="line"><a name="l02214"></a><span class="lineno"> 2214</span>&#160;        <span class="comment">//============================================ Combine the two rotation matrices into a single rotation matrix</span></div>
<div class="line"><a name="l02215"></a><span class="lineno"> 2215</span>&#160;        proshade_double* rotMatFin                    = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a5f2b9b9da97b52b7e5cccc08493d0e0d">ProSHADE_internal_maths::compute3x3MatrixMultiplication</a> ( rotMat2, rotMat );</div>
<div class="line"><a name="l02216"></a><span class="lineno"> 2216</span>&#160; </div>
<div class="line"><a name="l02217"></a><span class="lineno"> 2217</span>&#160;        <span class="comment">//============================================ For each model axis</span></div>
<div class="line"><a name="l02218"></a><span class="lineno"> 2218</span>&#160;        std::vector&lt; proshade_double* &gt; hlpAxes;</div>
<div class="line"><a name="l02219"></a><span class="lineno"> 2219</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; icoAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1icosahedron_axes.html#aeb51e819ae1cf2ca1a2faba0ee3782ae">getNoAxes</a> ( ); iter++ )</div>
<div class="line"><a name="l02220"></a><span class="lineno"> 2220</span>&#160;        {</div>
<div class="line"><a name="l02221"></a><span class="lineno"> 2221</span>&#160;            <span class="comment">//======================================== Rotate the model axis to fit the detected orientation</span></div>
<div class="line"><a name="l02222"></a><span class="lineno"> 2222</span>&#160;            proshade_double* rotAxis                  = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2f9c7716f6ab682e8548ab77efcdc444">ProSHADE_internal_maths::compute3x3MatrixVectorMultiplication</a> ( rotMatFin,</div>
<div class="line"><a name="l02223"></a><span class="lineno"> 2223</span>&#160;                                                                                                                        icoAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1icosahedron_axes.html#aeec201a53ee1f3aeaf69cc956b43bb30">getValue</a> ( iter, 1 ),</div>
<div class="line"><a name="l02224"></a><span class="lineno"> 2224</span>&#160;                                                                                                                        icoAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1icosahedron_axes.html#aeec201a53ee1f3aeaf69cc956b43bb30">getValue</a> ( iter, 2 ),</div>
<div class="line"><a name="l02225"></a><span class="lineno"> 2225</span>&#160;                                                                                                                        icoAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1icosahedron_axes.html#aeec201a53ee1f3aeaf69cc956b43bb30">getValue</a> ( iter, 3 ) );</div>
<div class="line"><a name="l02226"></a><span class="lineno"> 2226</span>&#160; </div>
<div class="line"><a name="l02227"></a><span class="lineno"> 2227</span>&#160;            <span class="comment">//======================================== Create ProSHADE symmetry axis representation</span></div>
<div class="line"><a name="l02228"></a><span class="lineno"> 2228</span>&#160;            proshade_double* axis                     = <span class="keyword">new</span> proshade_double[7];</div>
<div class="line"><a name="l02229"></a><span class="lineno"> 2229</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a> ( axis, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l02230"></a><span class="lineno"> 2230</span>&#160; </div>
<div class="line"><a name="l02231"></a><span class="lineno"> 2231</span>&#160;            axis[0]                                   = icoAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1icosahedron_axes.html#aeec201a53ee1f3aeaf69cc956b43bb30">getValue</a> ( iter, 0 );</div>
<div class="line"><a name="l02232"></a><span class="lineno"> 2232</span>&#160;            axis[1]                                   = rotAxis[0];</div>
<div class="line"><a name="l02233"></a><span class="lineno"> 2233</span>&#160;            axis[2]                                   = rotAxis[1];</div>
<div class="line"><a name="l02234"></a><span class="lineno"> 2234</span>&#160;            axis[3]                                   = rotAxis[2];</div>
<div class="line"><a name="l02235"></a><span class="lineno"> 2235</span>&#160;            axis[4]                                   = ( 2.0 * M_PI ) / axis[0];</div>
<div class="line"><a name="l02236"></a><span class="lineno"> 2236</span>&#160;            axis[5]                                   = 0.0;</div>
<div class="line"><a name="l02237"></a><span class="lineno"> 2237</span>&#160;            axis[6]                                   = -std::numeric_limits &lt; proshade_double &gt;::infinity();</div>
<div class="line"><a name="l02238"></a><span class="lineno"> 2238</span>&#160; </div>
<div class="line"><a name="l02239"></a><span class="lineno"> 2239</span>&#160;            <span class="comment">//======================================== Save axis to ret</span></div>
<div class="line"><a name="l02240"></a><span class="lineno"> 2240</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aff0d8344fdd83482e5531eadedaac550">ProSHADE_internal_misc::deepCopyAxisToDblPtrVector</a> ( &amp;hlpAxes, axis );</div>
<div class="line"><a name="l02241"></a><span class="lineno"> 2241</span>&#160; </div>
<div class="line"><a name="l02242"></a><span class="lineno"> 2242</span>&#160;            <span class="comment">//======================================== Release memory</span></div>
<div class="line"><a name="l02243"></a><span class="lineno"> 2243</span>&#160;            <span class="keyword">delete</span>[] rotAxis;</div>
<div class="line"><a name="l02244"></a><span class="lineno"> 2244</span>&#160;            <span class="keyword">delete</span>[] axis;</div>
<div class="line"><a name="l02245"></a><span class="lineno"> 2245</span>&#160;        }</div>
<div class="line"><a name="l02246"></a><span class="lineno"> 2246</span>&#160;        </div>
<div class="line"><a name="l02247"></a><span class="lineno"> 2247</span>&#160;        <span class="comment">//============================================ Save to ret</span></div>
<div class="line"><a name="l02248"></a><span class="lineno"> 2248</span>&#160;        ret-&gt;emplace_back                             ( hlpAxes );</div>
<div class="line"><a name="l02249"></a><span class="lineno"> 2249</span>&#160; </div>
<div class="line"><a name="l02250"></a><span class="lineno"> 2250</span>&#160;        <span class="comment">//============================================ Release memory</span></div>
<div class="line"><a name="l02251"></a><span class="lineno"> 2251</span>&#160;        <span class="keyword">delete</span>[] rotMat;</div>
<div class="line"><a name="l02252"></a><span class="lineno"> 2252</span>&#160;        <span class="keyword">delete</span>[] rotMat2;</div>
<div class="line"><a name="l02253"></a><span class="lineno"> 2253</span>&#160;        <span class="keyword">delete</span>[] rotMatFin;</div>
<div class="line"><a name="l02254"></a><span class="lineno"> 2254</span>&#160;        <span class="keyword">delete</span>[] rotModelC3;</div>
<div class="line"><a name="l02255"></a><span class="lineno"> 2255</span>&#160;        <span class="keyword">delete</span>   icoAx;</div>
<div class="line"><a name="l02256"></a><span class="lineno"> 2256</span>&#160;    }</div>
<div class="line"><a name="l02257"></a><span class="lineno"> 2257</span>&#160; </div>
<div class="line"><a name="l02258"></a><span class="lineno"> 2258</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l02259"></a><span class="lineno"> 2259</span>&#160;    return ;</div>
<div class="line"><a name="l02260"></a><span class="lineno"> 2260</span>&#160;    </div>
<div class="line"><a name="l02261"></a><span class="lineno"> 2261</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a38ce8efbbe05220793b5f01f0fef07a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ce8efbbe05220793b5f01f0fef07a6">&#9670;&nbsp;</a></span>predictOctaAxes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::predictOctaAxes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function predicts all octahedral point group symmetry axes from the cyclic point groups list. </p>
<p>This function starts by finding the rotation matrix corresponding to the angle between the predicted C4 axis and the C4 axis found in the pre-computed octahedron model available in the ProSHADE_precomputedValues file. It then proceeds to use this rotation matrix to rotate the pre-computed model C3 axis to now be in the correct orientation to the detected C4 axis.</p>
<p>Next, the function computes the rotation matrix corresponding to rotation along the detected C4 axis about the angle between the rotated pre-computed model C3 axis and the detected C3 axis. Finally, when these two rotation matrices are combined, the resulting rotation matrix is the optimal match rotation between the pre-computed model and the detected axes positions. This final rotation matrix is then used to rotate the model axes and these rotated model axes are then the predicted axes in the structre.</p>
<p>Please note that the peak heights are set to 0.0 for all predicted axes, as they were not detected in the structure, but were only predicted.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function assumes that the <a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a4f09b90de1f15b345ee7998ff31327f3" title="This function takes the list of C symmetries and decides whether basic requirements for isosahedral s...">detectIcosahedralSymmetry()</a> function has successfully run (i.e. returned true).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>The vector containing all the axes forming icosahedral group or empty vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum average peak height for axis to be considered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l02337">2337</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02338"></a><span class="lineno"> 2338</span>&#160;{</div>
<div class="line"><a name="l02339"></a><span class="lineno"> 2339</span>&#160;    <span class="comment">//================================================ Create the tetrahedronAxes object</span></div>
<div class="line"><a name="l02340"></a><span class="lineno"> 2340</span>&#160;    <a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1octahedron_axes.html">ProSHADE_internal_precomputedVals::octahedronAxes</a> *octAx = <span class="keyword">new</span> <a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1octahedron_axes.html">ProSHADE_internal_precomputedVals::octahedronAxes</a> ( );</div>
<div class="line"><a name="l02341"></a><span class="lineno"> 2341</span>&#160;    </div>
<div class="line"><a name="l02342"></a><span class="lineno"> 2342</span>&#160;    <span class="comment">//================================================ Find the best axis combination with dihedral angle and correct folds</span></div>
<div class="line"><a name="l02343"></a><span class="lineno"> 2343</span>&#160;    std::pair&lt; proshade_unsign, proshade_unsign &gt; initAxes = <a class="code" href="_pro_s_h_a_d_e__symmetry_8cpp.html#a458a09071115478efb8b666b839c18f2">findBestOctaDihedralPair</a> ( CSymList, minPeakHeight, axErr );</div>
<div class="line"><a name="l02344"></a><span class="lineno"> 2344</span>&#160;    </div>
<div class="line"><a name="l02345"></a><span class="lineno"> 2345</span>&#160;    <span class="comment">//================================================ Find rotation between the detected C4 and the model C4 axes.</span></div>
<div class="line"><a name="l02346"></a><span class="lineno"> 2346</span>&#160;    proshade_double* rotMat                           = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2b17617f8b3c42c5199948828cd1a57b">ProSHADE_internal_maths::findRotMatMatchingVectors</a> ( octAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1octahedron_axes.html#ab357cd5b90f9f841ae7f53254f54e6d0">getValue</a> ( 0, 1 ),</div>
<div class="line"><a name="l02347"></a><span class="lineno"> 2347</span>&#160;                                                                                                             octAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1octahedron_axes.html#ab357cd5b90f9f841ae7f53254f54e6d0">getValue</a> ( 0, 2 ),</div>
<div class="line"><a name="l02348"></a><span class="lineno"> 2348</span>&#160;                                                                                                             octAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1octahedron_axes.html#ab357cd5b90f9f841ae7f53254f54e6d0">getValue</a> ( 0, 3 ),</div>
<div class="line"><a name="l02349"></a><span class="lineno"> 2349</span>&#160;                                                                                                             CSymList-&gt;at(initAxes.first)[1],</div>
<div class="line"><a name="l02350"></a><span class="lineno"> 2350</span>&#160;                                                                                                             CSymList-&gt;at(initAxes.first)[2],</div>
<div class="line"><a name="l02351"></a><span class="lineno"> 2351</span>&#160;                                                                                                             CSymList-&gt;at(initAxes.first)[3] );</div>
<div class="line"><a name="l02352"></a><span class="lineno"> 2352</span>&#160; </div>
<div class="line"><a name="l02353"></a><span class="lineno"> 2353</span>&#160;    <span class="comment">//================================================ Rotate the model C3 to the correct orientation relative to the detected C4 axis.</span></div>
<div class="line"><a name="l02354"></a><span class="lineno"> 2354</span>&#160;    proshade_double* rotModelC3                       = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2f9c7716f6ab682e8548ab77efcdc444">ProSHADE_internal_maths::compute3x3MatrixVectorMultiplication</a> ( rotMat,</div>
<div class="line"><a name="l02355"></a><span class="lineno"> 2355</span>&#160;                                                                                                                        octAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1octahedron_axes.html#ab357cd5b90f9f841ae7f53254f54e6d0">getValue</a> ( 3, 1 ),</div>
<div class="line"><a name="l02356"></a><span class="lineno"> 2356</span>&#160;                                                                                                                        octAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1octahedron_axes.html#ab357cd5b90f9f841ae7f53254f54e6d0">getValue</a> ( 3, 2 ),</div>
<div class="line"><a name="l02357"></a><span class="lineno"> 2357</span>&#160;                                                                                                                        octAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1octahedron_axes.html#ab357cd5b90f9f841ae7f53254f54e6d0">getValue</a> ( 3, 3 ) );</div>
<div class="line"><a name="l02358"></a><span class="lineno"> 2358</span>&#160;    </div>
<div class="line"><a name="l02359"></a><span class="lineno"> 2359</span>&#160;    <span class="comment">//================================================ Find the angle betwen the rotated model C3 and the detected C3 axes along the detected C4 axis.</span></div>
<div class="line"><a name="l02360"></a><span class="lineno"> 2360</span>&#160;    proshade_double bestAng = 0.0, curAngDist, bestAngDist = 999.9;</div>
<div class="line"><a name="l02361"></a><span class="lineno"> 2361</span>&#160;    proshade_double* rotMatHlp                    = <span class="keyword">new</span> proshade_double[9];</div>
<div class="line"><a name="l02362"></a><span class="lineno"> 2362</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a> ( rotMatHlp, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l02363"></a><span class="lineno"> 2363</span>&#160;    <span class="keywordflow">for</span> ( proshade_double ang = 0.0; ang &lt; ( M_PI * 2.0 ); ang += 0.002 )</div>
<div class="line"><a name="l02364"></a><span class="lineno"> 2364</span>&#160;    {</div>
<div class="line"><a name="l02365"></a><span class="lineno"> 2365</span>&#160;        <span class="comment">//============================================ Compute rotation matrix for this angle value</span></div>
<div class="line"><a name="l02366"></a><span class="lineno"> 2366</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a39eafef902a49cc0816a2ed675c14a49">ProSHADE_internal_maths::getRotationMatrixFromAngleAxis</a> ( rotMatHlp, CSymList-&gt;at(initAxes.first)[1], CSymList-&gt;at(initAxes.first)[2], CSymList-&gt;at(initAxes.first)[3], ang );</div>
<div class="line"><a name="l02367"></a><span class="lineno"> 2367</span>&#160;        </div>
<div class="line"><a name="l02368"></a><span class="lineno"> 2368</span>&#160;        <span class="comment">//============================================ Rotate the rotated C2 by the matrix</span></div>
<div class="line"><a name="l02369"></a><span class="lineno"> 2369</span>&#160;        proshade_double* rotRotModelC3                = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2f9c7716f6ab682e8548ab77efcdc444">ProSHADE_internal_maths::compute3x3MatrixVectorMultiplication</a> ( rotMatHlp,</div>
<div class="line"><a name="l02370"></a><span class="lineno"> 2370</span>&#160;                                                                                                                        rotModelC3[0],</div>
<div class="line"><a name="l02371"></a><span class="lineno"> 2371</span>&#160;                                                                                                                        rotModelC3[1],</div>
<div class="line"><a name="l02372"></a><span class="lineno"> 2372</span>&#160;                                                                                                                        rotModelC3[2] );</div>
<div class="line"><a name="l02373"></a><span class="lineno"> 2373</span>&#160;        </div>
<div class="line"><a name="l02374"></a><span class="lineno"> 2374</span>&#160;        <span class="comment">//============================================ Find distance</span></div>
<div class="line"><a name="l02375"></a><span class="lineno"> 2375</span>&#160;        curAngDist                                    = std::sqrt ( std::pow ( rotRotModelC3[0] - CSymList-&gt;at(initAxes.second)[1], 2.0 ) +</div>
<div class="line"><a name="l02376"></a><span class="lineno"> 2376</span>&#160;                                                                    std::pow ( rotRotModelC3[1] - CSymList-&gt;at(initAxes.second)[2], 2.0 ) +</div>
<div class="line"><a name="l02377"></a><span class="lineno"> 2377</span>&#160;                                                                    std::pow ( rotRotModelC3[2] - CSymList-&gt;at(initAxes.second)[3], 2.0 ) );</div>
<div class="line"><a name="l02378"></a><span class="lineno"> 2378</span>&#160;        </div>
<div class="line"><a name="l02379"></a><span class="lineno"> 2379</span>&#160;        <span class="comment">//============================================ Save best angle</span></div>
<div class="line"><a name="l02380"></a><span class="lineno"> 2380</span>&#160;        <span class="keywordflow">if</span> ( curAngDist &lt; bestAngDist ) { bestAngDist = curAngDist; bestAng = ang; }</div>
<div class="line"><a name="l02381"></a><span class="lineno"> 2381</span>&#160;        </div>
<div class="line"><a name="l02382"></a><span class="lineno"> 2382</span>&#160;        <span class="comment">//============================================ Release memory</span></div>
<div class="line"><a name="l02383"></a><span class="lineno"> 2383</span>&#160;        <span class="keyword">delete</span>[] rotRotModelC3;</div>
<div class="line"><a name="l02384"></a><span class="lineno"> 2384</span>&#160;    }</div>
<div class="line"><a name="l02385"></a><span class="lineno"> 2385</span>&#160;    </div>
<div class="line"><a name="l02386"></a><span class="lineno"> 2386</span>&#160;    <span class="comment">//============================================ Release memory</span></div>
<div class="line"><a name="l02387"></a><span class="lineno"> 2387</span>&#160;    <span class="keyword">delete</span>[] rotMatHlp;</div>
<div class="line"><a name="l02388"></a><span class="lineno"> 2388</span>&#160;    </div>
<div class="line"><a name="l02389"></a><span class="lineno"> 2389</span>&#160;    <span class="comment">//================================================ For the rotation matrix along the detected C5 axis with the same anlge as is between the rotated model C3 and the detected C3 axes.</span></div>
<div class="line"><a name="l02390"></a><span class="lineno"> 2390</span>&#160;    proshade_double* rotMat2                          = <span class="keyword">new</span> proshade_double[9];</div>
<div class="line"><a name="l02391"></a><span class="lineno"> 2391</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( rotMat2, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l02392"></a><span class="lineno"> 2392</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a39eafef902a49cc0816a2ed675c14a49">ProSHADE_internal_maths::getRotationMatrixFromAngleAxis</a> ( rotMat2, CSymList-&gt;at(initAxes.first)[1], CSymList-&gt;at(initAxes.first)[2], CSymList-&gt;at(initAxes.first)[3], bestAng );</div>
<div class="line"><a name="l02393"></a><span class="lineno"> 2393</span>&#160;    </div>
<div class="line"><a name="l02394"></a><span class="lineno"> 2394</span>&#160;    <span class="comment">//================================================ Combine the two rotation matrices into a single rotation matrix</span></div>
<div class="line"><a name="l02395"></a><span class="lineno"> 2395</span>&#160;    proshade_double* rotMatFin                        = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a5f2b9b9da97b52b7e5cccc08493d0e0d">ProSHADE_internal_maths::compute3x3MatrixMultiplication</a> ( rotMat2, rotMat );</div>
<div class="line"><a name="l02396"></a><span class="lineno"> 2396</span>&#160;    </div>
<div class="line"><a name="l02397"></a><span class="lineno"> 2397</span>&#160;    <span class="comment">//================================================ For each model axis</span></div>
<div class="line"><a name="l02398"></a><span class="lineno"> 2398</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; octAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1octahedron_axes.html#a7e437518938a28a37f54c0f6fe3636ec">getNoAxes</a> ( ); iter++ )</div>
<div class="line"><a name="l02399"></a><span class="lineno"> 2399</span>&#160;    {</div>
<div class="line"><a name="l02400"></a><span class="lineno"> 2400</span>&#160;        <span class="comment">//============================================ Rotate the model axis to fit the detected orientation</span></div>
<div class="line"><a name="l02401"></a><span class="lineno"> 2401</span>&#160;        proshade_double* rotAxis                      = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2f9c7716f6ab682e8548ab77efcdc444">ProSHADE_internal_maths::compute3x3MatrixVectorMultiplication</a> ( rotMatFin,</div>
<div class="line"><a name="l02402"></a><span class="lineno"> 2402</span>&#160;                                                                                                                        octAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1octahedron_axes.html#ab357cd5b90f9f841ae7f53254f54e6d0">getValue</a> ( iter, 1 ),</div>
<div class="line"><a name="l02403"></a><span class="lineno"> 2403</span>&#160;                                                                                                                        octAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1octahedron_axes.html#ab357cd5b90f9f841ae7f53254f54e6d0">getValue</a> ( iter, 2 ),</div>
<div class="line"><a name="l02404"></a><span class="lineno"> 2404</span>&#160;                                                                                                                        octAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1octahedron_axes.html#ab357cd5b90f9f841ae7f53254f54e6d0">getValue</a> ( iter, 3 ) );</div>
<div class="line"><a name="l02405"></a><span class="lineno"> 2405</span>&#160;        </div>
<div class="line"><a name="l02406"></a><span class="lineno"> 2406</span>&#160;        <span class="comment">//============================================ Create ProSHADE symmetry axis representation</span></div>
<div class="line"><a name="l02407"></a><span class="lineno"> 2407</span>&#160;        proshade_double* axis                         = <span class="keyword">new</span> proshade_double[7];</div>
<div class="line"><a name="l02408"></a><span class="lineno"> 2408</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a> ( axis, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l02409"></a><span class="lineno"> 2409</span>&#160;        </div>
<div class="line"><a name="l02410"></a><span class="lineno"> 2410</span>&#160;        axis[0]                                       = octAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1octahedron_axes.html#ab357cd5b90f9f841ae7f53254f54e6d0">getValue</a> ( iter, 0 );</div>
<div class="line"><a name="l02411"></a><span class="lineno"> 2411</span>&#160;        axis[1]                                       = rotAxis[0];</div>
<div class="line"><a name="l02412"></a><span class="lineno"> 2412</span>&#160;        axis[2]                                       = rotAxis[1];</div>
<div class="line"><a name="l02413"></a><span class="lineno"> 2413</span>&#160;        axis[3]                                       = rotAxis[2];</div>
<div class="line"><a name="l02414"></a><span class="lineno"> 2414</span>&#160;        axis[4]                                       = ( 2.0 * M_PI ) / axis[0];</div>
<div class="line"><a name="l02415"></a><span class="lineno"> 2415</span>&#160;        axis[5]                                       = 0.0;</div>
<div class="line"><a name="l02416"></a><span class="lineno"> 2416</span>&#160;        axis[6]                                       = -std::numeric_limits &lt; proshade_double &gt;::infinity();</div>
<div class="line"><a name="l02417"></a><span class="lineno"> 2417</span>&#160;        </div>
<div class="line"><a name="l02418"></a><span class="lineno"> 2418</span>&#160;        <span class="comment">//============================================ Save axis to ret</span></div>
<div class="line"><a name="l02419"></a><span class="lineno"> 2419</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a>     ( ret, axis );</div>
<div class="line"><a name="l02420"></a><span class="lineno"> 2420</span>&#160;        </div>
<div class="line"><a name="l02421"></a><span class="lineno"> 2421</span>&#160;        <span class="comment">//============================================ Release memory</span></div>
<div class="line"><a name="l02422"></a><span class="lineno"> 2422</span>&#160;        <span class="keyword">delete</span>[] rotAxis;</div>
<div class="line"><a name="l02423"></a><span class="lineno"> 2423</span>&#160;    }</div>
<div class="line"><a name="l02424"></a><span class="lineno"> 2424</span>&#160;    </div>
<div class="line"><a name="l02425"></a><span class="lineno"> 2425</span>&#160;    <span class="comment">//================================================ Release memory</span></div>
<div class="line"><a name="l02426"></a><span class="lineno"> 2426</span>&#160;    <span class="keyword">delete</span>[] rotMat;</div>
<div class="line"><a name="l02427"></a><span class="lineno"> 2427</span>&#160;    <span class="keyword">delete</span>[] rotMat2;</div>
<div class="line"><a name="l02428"></a><span class="lineno"> 2428</span>&#160;    <span class="keyword">delete</span>[] rotMatFin;</div>
<div class="line"><a name="l02429"></a><span class="lineno"> 2429</span>&#160;    <span class="keyword">delete</span>[] rotModelC3;</div>
<div class="line"><a name="l02430"></a><span class="lineno"> 2430</span>&#160;    <span class="keyword">delete</span>   octAx;</div>
<div class="line"><a name="l02431"></a><span class="lineno"> 2431</span>&#160;    </div>
<div class="line"><a name="l02432"></a><span class="lineno"> 2432</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l02433"></a><span class="lineno"> 2433</span>&#160;    return ;</div>
<div class="line"><a name="l02434"></a><span class="lineno"> 2434</span>&#160;    </div>
<div class="line"><a name="l02435"></a><span class="lineno"> 2435</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aef7a2435e9d3616d860aeee2d94dba55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef7a2435e9d3616d860aeee2d94dba55">&#9670;&nbsp;</a></span>predictTetraAxes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::predictTetraAxes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function predicts all tetrahedral point group symmetry axes from the cyclic point groups list. </p>
<p>This function starts by finding the rotation matrix corresponding to the angle between the predicted C3 axis and the C3 axis found in the pre-computed tetrahedron model available in the ProSHADE_precomputedValues file. It then proceeds to use this rotation matrix to rotate the pre-computed model C2 axis to now be in the correct orientation to the detected C3 axis.</p>
<p>Next, the function computes the rotation matrix corresponding to rotation along the detected C3 axis about the angle between the rotated pre-computed model C2axis and the detected C2 axis. Finally, when these two rotation matrices are combined, the resulting rotation matrix is the optimal match rotation between the pre-computed model and the detected axes positions. This final rotation matrix is then used to rotate the model axes and these rotated model axes are then the predicted axes in the structre.</p>
<p>Please note that the peak heights are set to 0.0 for all predicted axes, as they were not detected in the structure, but were only predicted.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function assumes that the <a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a4f09b90de1f15b345ee7998ff31327f3" title="This function takes the list of C symmetries and decides whether basic requirements for isosahedral s...">detectIcosahedralSymmetry()</a> function has successfully run (i.e. returned true).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>The vector containing all the axes forming icosahedral group or empty vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum average peak height for axis to be considered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l03558">3558</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03559"></a><span class="lineno"> 3559</span>&#160;{</div>
<div class="line"><a name="l03560"></a><span class="lineno"> 3560</span>&#160;    <span class="comment">//================================================ Create the tetrahedronAxes object</span></div>
<div class="line"><a name="l03561"></a><span class="lineno"> 3561</span>&#160;    <a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1tetrahedron_axes.html">ProSHADE_internal_precomputedVals::tetrahedronAxes</a> *tetAx = <span class="keyword">new</span> <a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1tetrahedron_axes.html">ProSHADE_internal_precomputedVals::tetrahedronAxes</a> ( );</div>
<div class="line"><a name="l03562"></a><span class="lineno"> 3562</span>&#160;    </div>
<div class="line"><a name="l03563"></a><span class="lineno"> 3563</span>&#160;    <span class="comment">//================================================ Find the best axis combination with dihedral angle and correct folds</span></div>
<div class="line"><a name="l03564"></a><span class="lineno"> 3564</span>&#160;    std::pair&lt; proshade_unsign, proshade_unsign &gt; initAxes = <a class="code" href="_pro_s_h_a_d_e__symmetry_8cpp.html#a02e0d7dfd2961c534fa1d5ab4c3002e3">findBestTetraDihedralPair</a> ( CSymList, minPeakHeight, axErr );</div>
<div class="line"><a name="l03565"></a><span class="lineno"> 3565</span>&#160; </div>
<div class="line"><a name="l03566"></a><span class="lineno"> 3566</span>&#160;    <span class="comment">//================================================ Find rotation between the detected C3 and the model C3 axes.</span></div>
<div class="line"><a name="l03567"></a><span class="lineno"> 3567</span>&#160;    proshade_double* rotMat                           = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2b17617f8b3c42c5199948828cd1a57b">ProSHADE_internal_maths::findRotMatMatchingVectors</a> ( tetAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1tetrahedron_axes.html#a67427f9d7294471f06126ff7768d8b74">getValue</a> ( 0, 1 ),</div>
<div class="line"><a name="l03568"></a><span class="lineno"> 3568</span>&#160;                                                                                                             tetAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1tetrahedron_axes.html#a67427f9d7294471f06126ff7768d8b74">getValue</a> ( 0, 2 ),</div>
<div class="line"><a name="l03569"></a><span class="lineno"> 3569</span>&#160;                                                                                                             tetAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1tetrahedron_axes.html#a67427f9d7294471f06126ff7768d8b74">getValue</a> ( 0, 3 ),</div>
<div class="line"><a name="l03570"></a><span class="lineno"> 3570</span>&#160;                                                                                                             CSymList-&gt;at(initAxes.first)[1],</div>
<div class="line"><a name="l03571"></a><span class="lineno"> 3571</span>&#160;                                                                                                             CSymList-&gt;at(initAxes.first)[2],</div>
<div class="line"><a name="l03572"></a><span class="lineno"> 3572</span>&#160;                                                                                                             CSymList-&gt;at(initAxes.first)[3] );</div>
<div class="line"><a name="l03573"></a><span class="lineno"> 3573</span>&#160; </div>
<div class="line"><a name="l03574"></a><span class="lineno"> 3574</span>&#160;    <span class="comment">//================================================ Rotate the model C2 to the correct orientation relative to the detected C3 axis.</span></div>
<div class="line"><a name="l03575"></a><span class="lineno"> 3575</span>&#160;    proshade_double* rotModelC2                       = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2f9c7716f6ab682e8548ab77efcdc444">ProSHADE_internal_maths::compute3x3MatrixVectorMultiplication</a> ( rotMat,</div>
<div class="line"><a name="l03576"></a><span class="lineno"> 3576</span>&#160;                                                                                                                        tetAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1tetrahedron_axes.html#a67427f9d7294471f06126ff7768d8b74">getValue</a> ( 4, 1 ),</div>
<div class="line"><a name="l03577"></a><span class="lineno"> 3577</span>&#160;                                                                                                                        tetAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1tetrahedron_axes.html#a67427f9d7294471f06126ff7768d8b74">getValue</a> ( 4, 2 ),</div>
<div class="line"><a name="l03578"></a><span class="lineno"> 3578</span>&#160;                                                                                                                        tetAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1tetrahedron_axes.html#a67427f9d7294471f06126ff7768d8b74">getValue</a> ( 4, 3 ) );</div>
<div class="line"><a name="l03579"></a><span class="lineno"> 3579</span>&#160; </div>
<div class="line"><a name="l03580"></a><span class="lineno"> 3580</span>&#160;    <span class="comment">//================================================ Find the angle betwen the rotated model C2 and the detected C2 axes along the detected C3 axis.</span></div>
<div class="line"><a name="l03581"></a><span class="lineno"> 3581</span>&#160;    proshade_double bestAng = 0.0, curAngDist, bestAngDist = 999.9;</div>
<div class="line"><a name="l03582"></a><span class="lineno"> 3582</span>&#160;    proshade_double* rotMatHlp                        = <span class="keyword">new</span> proshade_double[9];</div>
<div class="line"><a name="l03583"></a><span class="lineno"> 3583</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( rotMatHlp, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l03584"></a><span class="lineno"> 3584</span>&#160;    <span class="keywordflow">for</span> ( proshade_double ang = 0.0; ang &lt; ( M_PI * 2.0 ); ang += 0.002 )</div>
<div class="line"><a name="l03585"></a><span class="lineno"> 3585</span>&#160;    {</div>
<div class="line"><a name="l03586"></a><span class="lineno"> 3586</span>&#160;        <span class="comment">//============================================ Compute rotation matrix for this angle value</span></div>
<div class="line"><a name="l03587"></a><span class="lineno"> 3587</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a39eafef902a49cc0816a2ed675c14a49">ProSHADE_internal_maths::getRotationMatrixFromAngleAxis</a> ( rotMatHlp, CSymList-&gt;at(initAxes.first)[1], CSymList-&gt;at(initAxes.first)[2], CSymList-&gt;at(initAxes.first)[3], ang );</div>
<div class="line"><a name="l03588"></a><span class="lineno"> 3588</span>&#160;        </div>
<div class="line"><a name="l03589"></a><span class="lineno"> 3589</span>&#160;        <span class="comment">//============================================ Rotate the rotated C2 by the matrix</span></div>
<div class="line"><a name="l03590"></a><span class="lineno"> 3590</span>&#160;        proshade_double* rotRotModelC2                = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2f9c7716f6ab682e8548ab77efcdc444">ProSHADE_internal_maths::compute3x3MatrixVectorMultiplication</a> ( rotMatHlp,</div>
<div class="line"><a name="l03591"></a><span class="lineno"> 3591</span>&#160;                                                                                                                        rotModelC2[0],</div>
<div class="line"><a name="l03592"></a><span class="lineno"> 3592</span>&#160;                                                                                                                        rotModelC2[1],</div>
<div class="line"><a name="l03593"></a><span class="lineno"> 3593</span>&#160;                                                                                                                        rotModelC2[2] );</div>
<div class="line"><a name="l03594"></a><span class="lineno"> 3594</span>&#160;        </div>
<div class="line"><a name="l03595"></a><span class="lineno"> 3595</span>&#160;        <span class="comment">//============================================ Find distance</span></div>
<div class="line"><a name="l03596"></a><span class="lineno"> 3596</span>&#160;        curAngDist                                    = std::sqrt ( std::pow ( rotRotModelC2[0] - CSymList-&gt;at(initAxes.second)[1], 2.0 ) +</div>
<div class="line"><a name="l03597"></a><span class="lineno"> 3597</span>&#160;                                                                    std::pow ( rotRotModelC2[1] - CSymList-&gt;at(initAxes.second)[2], 2.0 ) +</div>
<div class="line"><a name="l03598"></a><span class="lineno"> 3598</span>&#160;                                                                    std::pow ( rotRotModelC2[2] - CSymList-&gt;at(initAxes.second)[3], 2.0 ) );</div>
<div class="line"><a name="l03599"></a><span class="lineno"> 3599</span>&#160;        </div>
<div class="line"><a name="l03600"></a><span class="lineno"> 3600</span>&#160;        <span class="comment">//============================================ Save best angle</span></div>
<div class="line"><a name="l03601"></a><span class="lineno"> 3601</span>&#160;        <span class="keywordflow">if</span> ( curAngDist &lt; bestAngDist ) { bestAngDist = curAngDist; bestAng = ang; }</div>
<div class="line"><a name="l03602"></a><span class="lineno"> 3602</span>&#160;        </div>
<div class="line"><a name="l03603"></a><span class="lineno"> 3603</span>&#160;        <span class="comment">//============================================ Release memory</span></div>
<div class="line"><a name="l03604"></a><span class="lineno"> 3604</span>&#160;        <span class="keyword">delete</span>[] rotRotModelC2;</div>
<div class="line"><a name="l03605"></a><span class="lineno"> 3605</span>&#160;    }</div>
<div class="line"><a name="l03606"></a><span class="lineno"> 3606</span>&#160;    </div>
<div class="line"><a name="l03607"></a><span class="lineno"> 3607</span>&#160;    <span class="comment">//================================================ Release memory</span></div>
<div class="line"><a name="l03608"></a><span class="lineno"> 3608</span>&#160;    <span class="keyword">delete</span>[] rotMatHlp;</div>
<div class="line"><a name="l03609"></a><span class="lineno"> 3609</span>&#160;    </div>
<div class="line"><a name="l03610"></a><span class="lineno"> 3610</span>&#160;    <span class="comment">//================================================ For the rotation matrix along the detected C5 axis with the same anlge as is between the rotated model C3 and the detected C3 axes.</span></div>
<div class="line"><a name="l03611"></a><span class="lineno"> 3611</span>&#160;    proshade_double* rotMat2                          = <span class="keyword">new</span> proshade_double[9];</div>
<div class="line"><a name="l03612"></a><span class="lineno"> 3612</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( rotMat2, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l03613"></a><span class="lineno"> 3613</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a39eafef902a49cc0816a2ed675c14a49">ProSHADE_internal_maths::getRotationMatrixFromAngleAxis</a> ( rotMat2, CSymList-&gt;at(initAxes.first)[1], CSymList-&gt;at(initAxes.first)[2], CSymList-&gt;at(initAxes.first)[3], bestAng );</div>
<div class="line"><a name="l03614"></a><span class="lineno"> 3614</span>&#160;    </div>
<div class="line"><a name="l03615"></a><span class="lineno"> 3615</span>&#160;    <span class="comment">//================================================ Combine the two rotation matrices into a single rotation matrix</span></div>
<div class="line"><a name="l03616"></a><span class="lineno"> 3616</span>&#160;    proshade_double* rotMatFin                        = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a5f2b9b9da97b52b7e5cccc08493d0e0d">ProSHADE_internal_maths::compute3x3MatrixMultiplication</a> ( rotMat2, rotMat );</div>
<div class="line"><a name="l03617"></a><span class="lineno"> 3617</span>&#160;    </div>
<div class="line"><a name="l03618"></a><span class="lineno"> 3618</span>&#160;    <span class="comment">//================================================ For each model axis</span></div>
<div class="line"><a name="l03619"></a><span class="lineno"> 3619</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; tetAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1tetrahedron_axes.html#ac293476061c52c6f5c4b3125672e8eae">getNoAxes</a>( ); iter++ )</div>
<div class="line"><a name="l03620"></a><span class="lineno"> 3620</span>&#160;    {</div>
<div class="line"><a name="l03621"></a><span class="lineno"> 3621</span>&#160;        <span class="comment">//============================================ Rotate the model axis to fit the detected orientation</span></div>
<div class="line"><a name="l03622"></a><span class="lineno"> 3622</span>&#160;        proshade_double* rotAxis                      = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2f9c7716f6ab682e8548ab77efcdc444">ProSHADE_internal_maths::compute3x3MatrixVectorMultiplication</a> ( rotMatFin,</div>
<div class="line"><a name="l03623"></a><span class="lineno"> 3623</span>&#160;                                                                                                                        tetAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1tetrahedron_axes.html#a67427f9d7294471f06126ff7768d8b74">getValue</a> ( iter, 1 ),</div>
<div class="line"><a name="l03624"></a><span class="lineno"> 3624</span>&#160;                                                                                                                        tetAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1tetrahedron_axes.html#a67427f9d7294471f06126ff7768d8b74">getValue</a> ( iter, 2 ),</div>
<div class="line"><a name="l03625"></a><span class="lineno"> 3625</span>&#160;                                                                                                                        tetAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1tetrahedron_axes.html#a67427f9d7294471f06126ff7768d8b74">getValue</a> ( iter, 3 ) );</div>
<div class="line"><a name="l03626"></a><span class="lineno"> 3626</span>&#160; </div>
<div class="line"><a name="l03627"></a><span class="lineno"> 3627</span>&#160;        <span class="comment">//============================================ Create ProSHADE symmetry axis representation</span></div>
<div class="line"><a name="l03628"></a><span class="lineno"> 3628</span>&#160;        proshade_double* axis                         = <span class="keyword">new</span> proshade_double[7];</div>
<div class="line"><a name="l03629"></a><span class="lineno"> 3629</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a> ( axis, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l03630"></a><span class="lineno"> 3630</span>&#160; </div>
<div class="line"><a name="l03631"></a><span class="lineno"> 3631</span>&#160;        axis[0]                                       = tetAx-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1tetrahedron_axes.html#a67427f9d7294471f06126ff7768d8b74">getValue</a> ( iter, 0 );</div>
<div class="line"><a name="l03632"></a><span class="lineno"> 3632</span>&#160;        axis[1]                                       = rotAxis[0];</div>
<div class="line"><a name="l03633"></a><span class="lineno"> 3633</span>&#160;        axis[2]                                       = rotAxis[1];</div>
<div class="line"><a name="l03634"></a><span class="lineno"> 3634</span>&#160;        axis[3]                                       = rotAxis[2];</div>
<div class="line"><a name="l03635"></a><span class="lineno"> 3635</span>&#160;        axis[4]                                       = ( 2.0 * M_PI ) / axis[0];</div>
<div class="line"><a name="l03636"></a><span class="lineno"> 3636</span>&#160;        axis[5]                                       = 0.0;</div>
<div class="line"><a name="l03637"></a><span class="lineno"> 3637</span>&#160;        axis[6]                                       = -std::numeric_limits &lt; proshade_double &gt;::infinity();</div>
<div class="line"><a name="l03638"></a><span class="lineno"> 3638</span>&#160; </div>
<div class="line"><a name="l03639"></a><span class="lineno"> 3639</span>&#160;        <span class="comment">//============================================ Save axis to ret</span></div>
<div class="line"><a name="l03640"></a><span class="lineno"> 3640</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a>     ( ret, axis );</div>
<div class="line"><a name="l03641"></a><span class="lineno"> 3641</span>&#160; </div>
<div class="line"><a name="l03642"></a><span class="lineno"> 3642</span>&#160;        <span class="comment">//============================================ Release memory</span></div>
<div class="line"><a name="l03643"></a><span class="lineno"> 3643</span>&#160;        <span class="keyword">delete</span>[] rotAxis;</div>
<div class="line"><a name="l03644"></a><span class="lineno"> 3644</span>&#160;    }</div>
<div class="line"><a name="l03645"></a><span class="lineno"> 3645</span>&#160; </div>
<div class="line"><a name="l03646"></a><span class="lineno"> 3646</span>&#160;    <span class="comment">//================================================ Release memory</span></div>
<div class="line"><a name="l03647"></a><span class="lineno"> 3647</span>&#160;    <span class="keyword">delete</span>[] rotMat;</div>
<div class="line"><a name="l03648"></a><span class="lineno"> 3648</span>&#160;    <span class="keyword">delete</span>[] rotMat2;</div>
<div class="line"><a name="l03649"></a><span class="lineno"> 3649</span>&#160;    <span class="keyword">delete</span>[] rotMatFin;</div>
<div class="line"><a name="l03650"></a><span class="lineno"> 3650</span>&#160;    <span class="keyword">delete</span>[] rotModelC2;</div>
<div class="line"><a name="l03651"></a><span class="lineno"> 3651</span>&#160;    <span class="keyword">delete</span>   tetAx;</div>
<div class="line"><a name="l03652"></a><span class="lineno"> 3652</span>&#160; </div>
<div class="line"><a name="l03653"></a><span class="lineno"> 3653</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l03654"></a><span class="lineno"> 3654</span>&#160;    return ;</div>
<div class="line"><a name="l03655"></a><span class="lineno"> 3655</span>&#160;    </div>
<div class="line"><a name="l03656"></a><span class="lineno"> 3656</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4e67dc983f98cde3963b0d805f41ce30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e67dc983f98cde3963b0d805f41ce30">&#9670;&nbsp;</a></span>releaseCentreOfMapFourierTransforms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::releaseCentreOfMapFourierTransforms </td>
          <td>(</td>
          <td class="paramtype">fftw_complex *&#160;</td>
          <td class="paramname"><em>origMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_complex *&#160;</td>
          <td class="paramname"><em>origCoeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_complex *&#160;</td>
          <td class="paramname"><em>rotMapComplex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_complex *&#160;</td>
          <td class="paramname"><em>rotCoeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_complex *&#160;</td>
          <td class="paramname"><em>trFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_complex *&#160;</td>
          <td class="paramname"><em>trFuncCoeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_plan&#160;</td>
          <td class="paramname"><em>planForwardFourier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_plan&#160;</td>
          <td class="paramname"><em>planForwardFourierRot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fftw_plan&#160;</td>
          <td class="paramname"><em>planReverseFourierComb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function releases the allocated memory for the Fourier transforms used to find the centre of the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">origMap</td><td>Array to which the original map will be saved before Fourier transform computation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">origCoeffs</td><td>Array to which the result of the Fourier transform of the original map will be saved into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotMapComplex</td><td>Array to which the rotated map will be saved before Fourier transform computation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotCoeffs</td><td>Array to which the result of the Fourier transform of the rotated map will be saved into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trFunc</td><td>Array to which the results of inverse Fourier transform of the conbined coefficients will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trFuncCoeffs</td><td>Array to which the two maps coefficients will be combined into before inverse Fourier transform computation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">planForwardFourier</td><td>FFTW3 plan for the original map Fourier transform. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">planForwardFourierRot</td><td>FFTW3 plat for the rotated map Fourier transform. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">planReverseFourierComb</td><td>FFTW3 plan for the inverse Fourier transform from the combined coefficients to translation function. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l03831">3831</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03832"></a><span class="lineno"> 3832</span>&#160;{</div>
<div class="line"><a name="l03833"></a><span class="lineno"> 3833</span>&#160;    <span class="comment">//================================================ Destroy the FFTW3 plans</span></div>
<div class="line"><a name="l03834"></a><span class="lineno"> 3834</span>&#160;    fftw_destroy_plan                                 ( planReverseFourierComb );</div>
<div class="line"><a name="l03835"></a><span class="lineno"> 3835</span>&#160;    fftw_destroy_plan                                 ( planForwardFourier );</div>
<div class="line"><a name="l03836"></a><span class="lineno"> 3836</span>&#160;    fftw_destroy_plan                                 ( planForwardFourierRot );</div>
<div class="line"><a name="l03837"></a><span class="lineno"> 3837</span>&#160;    </div>
<div class="line"><a name="l03838"></a><span class="lineno"> 3838</span>&#160;    <span class="comment">//================================================ Set pointers to NULL</span></div>
<div class="line"><a name="l03839"></a><span class="lineno"> 3839</span>&#160;    planReverseFourierComb                            = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l03840"></a><span class="lineno"> 3840</span>&#160;    planForwardFourier                                = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l03841"></a><span class="lineno"> 3841</span>&#160;    planForwardFourierRot                             = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l03842"></a><span class="lineno"> 3842</span>&#160;    </div>
<div class="line"><a name="l03843"></a><span class="lineno"> 3843</span>&#160;    <span class="comment">//================================================ Release the memory</span></div>
<div class="line"><a name="l03844"></a><span class="lineno"> 3844</span>&#160;    <span class="keyword">delete</span>[] origMap;</div>
<div class="line"><a name="l03845"></a><span class="lineno"> 3845</span>&#160;    <span class="keyword">delete</span>[] origCoeffs;</div>
<div class="line"><a name="l03846"></a><span class="lineno"> 3846</span>&#160;    <span class="keyword">delete</span>[] rotMapComplex;</div>
<div class="line"><a name="l03847"></a><span class="lineno"> 3847</span>&#160;    <span class="keyword">delete</span>[] rotCoeffs;</div>
<div class="line"><a name="l03848"></a><span class="lineno"> 3848</span>&#160;    <span class="keyword">delete</span>[] trFunc;</div>
<div class="line"><a name="l03849"></a><span class="lineno"> 3849</span>&#160;    <span class="keyword">delete</span>[] trFuncCoeffs;</div>
<div class="line"><a name="l03850"></a><span class="lineno"> 3850</span>&#160;    </div>
<div class="line"><a name="l03851"></a><span class="lineno"> 3851</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l03852"></a><span class="lineno"> 3852</span>&#160;    return ;</div>
<div class="line"><a name="l03853"></a><span class="lineno"> 3853</span>&#160;    </div>
<div class="line"><a name="l03854"></a><span class="lineno"> 3854</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab0ac919dd609bc6bded806c0f78201fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0ac919dd609bc6bded806c0f78201fd">&#9670;&nbsp;</a></span>saveDSymmetry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::saveDSymmetry </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>axisOne</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>axisTwo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function saves a detected dihedral symmetry to the dihedral symmetries list. </p>
<p>This function takes two C symmetry axes as supplied by the calling function and the list of the detected C symmetries. It then produces the saving structure for a dihedral symmetry formed by the two supplied axes and saves this structure to the supplied dihedral symmetry list vector - ret.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>The vector of double pointers to which the symmetry is to be saved to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axisOne</td><td>The index of the first C symmetry forming the dihedral symmetry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axisTwo</td><td>The index of the second C symmetry forming the dihedral symmetry. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00383">383</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;{</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;    <span class="comment">//================================================ Allocate the memory</span></div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;    proshade_double* hlpP                             = <span class="keyword">new</span> proshade_double [14];</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( hlpP, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;    </div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;    <span class="comment">//================================================ Set the axis and heights</span></div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;    hlpP[0]                                           = CSymList-&gt;at(axisOne)[0];</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    hlpP[1]                                           = CSymList-&gt;at(axisOne)[1];</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    hlpP[2]                                           = CSymList-&gt;at(axisOne)[2];</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;    hlpP[3]                                           = CSymList-&gt;at(axisOne)[3];</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;    hlpP[4]                                           = CSymList-&gt;at(axisOne)[4];</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    hlpP[5]                                           = CSymList-&gt;at(axisOne)[5];</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;    hlpP[6]                                           = CSymList-&gt;at(axisOne)[6];</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;    hlpP[7]                                           = CSymList-&gt;at(axisTwo)[0];</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;    hlpP[8]                                           = CSymList-&gt;at(axisTwo)[1];</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;    hlpP[9]                                           = CSymList-&gt;at(axisTwo)[2];</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;    hlpP[10]                                          = CSymList-&gt;at(axisTwo)[3];</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;    hlpP[11]                                          = CSymList-&gt;at(axisTwo)[4];</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;    hlpP[12]                                          = CSymList-&gt;at(axisTwo)[5];</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    hlpP[13]                                          = CSymList-&gt;at(axisTwo)[6];</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;    </div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;    <span class="comment">//================================================ Save to ret</span></div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a>         ( ret, hlpP );</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;    </div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;    return ;</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;    </div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5dc4353223fc752e0007b2adec193079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc4353223fc752e0007b2adec193079">&#9670;&nbsp;</a></span>saveMissingAxisNewOnly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::saveMissingAxisNewOnly </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>axVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function saves the recovered information about missing axis into a full symmetry, making sure no duplicates are created. </p>
<p>This function takes the information about the missing symmetry and proceeds to create a full symmetry description out of it. It then checks whether the vector already contains similar symmetry, either replacing the old or ignoring the new symmetry based on which has hiher height. If the symmetry does not match anything in the vector, it will be copied as a new vector entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">axVec</td><td>Vector containing all already detected missing axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axX</td><td>The x-axis element of the missing axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axY</td><td>The y-axis element of the missing axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axZ</td><td>The z-axis element of the missing axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>The average map height for this new axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fold</td><td>The fold of the searched for axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00899">899</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;{</div>
<div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;    <span class="comment">//================================================  Create symmetry array from the inputs</span></div>
<div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;    proshade_double* hlpSym                           = <span class="keyword">new</span> proshade_double [6];</div>
<div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( hlpSym, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;    </div>
<div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;    <span class="comment">//================================================ Fill it in</span></div>
<div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;    hlpSym[0]                                         = <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( fold );</div>
<div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;    hlpSym[1]                                         = axX;</div>
<div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;    hlpSym[2]                                         = axY;</div>
<div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;    hlpSym[3]                                         = axZ;</div>
<div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;    hlpSym[4]                                         = ( 2.0 * M_PI ) / <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( fold );</div>
<div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;    hlpSym[5]                                         = height;</div>
<div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;    </div>
<div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;    <span class="comment">//================================================ Check if similar symmetry does not exist already</span></div>
<div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign symIt = 0; symIt &lt; static_cast&lt;proshade_unsign&gt; ( axVec-&gt;size() ); symIt++ )</div>
<div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;    {</div>
<div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;        <span class="comment">//============================================ Minor speed-up =&gt; only test for same folds</span></div>
<div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;        <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; lhs1 ( axVec-&gt;at(symIt)[0] ), rhs1 ( hlpSym[0] );</div>
<div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;        <span class="keywordflow">if</span> ( lhs1.AlmostEquals ( rhs1 ) )</div>
<div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;        {</div>
<div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;            <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2b2f67cba1eea57f19fdaf062db74fde">ProSHADE_internal_maths::vectorOrientationSimilarity</a> ( axVec-&gt;at(symIt)[1],</div>
<div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;                                                                        axVec-&gt;at(symIt)[2],</div>
<div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;                                                                        axVec-&gt;at(symIt)[3],</div>
<div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;                                                                        hlpSym[1],</div>
<div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;                                                                        hlpSym[2],</div>
<div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;                                                                        hlpSym[3],</div>
<div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;                                                                        axErr ) )</div>
<div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;            {</div>
<div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;                <span class="comment">//==================================== Almost identical entry</span></div>
<div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;                <span class="keywordflow">if</span> ( axVec-&gt;at(symIt)[5] &lt; hlpSym[5] )</div>
<div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;                {</div>
<div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;                    <span class="comment">//================================ If higher, save</span></div>
<div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;                    <span class="keyword">delete</span>[] axVec-&gt;at(symIt);</div>
<div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;                    axVec-&gt;at(symIt)                  = hlpSym;</div>
<div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;                    return ;</div>
<div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;                }</div>
<div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;                {</div>
<div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;                    <span class="comment">//================================ or just terminate if better is already saved</span></div>
<div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;                    <span class="keyword">delete</span>[] hlpSym;</div>
<div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;                    return ;</div>
<div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;                }</div>
<div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;            }</div>
<div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;        }</div>
<div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;    }</div>
<div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;    </div>
<div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;    <span class="comment">//================================================ Not matched to anything</span></div>
<div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a>         ( axVec, hlpSym );</div>
<div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;    </div>
<div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;    return ;</div>
<div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;    </div>
<div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1ada2416687dbb0bec93603770cb4c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ada2416687dbb0bec93603770cb4c83">&#9670;&nbsp;</a></span>searchMissingSymmetrySpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_symmetry::searchMissingSymmetrySpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *&#160;</td>
          <td class="paramname"><em>dataObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>hlpVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>minPeakHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tests feasible axes against the missing axis criteria, returning a set of matching axes. </p>
<p>This function does the real missing axis searching. It starts by taking all supplied axes and algebraically computing the vector which has the required angle to two of the supplied axes. This computed axis is then tested against the group for being unique and having an average height at least as high as required. If such axis is found, it is added to the axes list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataObj</td><td>The full data holding object pointer - this is to get access to self-rotation function values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>A vector of indices (relating to CSymList) of the group members. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hlpVec</td><td>A vector which will hold the detected, but not verified axes to be returned to the caller function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle</td><td>The angle that each group member is required to have against the symmetry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fold</td><td>The fold of the searched for axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPeakHeight</td><td>The minimum new axis average peak height in order for the axis to be added. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00968">968</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;{</div>
<div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;    <span class="comment">//================================================ Sanity check</span></div>
<div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;    <span class="keywordflow">if</span> ( grp-&gt;size() &lt; 2 ) { <span class="keywordflow">return</span>; }</div>
<div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;    </div>
<div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;    proshade_double axHeight                          = 0.0;</div>
<div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;    proshade_double* symHlp                           = <span class="keyword">new</span> proshade_double[7];</div>
<div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( symHlp, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;    </div>
<div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;    <span class="comment">//================================================ For each axis pair in the group, find the possible solutions</span></div>
<div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign fAx = 0; fAx &lt; static_cast&lt;proshade_unsign&gt; ( grp-&gt;size() ); fAx++ )</div>
<div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;    {</div>
<div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign sAx = 1; sAx &lt; static_cast&lt;proshade_unsign&gt; ( grp-&gt;size() ); sAx++ )</div>
<div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;        {</div>
<div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;            <span class="comment">//======================================== Only unique pairs</span></div>
<div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;            <span class="keywordflow">if</span> ( fAx &gt;= sAx ) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;            </div>
<div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;            <span class="comment">//======================================== Find possible axis having the required angle to this pair ( solution 1 )</span></div>
<div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;            std::vector&lt; proshade_double &gt; solVec     = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a45fbcfaeaabf9bae2fbd7d46a5fb4bc7">ProSHADE_internal_maths::findVectorFromTwoVAndTwoD</a> ( CSymList-&gt;at(grp-&gt;at(fAx))[1],</div>
<div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;                                                                                                             CSymList-&gt;at(grp-&gt;at(fAx))[2],</div>
<div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;                                                                                                             CSymList-&gt;at(grp-&gt;at(fAx))[3],</div>
<div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;                                                                                                             CSymList-&gt;at(grp-&gt;at(sAx))[1],</div>
<div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;                                                                                                             CSymList-&gt;at(grp-&gt;at(sAx))[2],</div>
<div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;                                                                                                             CSymList-&gt;at(grp-&gt;at(sAx))[3], angle, angle );</div>
<div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;            </div>
<div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;            <span class="comment">//======================================== Set largest axis element to positive</span></div>
<div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;            <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; lhs1 ( std::max ( std::abs ( solVec.at(0) ), std::max( std::abs ( solVec.at(1) ), std::abs ( solVec.at(2) ) ) ) );</div>
<div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;            <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; rhs1 ( std::abs ( solVec.at(0) ) );</div>
<div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;            <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; rhs2 ( std::abs ( solVec.at(1) ) );</div>
<div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;            <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; rhs3 ( std::abs ( solVec.at(2) ) );</div>
<div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;            <span class="keywordflow">if</span> ( ( lhs1.AlmostEquals ( rhs1 ) &amp;&amp; ( solVec.at(0) &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;                 ( lhs1.AlmostEquals ( rhs2 ) &amp;&amp; ( solVec.at(1) &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;                 ( lhs1.AlmostEquals ( rhs3 ) &amp;&amp; ( solVec.at(2) &lt; 0.0 ) ) )</div>
<div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;            {</div>
<div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;                solVec.at(0)                         *= -1.0;</div>
<div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;                solVec.at(1)                         *= -1.0;</div>
<div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;                solVec.at(2)                         *= -1.0;</div>
<div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;            }</div>
<div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;            </div>
<div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;            <span class="comment">//======================================== Does the solution fit the whole group?</span></div>
<div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;            symHlp[1] = solVec.at(0); symHlp[2] = solVec.at(1); symHlp[3] = solVec.at(2); symHlp[6] = -std::numeric_limits &lt; proshade_double &gt;::infinity();</div>
<div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;            <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad8c193e95c7069fafa78dccc1de1aaa4">ProSHADE_internal_symmetry::testGroupAgainstSymmetry</a> ( CSymList, grp, symHlp, axErr, angle, <span class="keyword">true</span> ) )</div>
<div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;            {</div>
<div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;                <span class="comment">//==================================== Find the height for the axis</span></div>
<div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;                axHeight                              = <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad44ed609e8a3d59674b2b2256aec41f8">ProSHADE_internal_symmetry::missingAxisHeight</a> ( solVec.at(0), solVec.at(1), solVec.at(2), dataObj, fold, axErr );</div>
<div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;                </div>
<div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;                <span class="comment">//================================ Save max height result</span></div>
<div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;                <span class="keywordflow">if</span> ( axHeight &gt;= minPeakHeight ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5dc4353223fc752e0007b2adec193079">ProSHADE_internal_symmetry::saveMissingAxisNewOnly</a> ( hlpVec, solVec.at(0), solVec.at(1), solVec.at(2), axHeight, fold, axErr ); }</div>
<div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;            }</div>
<div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;            </div>
<div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;            <span class="comment">//======================================== Find possible axis having the required angle to this pair ( solution 2 )</span></div>
<div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;            solVec                                    = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a45fbcfaeaabf9bae2fbd7d46a5fb4bc7">ProSHADE_internal_maths::findVectorFromTwoVAndTwoD</a> ( CSymList-&gt;at(grp-&gt;at(fAx))[1],</div>
<div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;                                                                                                             CSymList-&gt;at(grp-&gt;at(fAx))[2],</div>
<div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;                                                                                                             CSymList-&gt;at(grp-&gt;at(fAx))[3],</div>
<div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;                                                                                                             CSymList-&gt;at(grp-&gt;at(sAx))[1],</div>
<div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;                                                                                                             CSymList-&gt;at(grp-&gt;at(sAx))[2],</div>
<div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;                                                                                                             CSymList-&gt;at(grp-&gt;at(sAx))[3], -angle, -angle );</div>
<div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;            </div>
<div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;            <span class="comment">//======================================== Set largest axis element to positive</span></div>
<div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;            <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; lhs2 ( std::max ( std::abs ( solVec.at(0) ), std::max( std::abs ( solVec.at(1) ), std::abs ( solVec.at(2) ) ) ) );</div>
<div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;            <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; rhs4 ( std::abs ( solVec.at(0) ) );</div>
<div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;            <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; rhs5 ( std::abs ( solVec.at(1) ) );</div>
<div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;            <span class="keyword">const</span> FloatingPoint&lt; proshade_double &gt; rhs6 ( std::abs ( solVec.at(2) ) );</div>
<div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;            <span class="keywordflow">if</span> ( ( lhs2.AlmostEquals ( rhs4 ) &amp;&amp; ( solVec.at(0) &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;                 ( lhs2.AlmostEquals ( rhs5 ) &amp;&amp; ( solVec.at(1) &lt; 0.0 ) ) ||</div>
<div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;                 ( lhs2.AlmostEquals ( rhs6 ) &amp;&amp; ( solVec.at(2) &lt; 0.0 ) ) )</div>
<div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;            {</div>
<div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;                solVec.at(0)                         *= -1.0;</div>
<div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;                solVec.at(1)                         *= -1.0;</div>
<div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;                solVec.at(2)                         *= -1.0;</div>
<div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;            }</div>
<div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;            </div>
<div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;            <span class="comment">//======================================== Does the solution fit the whole group?</span></div>
<div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;            symHlp[1] = solVec.at(0); symHlp[2] = solVec.at(1); symHlp[3] = solVec.at(2); symHlp[6] = -std::numeric_limits &lt; proshade_double &gt;::infinity();</div>
<div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;            <span class="keywordflow">if</span> ( <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad8c193e95c7069fafa78dccc1de1aaa4">ProSHADE_internal_symmetry::testGroupAgainstSymmetry</a> ( CSymList, grp, symHlp, axErr, angle, <span class="keyword">true</span> ) )</div>
<div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;            {</div>
<div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;                <span class="comment">//==================================== Find the height for the axis</span></div>
<div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;                axHeight                              = <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad44ed609e8a3d59674b2b2256aec41f8">ProSHADE_internal_symmetry::missingAxisHeight</a> ( solVec.at(0), solVec.at(1), solVec.at(2), dataObj, fold, axErr );</div>
<div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;                </div>
<div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;                <span class="comment">//================================ Save max height result</span></div>
<div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;                <span class="keywordflow">if</span> ( axHeight &gt;= minPeakHeight ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5dc4353223fc752e0007b2adec193079">ProSHADE_internal_symmetry::saveMissingAxisNewOnly</a> ( hlpVec, solVec.at(0), solVec.at(1), solVec.at(2), axHeight, fold, axErr ); }</div>
<div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;            }</div>
<div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;        }</div>
<div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;    }</div>
<div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;    </div>
<div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;    <span class="comment">//================================================ Release memory</span></div>
<div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;    <span class="keyword">delete</span>[] symHlp;</div>
<div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;    </div>
<div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;    return ;</div>
<div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;    </div>
<div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a68d576f90449b7d3fcf5ae4d3114c268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d576f90449b7d3fcf5ae4d3114c268">&#9670;&nbsp;</a></span>sortArrVecHlp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_symmetry::sortArrVecHlp </td>
          <td>(</td>
          <td class="paramtype">const proshade_double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const proshade_double *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function compares two arrays of two based on the first number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first array to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second array to compare. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>Boolean whether the first is smaller than the second. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00736">736</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;{</div>
<div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;    <span class="comment">//================================================ Compare</span></div>
<div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;    <span class="keywordflow">return</span>                                            ( a[0] &lt; b[0] );</div>
<div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;    </div>
<div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5360c152697780177eb2676888cd5108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5360c152697780177eb2676888cd5108">&#9670;&nbsp;</a></span>testGroupAgainstGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_symmetry::testGroupAgainstGroup </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>GrList1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>grp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>GrList2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>grp2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function compares two groups of axes for a single pair having the required angle. </p>
<p>This simple helper function takes two sets of symmetry axes and two vectors of indices, each relating to one of the two sets. It then proceeds to check each of the indexed axes in each set against all the indexed axes in the other set, searching for a particular angle. If this angle is found for at least one pair, true is returned, while otherwise false is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">GrList1</td><td>A vector containing the symmetries for the group 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grp1</td><td>The indices respective to GrList1 which form group 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">GrList2</td><td>A vector containing the symmetries for the group 2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grp2</td><td>The indices respective to GrList1 which form group 2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle</td><td>The angle which needs to be found between any pair of axes in group 1 and 2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>True if succeeded, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01161">1161</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;{</div>
<div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;    <span class="keywordtype">bool</span> ret                                          = <span class="keyword">false</span>;</div>
<div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;    proshade_double dotProduct;</div>
<div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;    </div>
<div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;    <span class="comment">//================================================ For all pairs of axes</span></div>
<div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign g1It = 0; g1It &lt; static_cast&lt;proshade_unsign&gt; ( grp1-&gt;size() ); g1It++ )</div>
<div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;    {</div>
<div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign g2It = 0; g2It &lt; static_cast&lt;proshade_unsign&gt; ( grp2-&gt;size() ); g2It++ )</div>
<div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;        {</div>
<div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;            <span class="comment">//======================================== Find the angle</span></div>
<div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;            dotProduct                                = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> ( &amp;GrList1-&gt;at(grp1-&gt;at(g1It))[1],</div>
<div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;                                                                                                     &amp;GrList1-&gt;at(grp1-&gt;at(g1It))[2],</div>
<div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;                                                                                                     &amp;GrList1-&gt;at(grp1-&gt;at(g1It))[3],</div>
<div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;                                                                                                     &amp;GrList2-&gt;at(grp2-&gt;at(g2It))[1],</div>
<div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;                                                                                                     &amp;GrList2-&gt;at(grp2-&gt;at(g2It))[2],</div>
<div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;                                                                                                     &amp;GrList2-&gt;at(grp2-&gt;at(g2It))[3] );</div>
<div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;            </div>
<div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;            <span class="comment">//======================================== Check the angle</span></div>
<div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;            <span class="keywordflow">if</span> ( ( angle &gt; ( dotProduct - axErr ) ) &amp;&amp; ( angle &lt; ( dotProduct + axErr ) ) )</div>
<div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;            {</div>
<div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;                ret                                   = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;                <span class="keywordflow">return</span>                                ( ret );</div>
<div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;            }</div>
<div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;        }</div>
<div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;    }</div>
<div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;    </div>
<div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;    <span class="keywordflow">return</span>                                            ( ret );</div>
<div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;    </div>
<div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad8c193e95c7069fafa78dccc1de1aaa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c193e95c7069fafa78dccc1de1aaa4">&#9670;&nbsp;</a></span>testGroupAgainstSymmetry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProSHADE_internal_symmetry::testGroupAgainstSymmetry </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double * &gt; *&#160;</td>
          <td class="paramname"><em>CSymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; proshade_unsign &gt; *&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>axErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>improve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tests whether a symmetry has particular angle to all members of a group. </p>
<p>This utility function tests if a sinlge symmetry axis has a given angle to all member of a particular symmetry group as given by the vector of indices and a vector of all symmetries. If the improve parameter is true, that it will also check for the tested axis for being parallel to any of the group axes while having higher average peak height - and in such cases, the function will replace the existing axis with the tested axis index as given in the pos argument. This utility is useful when searching for all axes of polyhedral symmetry groups.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CSymList</td><td>A vector containing the already detected Cyclic symmetries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>A vector of indices (relating to CSymList) of the group members. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sym</td><td>A double pointer to array containing the symmetry to be tested against the group. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axErr</td><td>The error tolerance on angle matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle</td><td>The angle that each group member is required to have against the symmetry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">improve</td><td>Boolead value stating whether an axis with higher average height should be used instead of equal axis with lower average height, if such axis is found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>This is the CSymList index of the axis tested against the group. It will be used if improve = true to change the grp entry which is identical, but has lower height. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>Boolean value speciying whether all group members have the angle to the symmetry or not. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00609">609</a> of file <a class="el" href="_pro_s_h_a_d_e__symmetry_8cpp_source.html">ProSHADE_symmetry.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;{</div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;    <span class="keywordtype">bool</span> allAnglesMet                                 = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;    proshade_double dotProduct;</div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;    </div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;    <span class="comment">//================================================ Improve if required</span></div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;    <span class="keywordflow">if</span> ( improve )</div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;    {</div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign mIt = 0; mIt &lt; static_cast&lt;proshade_unsign&gt; ( grp-&gt;size() ); mIt++ )</div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;        {</div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;            dotProduct                                = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> ( &amp;CSymList-&gt;at(grp-&gt;at(mIt))[1], &amp;CSymList-&gt;at(grp-&gt;at(mIt))[2], &amp;CSymList-&gt;at(grp-&gt;at(mIt))[3], &amp;sym[1], &amp;sym[2], &amp;sym[3] );</div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;            </div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;            <span class="keywordflow">if</span> ( ( ( 1.0 &gt; ( dotProduct - axErr ) ) &amp;&amp; ( 1.0 &lt; ( dotProduct + axErr ) ) ) || ( ( -1.0 &gt; ( dotProduct - axErr ) ) &amp;&amp; ( -1.0 &lt; ( dotProduct + axErr ) ) ) )</div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;            {</div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;                <span class="keywordflow">if</span> ( sym[5] &gt; CSymList-&gt;at(grp-&gt;at(mIt))[5] )</div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;                {</div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;                    grp-&gt;at(mIt)                      = pos;</div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;                }</div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;                {</div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;                    allAnglesMet                      = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;                    <span class="keywordflow">return</span>                            ( allAnglesMet );</div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;                }</div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;            }</div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;        }</div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;    }</div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;    </div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;    <span class="comment">//================================================ For all group members</span></div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign mIt = 0; mIt &lt; static_cast&lt;proshade_unsign&gt; ( grp-&gt;size() ); mIt++ )</div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;    {</div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;        dotProduct                                    = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> ( &amp;CSymList-&gt;at(grp-&gt;at(mIt))[1], &amp;CSymList-&gt;at(grp-&gt;at(mIt))[2], &amp;CSymList-&gt;at(grp-&gt;at(mIt))[3], &amp;sym[1], &amp;sym[2], &amp;sym[3] );</div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;        </div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;        <span class="keywordflow">if</span> ( ( angle &gt; ( std::abs ( dotProduct ) - axErr ) ) &amp;&amp;</div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;             ( angle &lt; ( std::abs ( dotProduct ) + axErr ) ) )</div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;        {</div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;            <span class="comment">//======================================== Matching group memner - try next one</span></div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;        }</div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;        {</div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;            <span class="comment">//======================================== Group member not matched - try next group</span></div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;            allAnglesMet                              = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;        }</div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;    }</div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;    </div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;    <span class="keywordflow">return</span>                                           ( allAnglesMet );</div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;    </div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_ae9f376bb341b192fff008b9b4ef5c603"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#ae9f376bb341b192fff008b9b4ef5c603">ProSHADE_internal_maths::findVectorFromThreeVAndThreeD</a></div><div class="ttdeci">std::vector&lt; proshade_double &gt; findVectorFromThreeVAndThreeD(proshade_double x1, proshade_double y1, proshade_double z1, proshade_double x2, proshade_double y2, proshade_double z2, proshade_double x3, proshade_double y3, proshade_double z3, proshade_double dot1, proshade_double dot2, proshade_double dot3)</div><div class="ttdoc">Function for finding a vector which would have a given three dot products to three other vectors.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l02455">ProSHADE_maths.cpp:2455</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data_html_af4d641d62864e4adf67c1365b0960970"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#af4d641d62864e4adf67c1365b0960970">ProSHADE_internal_data::ProSHADE_data::getZDimSize</a></div><div class="ttdeci">proshade_single getZDimSize(void)</div><div class="ttdoc">This function allows access to the map size in angstroms along the Z axis.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__data_8cpp_source.html#l03919">ProSHADE_data.cpp:3919</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__precomputed_vals_1_1octahedron_axes_html"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1octahedron_axes.html">ProSHADE_internal_precomputedVals::octahedronAxes</a></div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__precomputed_values_8hpp_source.html#l00054">ProSHADE_precomputedValues.hpp:55</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_af6093da290ce7b73a33e8b55f2c83491"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af6093da290ce7b73a33e8b55f2c83491">ProSHADE_internal_symmetry::findMissingAxes</a></div><div class="ttdeci">bool findMissingAxes(std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; *possibilities, std::vector&lt; proshade_double * &gt; *CSymList, proshade_unsign requiredNoAxes, proshade_double axErr, proshade_double angle, proshade_unsign fold, ProSHADE_internal_data::ProSHADE_data *dataObj, proshade_double minPeakHeight)</div><div class="ttdoc">This function tries to find an axis which would complete a particular group of axes for polyhedral sy...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00676">ProSHADE_symmetry.cpp:676</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__misc_html_aa3103c7b5e2dc2cbf1778705c7693334"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__misc.html#aa3103c7b5e2dc2cbf1778705c7693334">ProSHADE_internal_misc::addToDblPtrVector</a></div><div class="ttdeci">void addToDblPtrVector(std::vector&lt; proshade_double * &gt; *vecToAddTo, proshade_double *elementToAdd)</div><div class="ttdoc">Adds the element to the vector.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__misc_8cpp_source.html#l00143">ProSHADE_misc.cpp:143</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_a68d576f90449b7d3fcf5ae4d3114c268"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a68d576f90449b7d3fcf5ae4d3114c268">ProSHADE_internal_symmetry::sortArrVecHlp</a></div><div class="ttdeci">bool sortArrVecHlp(const proshade_double *a, const proshade_double *b)</div><div class="ttdoc">This function compares two arrays of two based on the first number.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00736">ProSHADE_symmetry.cpp:736</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a61807efeb86ea021f3d17ac531911c3c"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a61807efeb86ea021f3d17ac531911c3c">ProSHADE_internal_maths::computeCrossProduct</a></div><div class="ttdeci">proshade_double * computeCrossProduct(proshade_double *x1, proshade_double *y1, proshade_double *z1, proshade_double *x2, proshade_double *y2, proshade_double *z2)</div><div class="ttdoc">Simple 3D vector cross product computation.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01820">ProSHADE_maths.cpp:1820</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_a262d9e21cd6b81b8bda35ec22eb363dd"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a262d9e21cd6b81b8bda35ec22eb363dd">ProSHADE_internal_symmetry::addAxisUnlessSame</a></div><div class="ttdeci">proshade_signed addAxisUnlessSame(proshade_unsign fold, proshade_double axX, proshade_double axY, proshade_double axZ, proshade_double axHeight, proshade_double averageFSC, std::vector&lt; proshade_double * &gt; *prosp, proshade_double axErr)</div><div class="ttdoc">This function simply creates a new axis from information in aruments and tests if no such axis alread...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01657">ProSHADE_symmetry.cpp:1657</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere_html"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere.html">ProSHADE_internal_spheres::ProSHADE_rotFun_sphere</a></div><div class="ttdoc">This class contains all inputed data for the rotation function angle-axis converted spheres.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8hpp_source.html#l00057">ProSHADE_maths.hpp:58</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__precomputed_vals_1_1icosahedron_axes_html_aeec201a53ee1f3aeaf69cc956b43bb30"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1icosahedron_axes.html#aeec201a53ee1f3aeaf69cc956b43bb30">ProSHADE_internal_precomputedVals::icosahedronAxes::getValue</a></div><div class="ttdeci">proshade_double getValue(proshade_unsign axis, proshade_unsign element)</div><div class="ttdoc">Accessor for the icosahedronAxesVals variable.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__precomputed_values_8cpp_source.html#l00223">ProSHADE_precomputedValues.cpp:223</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__exception_html"><div class="ttname"><a href="class_pro_s_h_a_d_e__exception.html">ProSHADE_exception</a></div><div class="ttdoc">This class is the representation of ProSHADE exception.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__exceptions_8hpp_source.html#l00036">ProSHADE_exceptions.hpp:37</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_a33c650c19a6954800bba6b3a8f5842e6"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a33c650c19a6954800bba6b3a8f5842e6">ProSHADE_internal_symmetry::findPredictedAxesHeights</a></div><div class="ttdeci">void findPredictedAxesHeights(std::vector&lt; proshade_double * &gt; *ret, ProSHADE_internal_data::ProSHADE_data *dataObj, ProSHADE_settings *settings)</div><div class="ttdoc">This function finds the rotation function value for all axes supplied in the ret parameter.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l03022">ProSHADE_symmetry.cpp:3022</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data_html_a51d7b9d87d536ef0c48d820872bc9185"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a51d7b9d87d536ef0c48d820872bc9185">ProSHADE_internal_data::ProSHADE_data::getXDimSize</a></div><div class="ttdeci">proshade_single getXDimSize(void)</div><div class="ttdoc">This function allows access to the map size in angstroms along the X axis.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__data_8cpp_source.html#l03899">ProSHADE_data.cpp:3899</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__misc_html_a86e2bb172f766ab4a620df482d2fe481"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__misc.html#a86e2bb172f766ab4a620df482d2fe481">ProSHADE_internal_misc::addToUnsignVectorVector</a></div><div class="ttdeci">void addToUnsignVectorVector(std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; *vecToAddTo, std::vector&lt; proshade_unsign &gt; elementToAdd)</div><div class="ttdoc">Adds the element to the vector of vectors.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__misc_8cpp_source.html#l00211">ProSHADE_misc.cpp:211</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data_html_ae477e3c0d7b866e6069d8603950afe51"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#ae477e3c0d7b866e6069d8603950afe51">ProSHADE_internal_data::ProSHADE_data::getYDimSize</a></div><div class="ttdeci">proshade_single getYDimSize(void)</div><div class="ttdoc">This function allows access to the map size in angstroms along the Y axis.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__data_8cpp_source.html#l03909">ProSHADE_data.cpp:3909</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_ad44ed609e8a3d59674b2b2256aec41f8"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad44ed609e8a3d59674b2b2256aec41f8">ProSHADE_internal_symmetry::missingAxisHeight</a></div><div class="ttdeci">proshade_double missingAxisHeight(proshade_double xVal, proshade_double yVal, proshade_double zVal, ProSHADE_internal_data::ProSHADE_data *dataObj, proshade_unsign fold, proshade_double axErr)</div><div class="ttdoc">This function searches for the highest peaks average that would produce the required axis and fold.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00757">ProSHADE_symmetry.cpp:757</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_a1ada2416687dbb0bec93603770cb4c83"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a1ada2416687dbb0bec93603770cb4c83">ProSHADE_internal_symmetry::searchMissingSymmetrySpace</a></div><div class="ttdeci">void searchMissingSymmetrySpace(ProSHADE_internal_data::ProSHADE_data *dataObj, std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_unsign &gt; *grp, std::vector&lt; proshade_double * &gt; *hlpVec, proshade_double axErr, proshade_double angle, proshade_unsign fold, proshade_double minPeakHeight)</div><div class="ttdoc">This function tests feasible axes against the missing axis criteria, returning a set of matching axes...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00968">ProSHADE_symmetry.cpp:968</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_a6d9f533a789bd5c6031fa77b9649ed3d"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a6d9f533a789bd5c6031fa77b9649ed3d">ProSHADE_internal_symmetry::findMissingAxesDual</a></div><div class="ttdeci">bool findMissingAxesDual(std::vector&lt; proshade_unsign &gt; *possibilities, std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, std::vector&lt; proshade_unsign &gt; *retGroup, proshade_unsign requiredNoAxes, proshade_double axErr, proshade_unsign noMatchesG1, proshade_double angle1, proshade_unsign noMatchesG2, proshade_double angle2, proshade_unsign fold, ProSHADE_internal_data::ProSHADE_data *dataObj)</div><div class="ttdoc">This function tries to find a particular symmetry axes which would complete a group of symmetries wit...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01562">ProSHADE_symmetry.cpp:1562</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data_html_a367d0cd13e3d7a2648488980220ca69b"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a367d0cd13e3d7a2648488980220ca69b">ProSHADE_internal_data::ProSHADE_data::maxShellBand</a></div><div class="ttdeci">proshade_unsign maxShellBand</div><div class="ttdoc">The maximum band for any shell of the object.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__data_8hpp_source.html#l00123">ProSHADE_data.hpp:123</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_abd9fe573a48f499dd7d1df4f779222f1"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#abd9fe573a48f499dd7d1df4f779222f1">ProSHADE_internal_maths::getRotationMatrixFromEulerZXZAngles</a></div><div class="ttdeci">void getRotationMatrixFromEulerZXZAngles(proshade_double eulerAlpha, proshade_double eulerBeta, proshade_double eulerGamma, proshade_double *matrix)</div><div class="ttdoc">Function to find the rotation matrix from Euler angles (ZXZ convention).</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01020">ProSHADE_maths.cpp:1020</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_a8b39de1c901703986cb476d8cb8cf9dc"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a8b39de1c901703986cb476d8cb8cf9dc">ProSHADE_internal_symmetry::optimiseDGroupAngleFromAxesHeights</a></div><div class="ttdeci">void optimiseDGroupAngleFromAxesHeights(std::vector&lt; std::vector&lt; proshade_double &gt; &gt; *ret, ProSHADE_internal_data::ProSHADE_data *dataObj, ProSHADE_settings *settings)</div><div class="ttdoc">This function takes two axes with almost dihedral angle and optimises their relative positions as wel...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l03227">ProSHADE_symmetry.cpp:3227</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__settings_html_a89094c73ae033812d4df0bd846e03442"><div class="ttname"><a href="class_pro_s_h_a_d_e__settings.html#a89094c73ae033812d4df0bd846e03442">ProSHADE_settings::verbose</a></div><div class="ttdeci">proshade_signed verbose</div><div class="ttdoc">Should the software report on the progress, or just be quiet? Value between -1 (nothing) and 4 (loud)</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__settings_8hpp_source.html#l00149">ProSHADE_settings.hpp:149</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_ad977c265833d6466598cceb406a085db"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad977c265833d6466598cceb406a085db">ProSHADE_internal_symmetry::isSymmetrySame</a></div><div class="ttdeci">bool isSymmetrySame(std::vector&lt; proshade_double * &gt; *ret, proshade_double *sym, proshade_double simThres, proshade_signed *matchedPos)</div><div class="ttdoc">This function checks if a very similar symmetry is not already saved.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00200">ProSHADE_symmetry.cpp:200</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a2b2f67cba1eea57f19fdaf062db74fde"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2b2f67cba1eea57f19fdaf062db74fde">ProSHADE_internal_maths::vectorOrientationSimilarity</a></div><div class="ttdeci">bool vectorOrientationSimilarity(proshade_double a1, proshade_double a2, proshade_double a3, proshade_double b1, proshade_double b2, proshade_double b3, proshade_double tolerance=0.1)</div><div class="ttdoc">This function compares two vectors using cosine distance and decides if they are similar using tolera...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l02589">ProSHADE_maths.cpp:2589</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__settings_html_a286453ecf4904c2957e792a24567af6b"><div class="ttname"><a href="class_pro_s_h_a_d_e__settings.html#a286453ecf4904c2957e792a24567af6b">ProSHADE_settings::messageShift</a></div><div class="ttdeci">proshade_signed messageShift</div><div class="ttdoc">This value allows shifting the messages to create more readable log for sub-processes.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__settings_8hpp_source.html#l00150">ProSHADE_settings.hpp:150</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere_peak_group_html_a3b9036c0e6a0aee55a7b480f216db845"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere_peak_group.html#a3b9036c0e6a0aee55a7b480f216db845">ProSHADE_internal_spheres::ProSHADE_rotFun_spherePeakGroup::checkIfPeakBelongs</a></div><div class="ttdeci">bool checkIfPeakBelongs(proshade_double lat, proshade_double lon, proshade_unsign sphPos, proshade_double cosTol, proshade_signed verbose, proshade_signed messageShift)</div><div class="ttdoc">This function takes a new prospective peak and tests if it belongs to this peak group or not.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__spheres_8cpp_source.html#l01163">ProSHADE_spheres.cpp:1163</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__misc_html_a68c3eafaeea1c1873c33525f337f9d0b"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__misc.html#a68c3eafaeea1c1873c33525f337f9d0b">ProSHADE_internal_misc::addToDoubleVector</a></div><div class="ttdeci">void addToDoubleVector(std::vector&lt; proshade_double &gt; *vecToAddTo, proshade_double elementToAdd)</div><div class="ttdoc">Adds the element to the vector.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__misc_8cpp_source.html#l00077">ProSHADE_misc.cpp:77</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__precomputed_vals_1_1octahedron_axes_html_ab357cd5b90f9f841ae7f53254f54e6d0"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1octahedron_axes.html#ab357cd5b90f9f841ae7f53254f54e6d0">ProSHADE_internal_precomputedVals::octahedronAxes::getValue</a></div><div class="ttdeci">proshade_double getValue(proshade_unsign axis, proshade_unsign element)</div><div class="ttdoc">Accessor for the octahedronAxesVals variable.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__precomputed_values_8cpp_source.html#l00136">ProSHADE_precomputedValues.cpp:136</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data_html_a3bc44913222e67ab861dd1e5838c1ae1"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a3bc44913222e67ab861dd1e5838c1ae1">ProSHADE_internal_data::ProSHADE_data::getXDim</a></div><div class="ttdeci">proshade_unsign getXDim(void)</div><div class="ttdoc">This function allows access to the map size in indices along the X axis.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__data_8cpp_source.html#l03929">ProSHADE_data.cpp:3929</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__precomputed_vals_1_1tetrahedron_axes_html_a67427f9d7294471f06126ff7768d8b74"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1tetrahedron_axes.html#a67427f9d7294471f06126ff7768d8b74">ProSHADE_internal_precomputedVals::tetrahedronAxes::getValue</a></div><div class="ttdeci">proshade_double getValue(proshade_unsign axis, proshade_unsign element)</div><div class="ttdoc">Accessor for the tetrahedronAxesVals variable.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__precomputed_values_8cpp_source.html#l00068">ProSHADE_precomputedValues.cpp:68</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__settings_html_afb183823a47a73d459a5bae16042bf4e"><div class="ttname"><a href="class_pro_s_h_a_d_e__settings.html#afb183823a47a73d459a5bae16042bf4e">ProSHADE_settings::useBiCubicInterpolationOnPeaks</a></div><div class="ttdeci">bool useBiCubicInterpolationOnPeaks</div><div class="ttdoc">This variable switch decides whether best symmetry is detected from peak indices, or whether bicubic ...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__settings_8hpp_source.html#l00135">ProSHADE_settings.hpp:135</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_a5dc4353223fc752e0007b2adec193079"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5dc4353223fc752e0007b2adec193079">ProSHADE_internal_symmetry::saveMissingAxisNewOnly</a></div><div class="ttdeci">void saveMissingAxisNewOnly(std::vector&lt; proshade_double * &gt; *axVec, proshade_double axX, proshade_double axY, proshade_double axZ, proshade_double height, proshade_unsign fold, proshade_double axErr)</div><div class="ttdoc">This function saves the recovered information about missing axis into a full symmetry,...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00899">ProSHADE_symmetry.cpp:899</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a2ac3b534f974de25b092e9d48d9f7dea"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a></div><div class="ttdeci">proshade_double computeDotProduct(proshade_double *x1, proshade_double *y1, proshade_double *z1, proshade_double *x2, proshade_double *y2, proshade_double *z2)</div><div class="ttdoc">Simple 3D vector dot product computation.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01788">ProSHADE_maths.cpp:1788</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__misc_html_aff0d8344fdd83482e5531eadedaac550"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__misc.html#aff0d8344fdd83482e5531eadedaac550">ProSHADE_internal_misc::deepCopyAxisToDblPtrVector</a></div><div class="ttdeci">void deepCopyAxisToDblPtrVector(std::vector&lt; proshade_double * &gt; *dblPtrVec, proshade_double *axis)</div><div class="ttdoc">Does a deep copy of a double array to a vector of double arrays.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__misc_8cpp_source.html#l00335">ProSHADE_misc.cpp:335</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__precomputed_vals_1_1tetrahedron_axes_html_ac293476061c52c6f5c4b3125672e8eae"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1tetrahedron_axes.html#ac293476061c52c6f5c4b3125672e8eae">ProSHADE_internal_precomputedVals::tetrahedronAxes::getNoAxes</a></div><div class="ttdeci">proshade_unsign getNoAxes()</div><div class="ttdoc">Accessor for the tetrahedronAxesVals variable number of axes.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__precomputed_values_8cpp_source.html#l00079">ProSHADE_precomputedValues.cpp:79</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a39eafef902a49cc0816a2ed675c14a49"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a39eafef902a49cc0816a2ed675c14a49">ProSHADE_internal_maths::getRotationMatrixFromAngleAxis</a></div><div class="ttdeci">void getRotationMatrixFromAngleAxis(proshade_double *rotMat, proshade_double x, proshade_double y, proshade_double z, proshade_double ang)</div><div class="ttdoc">This function converts the axis-angle representation to the rotation matrix representation.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01459">ProSHADE_maths.cpp:1459</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data_html_a152b43815a3d3debd4b60751d9c8afdd"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a152b43815a3d3debd4b60751d9c8afdd">ProSHADE_internal_data::ProSHADE_data::getMaxBand</a></div><div class="ttdeci">proshade_unsign getMaxBand(void)</div><div class="ttdoc">This function returns the maximum band value for the object.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__data_8cpp_source.html#l03611">ProSHADE_data.cpp:3611</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data_html_a50c884973add562558803a45991bbf19"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a50c884973add562558803a45991bbf19">ProSHADE_internal_data::ProSHADE_data::getYDim</a></div><div class="ttdeci">proshade_unsign getYDim(void)</div><div class="ttdoc">This function allows access to the map size in indices along the Y axis.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__data_8cpp_source.html#l03939">ProSHADE_data.cpp:3939</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a7caf87603d759cb0de1b0bd834ae8f6d"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a7caf87603d759cb0de1b0bd834ae8f6d">ProSHADE_internal_maths::findHighestValueInMap</a></div><div class="ttdeci">void findHighestValueInMap(fftw_complex *resIn, proshade_unsign xD, proshade_unsign yD, proshade_unsign zD, proshade_double *trsX, proshade_double *trsY, proshade_double *trsZ, proshade_double *mapPeak)</div><div class="ttdoc">This function simply finds the highest value in fftw_complex map and returns its position and value.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l03912">ProSHADE_maths.cpp:3912</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_aad5409074bece14a244fad191524a687"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#aad5409074bece14a244fad191524a687">ProSHADE_internal_maths::getAxisAngleFromRotationMatrix</a></div><div class="ttdeci">void getAxisAngleFromRotationMatrix(proshade_double *rotMat, proshade_double *x, proshade_double *y, proshade_double *z, proshade_double *ang, proshade_signed verbose=1)</div><div class="ttdoc">This function converts rotation matrix to the axis-angle representation.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01084">ProSHADE_maths.cpp:1084</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a12a5f7b87baedbe1cd37ad588d3fca92"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a12a5f7b87baedbe1cd37ad588d3fca92">ProSHADE_internal_maths::build3x3MatrixFromXYZRotations</a></div><div class="ttdeci">proshade_double * build3x3MatrixFromXYZRotations(proshade_double xRot, proshade_double yRot, proshade_double zRot)</div><div class="ttdoc">Function for building a 3x3 rotation matrix from the x, y and z rotations in degrees.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l02033">ProSHADE_maths.cpp:2033</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a64ba4ba55d58078eeea8b70311e4ab49"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a64ba4ba55d58078eeea8b70311e4ab49">ProSHADE_internal_maths::combineFourierForTranslation</a></div><div class="ttdeci">void combineFourierForTranslation(fftw_complex *tmpOut1, fftw_complex *tmpOut2, fftw_complex *&amp;resOut, proshade_unsign xD, proshade_unsign yD, proshade_unsign zD)</div><div class="ttdoc">This function combines Fourier coefficients of two structures in a way, so that inverse Fourier of th...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l03865">ProSHADE_maths.cpp:3865</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data_html_a034af93b9152fb2db675d5632a4ebc6d"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a034af93b9152fb2db675d5632a4ebc6d">ProSHADE_internal_data::ProSHADE_data::getZDim</a></div><div class="ttdeci">proshade_unsign getZDim(void)</div><div class="ttdoc">This function allows access to the map size in indices along the Z axis.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__data_8cpp_source.html#l03949">ProSHADE_data.cpp:3949</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a26fa82e82a6a4af696cfae0581785446"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a26fa82e82a6a4af696cfae0581785446">ProSHADE_internal_maths::findTopGroupSmooth</a></div><div class="ttdeci">proshade_double findTopGroupSmooth(std::vector&lt; proshade_double * &gt; *CSym, size_t peakPos, proshade_double step, proshade_double sigma, proshade_signed windowSize, proshade_double maxLim=0.9)</div><div class="ttdoc">This function finds a subgroup of axes with distinctly higher correlation value.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l03743">ProSHADE_maths.cpp:3743</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_a3ec1b87286193d7797b6afa2bed1ea33"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a3ec1b87286193d7797b6afa2bed1ea33">ProSHADE_internal_symmetry::findTranslationBetweenRotatedAndOriginalMap</a></div><div class="ttdeci">std::vector&lt; proshade_double &gt; findTranslationBetweenRotatedAndOriginalMap(ProSHADE_internal_data::ProSHADE_data *symStr, std::vector&lt; proshade_double &gt; symElem, fftw_complex *origCoeffs, fftw_complex *rotMapComplex, fftw_complex *rotCoeffs, fftw_plan planForwardFourierRot, fftw_complex *trFuncCoeffs, fftw_complex *trFunc, fftw_plan planReverseFourierComb)</div><div class="ttdoc">This function takes a single rotation matrix and procceds to compute the optimal translation between ...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l03869">ProSHADE_symmetry.cpp:3869</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere_peak_group_html"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere_peak_group.html">ProSHADE_internal_spheres::ProSHADE_rotFun_spherePeakGroup</a></div><div class="ttdoc">This class contains peak groups detected in the rotation function mapped spheres.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__spheres_8hpp_source.html#l00128">ProSHADE_spheres.hpp:129</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a2380a3710f7dbe672519c3adda30f7cd"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2380a3710f7dbe672519c3adda30f7cd">ProSHADE_internal_maths::isAxisUnique</a></div><div class="ttdeci">bool isAxisUnique(std::vector&lt; proshade_double * &gt; *CSymList, proshade_double *axis, proshade_double tolerance=0.1, bool improve=false)</div><div class="ttdoc">This function checks if new axis is unique, or already detected.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l02974">ProSHADE_maths.cpp:2974</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_ae266053664eb7cf916aa5e2d282e35dd"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ae266053664eb7cf916aa5e2d282e35dd">ProSHADE_internal_symmetry::findMissingAxesTriple</a></div><div class="ttdeci">bool findMissingAxesTriple(std::vector&lt; proshade_unsign &gt; *possibilities, std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, std::vector&lt; proshade_unsign &gt; *retGroup, proshade_unsign requiredNoAxes, proshade_double axErr, proshade_unsign noMatchesG1, proshade_double angle1, proshade_unsign noMatchesG2, proshade_double angle2, proshade_unsign noMatchesG3, proshade_double angle3, proshade_unsign fold, ProSHADE_internal_data::ProSHADE_data *dataObj)</div><div class="ttdoc">This function tries to find a particular symmetry axis which would complete a group of symmetries wit...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l02607">ProSHADE_symmetry.cpp:2607</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a2b17617f8b3c42c5199948828cd1a57b"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2b17617f8b3c42c5199948828cd1a57b">ProSHADE_internal_maths::findRotMatMatchingVectors</a></div><div class="ttdeci">proshade_double * findRotMatMatchingVectors(proshade_double x1, proshade_double y1, proshade_double z1, proshade_double x2, proshade_double y2, proshade_double z2)</div><div class="ttdoc">Computation of rotation matrix rotating one vector onto the other.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l02095">ProSHADE_maths.cpp:2095</a></div></div>
<div class="ttc" id="a_pro_s_h_a_d_e__symmetry_8cpp_html_a16b3a0c170d01be9b4fad682f90025a5"><div class="ttname"><a href="_pro_s_h_a_d_e__symmetry_8cpp.html#a16b3a0c170d01be9b4fad682f90025a5">findBestIcosDihedralPair</a></div><div class="ttdeci">std::vector&lt; std::pair&lt; proshade_unsign, proshade_unsign &gt; &gt; findBestIcosDihedralPair(std::vector&lt; proshade_double * &gt; *CSymList, proshade_double minPeakHeight, proshade_double axErr)</div><div class="ttdoc">This function finds all the pairs of axes conforming to the icosahedron dihedral angle.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l02091">ProSHADE_symmetry.cpp:2091</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data_html_a22caf254dfc11e52890f79a161493e6e"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a22caf254dfc11e52890f79a161493e6e">ProSHADE_internal_data::ProSHADE_data::rotateMapRealSpace</a></div><div class="ttdeci">std::vector&lt; proshade_double &gt; rotateMapRealSpace(proshade_double axX, proshade_double axY, proshade_double axZ, proshade_double axAng, proshade_double *&amp;map)</div><div class="ttdoc">This function rotates a map based on the given angle-axis rotation.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__overlay_8cpp_source.html#l00632">ProSHADE_overlay.cpp:632</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a2f9c7716f6ab682e8548ab77efcdc444"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2f9c7716f6ab682e8548ab77efcdc444">ProSHADE_internal_maths::compute3x3MatrixVectorMultiplication</a></div><div class="ttdeci">proshade_double * compute3x3MatrixVectorMultiplication(proshade_double *mat, proshade_double x, proshade_double y, proshade_double z)</div><div class="ttdoc">Function for computing a 3x3 matrix to 3x1 vector multiplication.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01898">ProSHADE_maths.cpp:1898</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__precomputed_vals_1_1tetrahedron_axes_html"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1tetrahedron_axes.html">ProSHADE_internal_precomputedVals::tetrahedronAxes</a></div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__precomputed_values_8hpp_source.html#l00068">ProSHADE_precomputedValues.hpp:69</a></div></div>
<div class="ttc" id="a_pro_s_h_a_d_e__symmetry_8cpp_html_a02e0d7dfd2961c534fa1d5ab4c3002e3"><div class="ttname"><a href="_pro_s_h_a_d_e__symmetry_8cpp.html#a02e0d7dfd2961c534fa1d5ab4c3002e3">findBestTetraDihedralPair</a></div><div class="ttdeci">std::pair&lt; proshade_unsign, proshade_unsign &gt; findBestTetraDihedralPair(std::vector&lt; proshade_double * &gt; *CSymList, proshade_double minPeakHeight, proshade_double axErr)</div><div class="ttdoc">This function finds the best pair of axes conforming to the tetrahedron dihedral angle.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l03444">ProSHADE_symmetry.cpp:3444</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a4348a7a36275c9cea20b5c27093c9b7e"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a4348a7a36275c9cea20b5c27093c9b7e">ProSHADE_internal_maths::rotationMatrixSimilarity</a></div><div class="ttdeci">bool rotationMatrixSimilarity(std::vector&lt; proshade_double &gt; *mat1, std::vector&lt; proshade_double &gt; *mat2, proshade_double tolerance=0.1)</div><div class="ttdoc">This function compares the distance between two rotation matrices and decides if they are similar usi...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l02552">ProSHADE_maths.cpp:2552</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_ad8c193e95c7069fafa78dccc1de1aaa4"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad8c193e95c7069fafa78dccc1de1aaa4">ProSHADE_internal_symmetry::testGroupAgainstSymmetry</a></div><div class="ttdeci">bool testGroupAgainstSymmetry(std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_unsign &gt; *grp, proshade_double *sym, proshade_double axErr, proshade_double angle, bool improve, proshade_unsign pos=0)</div><div class="ttdoc">This function tests whether a symmetry has particular angle to all members of a group.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00609">ProSHADE_symmetry.cpp:609</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__precomputed_vals_1_1icosahedron_axes_html"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1icosahedron_axes.html">ProSHADE_internal_precomputedVals::icosahedronAxes</a></div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__precomputed_values_8hpp_source.html#l00040">ProSHADE_precomputedValues.hpp:41</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__misc_html_af556836aa9286c1571196de442a6b493"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a></div><div class="ttdeci">void checkMemoryAllocation(chVar checkVar, std::string fileP, unsigned int lineP, std::string funcP, std::string infoP=&quot;This error may occurs when ProSHADE requests memory to be\n                    : allocated to it and this operation fails. This could\n                    : happen when not enough memory is available, either due to\n                    : other processes using a lot of memory, or when the machine\n                    : does not have sufficient memory available. Re-run to see\n                    : if this problem persists.&quot;)</div><div class="ttdoc">Checks if memory was allocated properly.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__misc_8hpp_source.html#l00068">ProSHADE_misc.hpp:68</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_acf6c5376edac98e54ef0e418cd05d706"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#acf6c5376edac98e54ef0e418cd05d706">ProSHADE_internal_maths::getEulerZXZFromSOFTPosition</a></div><div class="ttdeci">void getEulerZXZFromSOFTPosition(proshade_signed band, proshade_signed x, proshade_signed y, proshade_signed z, proshade_double *eulerAlpha, proshade_double *eulerBeta, proshade_double *eulerGamma)</div><div class="ttdoc">Function to find Euler angles (ZXZ convention) from index position in the inverse SOFT map.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00963">ProSHADE_maths.cpp:963</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__precomputed_vals_1_1octahedron_axes_html_a7e437518938a28a37f54c0f6fe3636ec"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1octahedron_axes.html#a7e437518938a28a37f54c0f6fe3636ec">ProSHADE_internal_precomputedVals::octahedronAxes::getNoAxes</a></div><div class="ttdeci">proshade_unsign getNoAxes()</div><div class="ttdoc">Accessor for the octahedronAxesVals variable number of axes.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__precomputed_values_8cpp_source.html#l00147">ProSHADE_precomputedValues.cpp:147</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data_html_a2eb10989a2f8d46b849cdaf8410b68be"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a2eb10989a2f8d46b849cdaf8410b68be">ProSHADE_internal_data::ProSHADE_data::getInvSO3Coeffs</a></div><div class="ttdeci">proshade_complex * getInvSO3Coeffs(void)</div><div class="ttdoc">This function allows access to the inverse SO(3) coefficients array.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__data_8cpp_source.html#l03847">ProSHADE_data.cpp:3847</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__misc_html_a16336bdf0b391c953a549d3df115d691"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__misc.html#a16336bdf0b391c953a549d3df115d691">ProSHADE_internal_misc::addToUnsignVector</a></div><div class="ttdeci">void addToUnsignVector(std::vector&lt; proshade_unsign &gt; *vecToAddTo, proshade_unsign elementToAdd)</div><div class="ttdoc">Adds the element to the vector.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__misc_8cpp_source.html#l00099">ProSHADE_misc.cpp:99</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere_peak_group_html_a5632fb5fe86d3be126f37936568efbcf"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere_peak_group.html#a5632fb5fe86d3be126f37936568efbcf">ProSHADE_internal_spheres::ProSHADE_rotFun_spherePeakGroup::findCyclicPointGroupsGivenFold</a></div><div class="ttdeci">void findCyclicPointGroupsGivenFold(std::vector&lt; ProSHADE_internal_spheres::ProSHADE_rotFun_sphere * &gt; sphereVals, std::vector&lt; proshade_double * &gt; *detectedCs, bool bicubicInterp, proshade_unsign fold, proshade_signed verbose, proshade_signed messageShift)</div><div class="ttdoc">Function detecting cyclic point groups with a particular fold in a peak group.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__spheres_8cpp_source.html#l01392">ProSHADE_spheres.cpp:1392</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_a194944b48a4b6b523ef251a2a03eab17"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a194944b48a4b6b523ef251a2a03eab17">ProSHADE_internal_symmetry::checkFittingAxisTripleAndSave</a></div><div class="ttdeci">void checkFittingAxisTripleAndSave(std::vector&lt; proshade_unsign &gt; *retGroup, std::vector&lt; proshade_double * &gt; *ret, proshade_unsign fold, proshade_double axX, proshade_double axY, proshade_double axZ, std::vector&lt; proshade_double * &gt; *prosp, proshade_double axErr, proshade_unsign noMatchesG1, proshade_double angle1, proshade_unsign noMatchesG2, proshade_double angle2, proshade_unsign noMatchesG3, proshade_double angle3, ProSHADE_internal_data::ProSHADE_data *dataObj)</div><div class="ttdoc">This function takes a newly detected &quot;missing&quot; axis and tests it for belonging to the group,...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l02718">ProSHADE_symmetry.cpp:2718</a></div></div>
<div class="ttc" id="a_pro_s_h_a_d_e__symmetry_8cpp_html_a458a09071115478efb8b666b839c18f2"><div class="ttname"><a href="_pro_s_h_a_d_e__symmetry_8cpp.html#a458a09071115478efb8b666b839c18f2">findBestOctaDihedralPair</a></div><div class="ttdeci">std::pair&lt; proshade_unsign, proshade_unsign &gt; findBestOctaDihedralPair(std::vector&lt; proshade_double * &gt; *CSymList, proshade_double minPeakHeight, proshade_double axErr)</div><div class="ttdoc">This function finds the best pair of axes conforming to the octahedron dihedral angle.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l02270">ProSHADE_symmetry.cpp:2270</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a45fbcfaeaabf9bae2fbd7d46a5fb4bc7"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a45fbcfaeaabf9bae2fbd7d46a5fb4bc7">ProSHADE_internal_maths::findVectorFromTwoVAndTwoD</a></div><div class="ttdeci">std::vector&lt; proshade_double &gt; findVectorFromTwoVAndTwoD(proshade_double x1, proshade_double y1, proshade_double z1, proshade_double x2, proshade_double y2, proshade_double z2, proshade_double dot1, proshade_double dot2)</div><div class="ttdoc">Function for finding a vector which would have a given two dot products to two other vectors.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l02309">ProSHADE_maths.cpp:2309</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__settings_html_a4627b03c4064d3de15efb3ebbf57ed78"><div class="ttname"><a href="class_pro_s_h_a_d_e__settings.html#a4627b03c4064d3de15efb3ebbf57ed78">ProSHADE_settings::axisErrTolerance</a></div><div class="ttdeci">proshade_double axisErrTolerance</div><div class="ttdoc">Allowed error on vector axis in in dot product ( acos ( 1 - axErr ) is the allowed difference in radi...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__settings_8hpp_source.html#l00128">ProSHADE_settings.hpp:128</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__precomputed_vals_1_1icosahedron_axes_html_aeb51e819ae1cf2ca1a2faba0ee3782ae"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__precomputed_vals_1_1icosahedron_axes.html#aeb51e819ae1cf2ca1a2faba0ee3782ae">ProSHADE_internal_precomputedVals::icosahedronAxes::getNoAxes</a></div><div class="ttdeci">proshade_unsign getNoAxes()</div><div class="ttdoc">Accessor for the octahedronAxesVals variable number of axes.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__precomputed_values_8cpp_source.html#l00234">ProSHADE_precomputedValues.cpp:234</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__messages_html_a4f98d32ed17424a1d8bf451a68370e20"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__messages.html#a4f98d32ed17424a1d8bf451a68370e20">ProSHADE_internal_messages::printProgressMessage</a></div><div class="ttdeci">void printProgressMessage(proshade_signed verbose, proshade_signed messageLevel, std::string message, proshade_signed messageShift=0)</div><div class="ttdoc">General stdout message printing.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__messages_8cpp_source.html#l00071">ProSHADE_messages.cpp:71</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__misc_html_a2e915d310892aea124046acd14db4a84"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__misc.html#a2e915d310892aea124046acd14db4a84">ProSHADE_internal_misc::sortSymHlpInv</a></div><div class="ttdeci">bool sortSymHlpInv(const proshade_double *a, const proshade_double *b)</div><div class="ttdoc">This function compares two arrays of two based on the fifth number, sorting highest first.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__misc_8cpp_source.html#l00266">ProSHADE_misc.cpp:266</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_a210ee0af651d440b68168882ead71c66"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a210ee0af651d440b68168882ead71c66">ProSHADE_internal_symmetry::checkFittingAxisDualAndSave</a></div><div class="ttdeci">bool checkFittingAxisDualAndSave(std::vector&lt; proshade_unsign &gt; *retGroup, std::vector&lt; proshade_double * &gt; *ret, proshade_unsign fold, proshade_double axX, proshade_double axY, proshade_double axZ, std::vector&lt; proshade_double * &gt; *prosp, proshade_double axErr, proshade_unsign noMatchesG1, proshade_double angle1, proshade_unsign noMatchesG2, proshade_double angle2, ProSHADE_internal_data::ProSHADE_data *dataObj)</div><div class="ttdoc">This function takes a newly detected &quot;missing&quot; axis and tests it for belonging to the group,...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l01756">ProSHADE_symmetry.cpp:1756</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__symmetry_html_a465606e58df7d6a2238d40c6919b2e58"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a465606e58df7d6a2238d40c6919b2e58">ProSHADE_internal_symmetry::findMissingAxisPoints</a></div><div class="ttdeci">std::vector&lt; proshade_double * &gt; findMissingAxisPoints(proshade_double xVal, proshade_double yVal, proshade_double zVal, ProSHADE_internal_data::ProSHADE_data *dataObj, proshade_double axErr)</div><div class="ttdoc">This function searches for all the self-rotation map points conforming to the axis,...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00821">ProSHADE_symmetry.cpp:821</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a5f2b9b9da97b52b7e5cccc08493d0e0d"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a5f2b9b9da97b52b7e5cccc08493d0e0d">ProSHADE_internal_maths::compute3x3MatrixMultiplication</a></div><div class="ttdeci">proshade_double * compute3x3MatrixMultiplication(proshade_double *mat1, proshade_double *mat2)</div><div class="ttdoc">Function for computing a 3x3 matrix multiplication.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01868">ProSHADE_maths.cpp:1868</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html">ProSHADE_internal_symmetry</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
