<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ProSHADE: ProSHADE Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Logo_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ProSHADE
   &#160;<span id="projectnumber">0.7.4 (SEP 2020) - DEVELOPMENT</span>
   </div>
   <div id="projectbrief">Protein Shape Detection</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">ProSHADE Documentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="intro"></a>
Introduction</h1>
<p>ProSHADE is a C++ language library and an associated tool providing functionalities for working with structural biology molecular structures. The library implements functions for computing shape-wise structural distances between pairs of molecules, detecting symmetry over the centre of mass of a single structure, map re-sizing as well as matching density maps and PDB coordinate files into one another. The executable implemented in the <a class="el" href="bin_8cpp.html" title="This code is the main function for the executable.">bin.cpp</a> file then allows easy access to these functionalities without the need for library linking, while the python modules provide easy access to the functionality from the python language. For help on how the executable should be used, refer to the -h option of it. For more details about the functionalities, see below.</p>
<h1><a class="anchor" id="download"></a>
Obtaining ProSHADE</h1>
<p>The most recent stable version of ProSHADE is available from the <em>master</em> branch of the GitHub repository <a href="https://github.com/michaltykac/proshade">https://github.com/michaltykac/proshade</a>, from where it can be cloned using the git application or downloaded manually using the interface. More advanced users may be interested in obtaining the <em>development</em> or the <em>experimental</em> branches, which are available from the same link. The <em>experimental</em> branch is where I do all new development and it may or may not be currently compilable and working properly, while the <em>development</em> branch should always compile, but is more likely to contain bugs and issues as it is the code before proper testing.</p>
<h1><a class="anchor" id="index"></a>
Index</h1>
<p>1) <a class="el" href="index.html#intro">Introduction</a></p>
<p>2) <a class="el" href="index.html#download">Obtaining ProSHADE</a></p>
<p>3) <a class="el" href="index.html#index">Index</a></p>
<p>4) <a class="el" href="index.html#install">Installation</a></p>
<p>4.1) <a class="el" href="index.html#stdSys">Standard System Dependencies</a></p>
<p>4.2) <a class="el" href="index.html#installBehaviour">CMake options</a></p>
<p>4.3) <a class="el" href="index.html#otherDependencies">Other dependencies</a></p>
<p>4.4) <a class="el" href="index.html#installcode">Install</a></p>
<p>4.5) <a class="el" href="index.html#uninstall">Uninstall</a></p>
<p>5) <a class="el" href="index.html#proshadeBinary">Using the ProSHADE binary</a></p>
<p>5.1) <a class="el" href="index.html#symDetection">Symmetry Detection</a></p>
<p>5.2) <a class="el" href="index.html#distDetection">Shape similarity distances</a></p>
<p>5.3) <a class="el" href="index.html#reboxingUsage">Re-boxing structures</a></p>
<p>5.4) <a class="el" href="index.html#overlayExample">Optimal rotation and translation</a></p>
<p>6) <a class="el" href="index.html#libuse">Using the ProSHADE library</a></p>
<p>6.1) <a class="el" href="index.html#liblink">Linking against the ProSHADE library</a></p>
<p>6.2) <a class="el" href="index.html#libexamples">Examples of ProSHADE library usage</a></p>
<p>7) <a class="el" href="index.html#pyusage">Using the Python modules</a></p>
<p>7.1) <a class="el" href="index.html#pyinstall">Python modules installation notes</a></p>
<p>7.2) <a class="el" href="index.html#pyexamples">Python module examples</a></p>
<h1><a class="anchor" id="install"></a>
Installation</h1>
<p>The installation of the ProSHADE software should be done using the CMake system and the supplied CMakeLists.txt file. The minimual requiered version of CMake is 2.6, however, python modules and single source file compilation will not be available unless CMake version 3.1 or higher is used. The CMakeLists.txt file assumes the standard system dependencies are installed in the system folders; for a full list of standard system dependencies, please see the section <a class="el" href="index.html#stdSys">Standard System Dependencies</a>.</p>
<p>Once all of the standard system dependencies are installed CMake can be run to create the make files. There are several options that can be used to modify the default behaviour of the installation; these typically drive the installation locations and dependencies paths in the case of non-standard dependency location. Please see the section <a class="el" href="index.html#installBehaviour">CMake options</a> for details as to how to use these options and what do they do.</p>
<p>Please note that while the ProSHADE code is C++98 standard compatible, some of the dependencies do require at least partial support for the C++11 standard.</p>
<h2><a class="anchor" id="stdSys"></a>
Standard System Dependencies</h2>
<p>Generally, the following list of standard system libraries and utilities are required for successfull installation of ProSHADE on Linux systems. On MacOS systems, most of these should be installed by default except where specifically stated:</p><ul>
<li><b>gcc</b> </li>
<li><b>g++</b> (on Ubuntu and Debian) or <b>gcc-c++</b> (on CentOS and SuSe)</li>
<li><b>gfortran</b> (on Ubuntu and Debian) or <b>gcc-gfortran</b> (on CentOS and SuSe )</li>
<li><b>make</b> </li>
<li><b>cmake</b> </li>
<li><b>m4</b> </li>
<li><b>fftw3-dev</b> (on Ubuntu, Debian and SuSe) or <b>fftw3-devel</b> (on CentOS)</li>
<li><b>libblas-dev</b> (on Ubuntu and Debian) or <b>blas-devel</b> (on CentOS and SuSe)</li>
<li><b>liblapack-dev</b> (on Ubuntu and Debian) or <b>lapack-devel</b> (on CentOS) or <b>lapack-dev</b> (on SuSe)</li>
<li><b>python</b> (on Ubuntu, Debian and SuSe) or <b>python2</b> (on CentOS)</li>
<li><b>python-pip</b> (on Ubuntu, Debian and SuSe) or <b>python2-pip</b> (on CentOS)</li>
<li><b>python-dev</b> (on Ubuntu, Debian and SuSe) or <b>python2-devel</b> (on CentOS)</li>
<li><b>python3</b> </li>
<li><b>python3-pip</b> </li>
<li><b>python3-dev</b> (on Ubuntu, Debian and SuSe) or <b>python3-devel</b> </li>
<li><b>swig</b> </li>
<li><b>git</b> </li>
<li><b>numpy</b> (installed using pip or pip3 separately for python2.x and python3.x)</li>
</ul>
<h2><a class="anchor" id="installBehaviour"></a>
CMake options</h2>
<p><b>-DINSTALL_LOCALLY=ON</b> or <b>OFF</b> </p><ul>
<li>This option is used to decide whether all the installed ProSHADE components are installed in the local source directory (value <b>ON</b> ) or whether they are instead installed in the system folders (value <b>OFF</b> ). This option applies to the binary, the C++ library, the python2 and python3 modules (which are installed in the appropriate site-packages folder if the option is <b>OFF</b> ) and the headers as well.</li>
</ul>
<p><b>-DINSTALL_BIN_DIR=/path</b> </p><ul>
<li>This option is used to manually specify the folder to which the ProSHADE binary shold be installed into.</li>
</ul>
<p><b>-DINSTALL_LIB_DIR=/path</b> </p><ul>
<li>This option is used to manually specify the folder to which the ProSHADE C++ library should be installed into.</li>
</ul>
<p><b>-DINSTALL_INC_DIR=/path</b> </p><ul>
<li>This option is used to specify the folder to which the ProSHADE header files required by the library should be installed into.</li>
</ul>
<p><b>-DCUSTOM_FFTW3_LIB_PATH=/path</b> </p><ul>
<li>This option is used to supply the path to the libfftw3.a/so/dylib in the case where ProSHADE CMake installation fails to detect the FFTW3 dependency. This is typically the case when FFTW3 is installed outside of the standard FFTW3 installation locations.</li>
</ul>
<p><b>-CUSTOM_FFTW3_INC_PATH=/path</b> </p><ul>
<li>This option is used to supply the path to the fftw3.h file in the case where ProSHADE CMake installation fails to detect the FFTW3 dependency. This is typically the case when FFTW3 is installed outside of the standard FFTW3 installation locations.</li>
</ul>
<p><b>-DCUSTOM_LAPACK_LIB_PATH=/path</b> </p><ul>
<li>This option is used to supply the path to the liblapack.a/so/dylib in the case where ProSHADE CMake installation fails to detect the LAPACK dependency. This is typically the case when the LAPACK is installed outside of the standard LAPACK installation locations.</li>
</ul>
<h2><a class="anchor" id="otherDependencies"></a>
Other dependencies</h2>
<p>ProSHADE also depends on the <em>Gemmi</em> and <em>SOFT2.0</em> libraries. Since the installation of these libraries is non-trivial and does require some user input, these libraries are supplied with the ProSHADE code and will be installed locally by the ProSHADE CMake installation. Please note that these dependencies do have their own licences (the CCP4 licence, the GPL licence, ...) and therefore this may limit the ProSHADE usage for some users beyond the ProSHADE copyright and licence itself.</p>
<h2><a class="anchor" id="installcode"></a>
Install</h2>
<p>In order to install ProSHADE, first please check that all the <a class="el" href="index.html#stdSys">Standard System Dependencies</a> are installed, preferably using a package management system such as <em>apt</em> or <em>yum</em>. Next, please navigate to any folder to which you would like to write the install files; some find it useful to create a <code>build</code> folder in the ProSHADE folder in order to keep the install files in the same location as the source codes. Then, issue the following set of commands, setting the <code>\path</code> \to\ProSHADE to the correct path on your system and adding any required <a class="el" href="index.html#installBehaviour">CMake options</a> to the first command. Please note that <code>sudo</code> may be required for the <code>make</code> <code>install</code> command if you are installing into the system folders.</p>
<p><code>cmake</code> <code>\path</code> \to\ProSHADE</p>
<p><code>make</code> </p>
<p><code>make</code> <code>install</code> </p>
<h2><a class="anchor" id="uninstall"></a>
Uninstall</h2>
<p>To remove the installed ProSHADE components, the command <code>make</code> <code>remove</code> needs to be issued to the makefile originally created by the CMake call. Please note that <code>sudo</code> may need to be used if the installation was done into the system folders and your current user does not have admin rights.</p>
<h1><a class="anchor" id="proshadeBinary"></a>
Using the ProSHADE binary</h1>
<p>The ProSHADE tool was developed in a modular fashion and as the usage slightly changes depending on the functionality that is required. Nonetheless, care has been taken to make sure that identical or closely related features are controlled by the same command line arguments in all cases. Moreover, the GNU command line options standard have been adhered to (through the getOpts library) and therefore the users familiar with other command line tools should find the entering of command line arguments simple. The following subsections relate to examples of using different functionalities; for a full list of command line options, please use the <code>&ndash;help</code> command line option of the ProSHADE binary.</p>
<h2><a class="anchor" id="symDetection"></a>
Symmetry Detection</h2>
<p>In order to detect symmetry in either a coordinate input file, or in a map input file, the ProSHADE executable needs to be supplied with the option <code>-S</code> or <code>&ndash;symmetry</code> and it will also require a single input file to be supplied using the <code>-f</code> option. These two options are the only mandatory options, although there are many optional values that the user can supply to supersede the default values and therefore modify the operation fo the ProSHADE executable to fit their purpose.</p>
<p>One particular option regarding the symmetry detection mode should be noted; the <code>&ndash;sym</code> (or <code>-u</code>) option allows the user to state which symmetry they believe to exist in the structure. The allowed values for this command line argument are "Cx", "Dx", "T", "O" and "I", where the <em>x</em> should be an integer number specifying the fold of the requested symmetry. When this option is used, it removes the default behaviour of returning the highest detected symmetry and instead the symmetry requested by the user is returned, if it can be found in the structure.</p>
<p>Another noteworthy option is the <code>&ndash;center</code> or <code>-c</code> option, which tells ProSHADE to center the internal map representation over the centre of co-ordinates before running any processing of the map. This may be important as ProSHADE detects symmetries over the centre of the co-ordinates and therefore a non-centered map (map which does not have the centre of mass at the centre of co-ordinates) will be found to have no symmetries even if these are present, just not over the co-ordinate centre.</p>
<p>To demonstrate how the tool can be run and the standard output for the symmetry mode of operation, the current version of the ProSHADE executable was used to detect the symmetry of a density map of the bacteriophage T4 portal protein with the PDB accession code 3JA7 (EMDB accession code 6324), which has the <em>C12</em> symmetry. The visualisation of the structure is shown in the following figure, while the output of the ProSHADE tool follows:</p>
<div class="image">
<img src="ProSHADE_3JA7.jpg" alt="" width="500cm"/>
</div>
<div class="fragment"><div class="line">$: ./proshade -S -f ./emd_6324.map --sym C12 -r 8</div>
<div class="line">ProSHADE 0.7.4 (SEP 2020):</div>
<div class="line">==========================</div>
<div class="line"> </div>
<div class="line"> ... Starting to read the structure: ./emd_6324.map</div>
<div class="line"> ... Map inversion (mirror image) not requested.</div>
<div class="line"> ... Map normalisation not requested.</div>
<div class="line"> ... Masking not requested.</div>
<div class="line"> ... Centering map onto its COM.</div>
<div class="line"> ... Adding extra 10 angstroms.</div>
<div class="line"> ... Phase information retained in the data.</div>
<div class="line"> ... Starting sphere mapping procedure.</div>
<div class="line"> ... Preparing spherical harmonics environment.</div>
<div class="line"> ... Starting spherical harmonics decomposition.</div>
<div class="line"> ... Starting self-rotation function computation.</div>
<div class="line"> ... Starting C symmetry detection.</div>
<div class="line"> </div>
<div class="line">Detected C symmetry with fold 12 .</div>
<div class="line"> ...   Fold       X           Y          Z           Angle        Height</div>
<div class="line"> ...    +12     -0.01170   +0.00616   +0.99980     +0.52360      +0.95423</div>
<div class="line"> </div>
<div class="line">======================</div>
<div class="line">ProSHADE run complete.</div>
<div class="line">Time taken: 16 seconds.</div>
<div class="line">======================</div>
</div><!-- fragment --><h2><a class="anchor" id="distDetection"></a>
Shape similarity distances</h2>
<p>The distances computation mode is signalled to the ProSHADE executable by the command line argument <code>-D</code> or <code>&ndash;distances</code>. This mode requires two or more structures to be supplied using the <code>-f</code> command line option. At least two structures are mandatory for the ProSHADE tool to proceed. Moreover, the resolution of the structures to which the comparison should be done needs to be supplied using the <code>-r</code> option. This resolution does not need to be the real resolution to which the structure(s) were solved, but rather reflects the amount of details which should be taken into accout when comparing shapes. Therefore, higher resolution comparison will focus more on details of the shapes, while lower resolution comparison will focus more on the overall shape ignoring the minor details. Please note that the results are calculated only for the first structure against all the remaining structures, <b>not</b> for all against all distance matrix.</p>
<p>There are a number of useful options for the shape distances computation, please consult the <code>&ndash;help</code> dialogue for their complete listing.</p>
<p>To demonstrate the output of the ProSHADE software tool for computing distances between structure shapes, the distances between the BALBES protein domains 1BFO_A_dom_1 and 1H8N_A_dom_1 (which have similar shape) and the 3IGU_A_dom_1 domain which has a different shape, as can be seen from the following figure - the first two domains are both in cluster a), while the last domain is from the cluster b). The output of the ProSHADE software tool is then shown below:</p>
<div class="image">
<img src="ProSHADE_dists.png" alt="" width="500cm"/>
</div>
<div class="fragment"><div class="line">$: ./proshade -D -f ./1BFO_A_dom_1.pdb -f ./1H8N_A_dom_1.pdb -f ./3IGU_A_dom_1.pdb -r 6</div>
<div class="line">ProSHADE 0.7.4 (SEP 2020):</div>
<div class="line">==========================</div>
<div class="line"> </div>
<div class="line"> ... Starting to read the structure: ./1BFO_A_dom_1.pdb</div>
<div class="line"> ... Map inversion (mirror image) not requested.</div>
<div class="line"> ... Map normalisation not requested.</div>
<div class="line"> ... Masking not requested.</div>
<div class="line"> ... Map centering not requested.</div>
<div class="line"> ... Adding extra 10 angstroms.</div>
<div class="line"> ... Phase information retained in the data.</div>
<div class="line"> ... Starting sphere mapping procedure.</div>
<div class="line"> ... Preparing spherical harmonics environment.</div>
<div class="line"> ... Starting spherical harmonics decomposition.</div>
<div class="line"> ... Starting to read the structure: ./1H8N_A_dom_1.pdb</div>
<div class="line"> ... Map inversion (mirror image) not requested.</div>
<div class="line"> ... Map normalisation not requested.</div>
<div class="line"> ... Masking not requested.</div>
<div class="line"> ... Map centering not requested.</div>
<div class="line"> ... Adding extra 10 angstroms.</div>
<div class="line"> ... Phase information retained in the data.</div>
<div class="line"> ... Starting sphere mapping procedure.</div>
<div class="line"> ... Preparing spherical harmonics environment.</div>
<div class="line"> ... Starting spherical harmonics decomposition.</div>
<div class="line"> ... Starting energy levels distance computation.</div>
<div class="line"> ... Starting trace sigma distance computation.</div>
<div class="line"> ... Starting rotation function distance computation.</div>
<div class="line">Distances between ./1BFO_A_dom_1.pdb and ./1H8N_A_dom_1.pdb</div>
<div class="line">Energy levels distance    : 0.895313</div>
<div class="line">Trace sigma distance      : 0.960445</div>
<div class="line">Rotation function distance: 0.756283</div>
<div class="line"> ... Starting to read the structure: ./3IGU_A_dom_1.pdb</div>
<div class="line"> ... Map inversion (mirror image) not requested.</div>
<div class="line"> ... Map normalisation not requested.</div>
<div class="line"> ... Masking not requested.</div>
<div class="line"> ... Map centering not requested.</div>
<div class="line"> ... Adding extra 10 angstroms.</div>
<div class="line"> ... Phase information retained in the data.</div>
<div class="line"> ... Starting sphere mapping procedure.</div>
<div class="line"> ... Preparing spherical harmonics environment.</div>
<div class="line"> ... Starting spherical harmonics decomposition.</div>
<div class="line"> ... Starting energy levels distance computation.</div>
<div class="line"> ... Starting trace sigma distance computation.</div>
<div class="line"> ... Starting rotation function distance computation.</div>
<div class="line">Distances between ./1BFO_A_dom_1.pdb and ./3IGU_A_dom_1.pdb</div>
<div class="line">Energy levels distance    : 0.55904</div>
<div class="line">Trace sigma distance      : 0.736554</div>
<div class="line">Rotation function distance: 0.452416</div>
<div class="line"> </div>
<div class="line">======================</div>
<div class="line">ProSHADE run complete.</div>
<div class="line">Time taken: 4 seconds.</div>
<div class="line">======================</div>
</div><!-- fragment --><h2><a class="anchor" id="reboxingUsage"></a>
Re-boxing structures</h2>
<p>Another useful feature of the ProSHADE tool is the re-boxing of macromolecular density maps. This mode is signalled to the ProSHADE tool by the command line option <code>-M</code> or <code>&ndash;mapManip</code> followed by the <code>-R</code> option to specify that the required map manipulations include re-boxing. Furthermore, a single map structure file needs to be supplied after the <code>-f</code> flag. In this mode, ProSHADE will attempt to find a suitable map mask by blurring the map (increasing the overall B-factors). Consequently, it will use the map boundaries to create a new, hopefully smaller, box to which the appropriate part of the map will be copied.</p>
<p>This ProSHADE functionality can be combinaed with other map manipulations, which include the map invertion (signalled by the <code>&ndash;invertMap</code> option and useful for cases where map reconstruction software mistakes the hands of the structure), the map normalisation (signalled by the <code>&ndash;normalise</code> option, which makes sure the map mean is 0 and standard deviation is 1), centering of centre of mass to the centre of co-ordinates (using the <code>&ndash;center</code> or <code>-c</code> option) or the phase removal (creating Patterson maps using the <code>&ndash;noPhase</code> or <code>-p</code> options).</p>
<p>The location and filename of where this new map should be saved can be specified using the <code>&ndash;reBoxedFilename</code> (or <code>-g</code> ) command line option followed by the filename.</p>
<p>The following snippet shows the output of the ProSHADE tool when used to re-box the TubZ-Bt four-stranded filament structure (EMDB accession code 5762 and PDB accession code 3J4S), where the original volume can be decreased to 46.9% of the original structure volume and thus any linear processing of such structure will be more than twice faster and the original. The original TubZ-Bt four-stranded filament structure box is shown in the following figure as semi-transparent grey, while the new box is shown in non-transparent yellow.</p>
<div class="image">
<img src="ProSHADE_rebox.png" alt="" width="500cm"/>
</div>
<div class="fragment"><div class="line">$ ./proshade -MRf ./emd_5762.map.gz</div>
<div class="line">ProSHADE 0.7.4 (SEP 2020):</div>
<div class="line">==========================</div>
<div class="line"> </div>
<div class="line"> ... Starting to read the structure: ./emd_5762.map.gz</div>
<div class="line"> ... Map inversion (mirror image) not requested.</div>
<div class="line"> ... Map normalisation not requested.</div>
<div class="line"> ... Computing mask.</div>
<div class="line"> ... Map centering not requested.</div>
<div class="line"> ... Adding extra 10 angstroms.</div>
<div class="line"> ... Phase information retained in the data.</div>
<div class="line"> ... Finding new boundaries.</div>
<div class="line"> ... Creating new structure according to the new  bounds.</div>
<div class="line"> ... Saving the re-boxed map into reBoxed_0.map</div>
<div class="line"> </div>
<div class="line">======================</div>
<div class="line">ProSHADE run complete.</div>
<div class="line">Time taken: 9 seconds.</div>
<div class="line">======================</div>
</div><!-- fragment --><h2><a class="anchor" id="overlayExample"></a>
Optimal rotation and translation</h2>
<p>In order to find the rotation and translation which optimally overlays (or fits) one structure into another, be them PDB files or maps (and any combination thereof), the ProSHADE tool can be used in the Overlay mode. This is signalled to the ProSHADE tool binary by the command line option <code>&ndash;strOverlay</code> or the <code>-O</code> and this mode requires exactly two structure files to be supplied using the <code>-f</code> command line options. The order of the two files does matter, as the second file will always be moved to match the first structure, which will remain static.</p>
<p>Due to the requirement for the second stucture movement and rotation, it is worth noting that the structure may need to be re-sampled and/or moved to the same viewing position as the first structure. This is done so that only the internal representation is modified, but never the input file. However, when the overlay structure is outputted (a non-default name can be specified by the <code>&ndash;overlayFile</code> command line option) the header of this output file may differ from the second structure header. Furthermore, if there is no extra space around the structure, movement and rotation may move pieces of the structure through the box boundaries to the other side of the box. To avoid this, please use the <code>&ndash;extraSpace</code> option to add some extra space around the structure.</p>
<p>As an example of the Overlay mode, we will be matching a single PDB structure (1BFO_A_dom_1 from the BALBES database, original structure code 1BFO) shown in part a) of the following figure to another PDB structure, this time the 1H8N_A_dom_1 structure from the BALBES database, shown in part b) of the following figure. Please note that ProSHADE can fit any allowed input (map or co-ordinates) to any allowed input, it is just this example which uses two PDB files. Part c) of the figure then shows the match obtained by the internal map representation of the moving structure (1H8N_A_dom_1) after rotation and translation with the static structure (1BFO_A_dom_1). Finally, part d) then shows the original static structure (1BFO_A_dom_1) in brown and the rotated and translated version of the moving structure (1H8N_A_dom_1) in blue. Please note that the optimal rotation matrix and translation vector are written into the output when verbosity (<code>&ndash;verbose</code>) is increased to at least 3, but are better accessed programatically (see the following sections) if you are interested in using these further.</p>
<div class="image">
<img src="ProSHADE_overlay.jpg" alt="" width="500cm"/>
</div>
<div class="fragment"><div class="line">$ ./proshade -O -f ./1BFO_A_dom_1.pdb -f ./1H8N_A_dom_1.pdb -r 4 -kjc</div>
<div class="line">ProSHADE 0.7.4 (SEP 2020):</div>
<div class="line">==========================</div>
<div class="line"> </div>
<div class="line"> ... Starting to read the structure: ./1BFO_A_dom_1.pdb</div>
<div class="line"> ... Starting to read the structure: ./1H8N_A_dom_1.pdb</div>
<div class="line"> ... Map inversion (mirror image) not requested.</div>
<div class="line"> ... Map normalisation not requested.</div>
<div class="line"> ... Masking not requested.</div>
<div class="line"> ... Centering map onto its COM.</div>
<div class="line"> ... Adding extra 10 angstroms.</div>
<div class="line"> ... Centering map onto its COM.</div>
<div class="line"> ... Phase information removed from the data.</div>
<div class="line"> ... Map inversion (mirror image) not requested.</div>
<div class="line"> ... Map normalisation not requested.</div>
<div class="line"> ... Masking not requested.</div>
<div class="line"> ... Centering map onto its COM.</div>
<div class="line"> ... Adding extra 10 angstroms.</div>
<div class="line"> ... Centering map onto its COM.</div>
<div class="line"> ... Phase information removed from the data.</div>
<div class="line"> ... Starting sphere mapping procedure.</div>
<div class="line"> ... Preparing spherical harmonics environment.</div>
<div class="line"> ... Starting sphere mapping procedure.</div>
<div class="line"> ... Preparing spherical harmonics environment.</div>
<div class="line"> ... Starting spherical harmonics decomposition.</div>
<div class="line"> ... Starting spherical harmonics decomposition.</div>
<div class="line"> ... Starting rotation function computation.</div>
<div class="line"> ... Starting to read the structure: ./1BFO_A_dom_1.pdb</div>
<div class="line"> ... Starting to read the structure: ./1H8N_A_dom_1.pdb</div>
<div class="line"> ... Map inversion (mirror image) not requested.</div>
<div class="line"> ... Map normalisation not requested.</div>
<div class="line"> ... Masking not requested.</div>
<div class="line"> ... Centering map onto its COM.</div>
<div class="line"> ... Adding extra 10 angstroms.</div>
<div class="line"> ... Phase information retained in the data.</div>
<div class="line"> ... Map inversion (mirror image) not requested.</div>
<div class="line"> ... Map normalisation not requested.</div>
<div class="line"> ... Masking not requested.</div>
<div class="line"> ... Centering map onto its COM.</div>
<div class="line"> ... Adding extra 10 angstroms.</div>
<div class="line"> ... Phase information retained in the data.</div>
<div class="line"> ... Starting sphere mapping procedure.</div>
<div class="line"> ... Preparing spherical harmonics environment.</div>
<div class="line"> ... Starting spherical harmonics decomposition.</div>
<div class="line"> ... Starting translation function computation.</div>
<div class="line"> </div>
<div class="line">======================</div>
<div class="line">ProSHADE run complete.</div>
<div class="line">Time taken: 4 seconds.</div>
<div class="line">======================</div>
</div><!-- fragment --><h1><a class="anchor" id="libuse"></a>
Using the ProSHADE library</h1>
<p>ProSHADE allows more programmatic access to its functionality through a C++ dynamic library, which is compiled at the same time as the binary is made. This library can be linked to any C++ project to allow direct access to the ProSHADE objects, functions and results. This section discusses how the ProSHADE library can be linked against and how the basic objects can be accessed.</p>
<h2><a class="anchor" id="liblink"></a>
Linking against the ProSHADE library</h2>
<p>The ProSHADE library can be linked as any other C++ library, that is by using the <code>-lproshade</code> option when calling the compiler (tested on <em>clang</em> and <em>g++</em> ) and including the header file (<code><a class="el" href="_pro_s_h_a_d_e_8hpp.html" title="This is the main header file providing the main access class and its functions.">ProSHADE.hpp</a></code> ). However, as the <code><a class="el" href="_pro_s_h_a_d_e_8hpp.html" title="This is the main header file providing the main access class and its functions.">ProSHADE.hpp</a></code> header file includes header files from the dependencies, any C++ project compiling against the ProSHADE library will need to provide their paths to the compiler. Moreover, if the ProSHADE library was not installed in the system folders (which are by default in the compiler paths), any project linking against the ProSHADE library will also need to provide the path to the libproshade.a/so/dylib library file and the RPATH to the same location. The following list states all the paths that may be required for a successfull compilation against the ProSHADE library:</p>
<ul>
<li><b>-I/path/to/proshade/extern/soft-2.0/include</b> This path is required for the SOFT2.0 dependency header file to be located correctly (it is confusingly called fftw_wrapper.h).</li>
<li><b>-I/path/to/proshade/extern/gemmi/include</b> This path is required for the Gemi dependency header file to be located correctly.</li>
<li><b>-L/path/to/proshade/install/lib</b> This is the path the where libproshade.a/so/dylib is installed. If ProSHADE was installed using the CMake -DINSTALL_LOCALLY=FALSE option, then this path may already be available to the compiler and it may not be needed.</li>
<li><b>-Wl</b>, <b>-rpath</b>, <b>/path/to/proshade/install/lib</b> or <b>-rpath</b> <b>/path/to/proshade/install/lib</b> This compiler option will be required if the proshade library was not installed into a system folder which is already included in the project's RPATH.</li>
</ul>
<p>Overall, a compilation of a C++ project linking against the ProSHADE library may look like the following code:</p>
<div class="fragment"><div class="line">$ clang ./proshadeBinary.cpp -I/path/to/proshade/extern/soft-2.0/include \</div>
<div class="line">                             -I/path/to/proshade/extern/gemmi/include \</div>
<div class="line">                             -L/path/to/proshade/install/lib \</div>
<div class="line">                             -std=c++11 -lproshade -lc++ -lz \</div>
<div class="line">                             -rpath /path/to/proshade/install/lib \</div>
<div class="line">                             -o ./proshadeBinary</div>
</div><!-- fragment --><p>or</p>
<div class="fragment"><div class="line">$ g++ ./proshadeProject.cpp -I/path/to/proshade/extern/soft-2.0/include \</div>
<div class="line">                            -I/path/to/proshade/extern/gemmi/include \</div>
<div class="line">                            -L/path/to/proshade/install/lib \</div>
<div class="line">                            -lproshade -lz -Wl,-rpath,/path/to/proshade/install/lib \</div>
<div class="line">                            -o ./proshadeProject</div>
</div><!-- fragment --><h2><a class="anchor" id="libexamples"></a>
Examples of ProSHADE library usage</h2>
<p>There are several examples of C++ code which makes use of the ProSHADE dynamic library to compute the standard ProSHADE functionalities and access the results programmatically (i.e. without the need for parsing any log files).</p>
<p><b>Simple</b> <b>access</b> </p>
<p>The examples are avaialbe in the <b>/path/to/proshade/examples/libproshade</b> folder and are divided into two categories of four examples. The source files with names starting with <em>simpleAccess_</em>... provide a <em>black</em> <em>box</em> experience similar to using ProSHADE binary. The user firstly creates a <code><a class="el" href="class_pro_s_h_a_d_e__settings.html" title="This class stores all the settings and is passed to the executive classes instead of a multitude of p...">ProSHADE_settings</a></code> object, which provides all the variables that can be set in order to drive which ProSHADE functionality is required and how it should be done. Next, the user needs to create the <code><a class="el" href="class_pro_s_h_a_d_e__run.html" title="This class provides the access point to the library.">ProSHADE_run</a></code> object, whose constructor takes the already created and filled <code>ProSHADE_setings</code> object as its only argument. This constructor will then proceed to compute all required information according to the settings object and return when complete. While the computation is being done, the execution is with the ProSHADE library and any C++ project using this mode will be waiting for the ProSHADE library to finish. Once the computation is complete, the execution will be returned to the calling C++ project and the results will be accessible through public functions of the <code><a class="el" href="class_pro_s_h_a_d_e__run.html" title="This class provides the access point to the library.">ProSHADE_run</a></code> object. The following code shows a very simple example of how ProSHADE can be run in this mode, but for more specific examples the users should review the <em>simpleAccess_</em>... example files.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_pro_s_h_a_d_e_8hpp.html">ProSHADE.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main ( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//================================================ Create the settings object</span></div>
<div class="line">    ProSHADE_Task task                                = Distances;</div>
<div class="line">    <a class="code" href="class_pro_s_h_a_d_e__settings.html">ProSHADE_settings</a>* settings                       = <span class="keyword">new</span> <a class="code" href="class_pro_s_h_a_d_e__settings.html">ProSHADE_settings</a> ( task );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//================================================ Set the settings object up</span></div>
<div class="line">    settings-&gt;<a class="code" href="class_pro_s_h_a_d_e__settings.html#a3e7f4174b62aa402a1f6d3becd8e9dd5">setResolution</a>                           ( 10.0 );</div>
<div class="line">    settings-&gt;<a class="code" href="class_pro_s_h_a_d_e__settings.html#a0024967775d544e8512b6b157d53c1d1">addStructure</a>                            ( <span class="stringliteral">&quot;./str1.pdb&quot;</span> );</div>
<div class="line">    settings-&gt;<a class="code" href="class_pro_s_h_a_d_e__settings.html#a0024967775d544e8512b6b157d53c1d1">addStructure</a>                            ( <span class="stringliteral">&quot;./str2.pdb&quot;</span> );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//================================================ Run ProSHADE. This may take some time, depending on what computations are required.</span></div>
<div class="line">    <a class="code" href="class_pro_s_h_a_d_e__run.html">ProSHADE_run</a>* runProshade                         = <span class="keyword">new</span> <a class="code" href="class_pro_s_h_a_d_e__run.html">ProSHADE_run</a> ( settings );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//================================================ Access the results</span></div>
<div class="line">    std::vector&lt; proshade_double &gt; energyDistances    = runProshade-&gt;<a class="code" href="class_pro_s_h_a_d_e__run.html#afe51ca33765b921b8e8381527b899cb3">getEnergyLevelsVector</a>     ( );</div>
<div class="line">    std::vector&lt; proshade_double &gt; traceDistances     = runProshade-&gt;<a class="code" href="class_pro_s_h_a_d_e__run.html#a78d93810b15c64493a5a2de49accafbc">getTraceSigmaVector</a>       ( );</div>
<div class="line">    std::vector&lt; proshade_double &gt; rotFunDistances    = runProshade-&gt;<a class="code" href="class_pro_s_h_a_d_e__run.html#a089c19ee79d76d77b50a38691b43940d">getRotationFunctionVector</a> ( );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//================================================ Release the memory</span></div>
<div class="line">    <span class="keyword">delete</span> runProshade;</div>
<div class="line">    <span class="keyword">delete</span> settings;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//================================================ Done</span></div>
<div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Advanced</b> <b>access</b> </p>
<p>The second set of examples of usage of the ProSHADE library are the source files with names starting with <em>advancedAccess_</em>... . These files provide examples of how individual ProSHADE functions can be arranged to provide the results of the main ProSHADE functionalities. Using the ProSHADE tool in the manner shown in these example codes gives the user more control over the execution and it also allows the user to modify the behaviour directly. On the other hand, using ProSHADE in this way required a bit more understanding than the simple <em>black</em> <em>box</em> approach and this documentation should be helpful for all who wish to use ProSHADE this way. Interested users are advised to review all the <em>advancedAccess_</em>... source files as well as the following simple example code.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_pro_s_h_a_d_e_8hpp.html">ProSHADE.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main ( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//================================================ Create the settings object</span></div>
<div class="line">    ProSHADE_Task task                                = Symmetry;</div>
<div class="line">    <a class="code" href="class_pro_s_h_a_d_e__settings.html">ProSHADE_settings</a>* settings                       = <span class="keyword">new</span> <a class="code" href="class_pro_s_h_a_d_e__settings.html">ProSHADE_settings</a> ( task );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//================================================ Create the structure objects</span></div>
<div class="line">    <a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a>* simpleSym  = <span class="keyword">new</span> <a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> ( settings );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//================================================ Read in the structures</span></div>
<div class="line">    simpleSym-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a59f2f2ce1bfdb90432c5a29600fdd9e6">readInStructure</a>                        ( <span class="stringliteral">&quot;./emd_6324.map&quot;</span>, 0, settings );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//================================================ Process internal map</span></div>
<div class="line">    simpleSym-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#afcb4202e9ffea1b99c59f73faf06d899">processInternalMap</a>                     ( settings );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//================================================ Map to spheres</span></div>
<div class="line">    simpleSym-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a56bfcfacedabd84ec54aa2843d59e014">mapToSpheres</a>                           ( settings );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//================================================ Compute spherical harmonics decompostion</span></div>
<div class="line">    simpleSym-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a23f9a5f8f6fb7cf0f0324bc1d83d6090">computeSphericalHarmonics</a>              ( settings );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//================================================ Compute self-rotation function</span></div>
<div class="line">    simpleSym-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#ae016c0e3cbba28141d593a6147f0b012">getRotationFunction</a>                    ( settings );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//================================================ Detect the recommended symmetry</span></div>
<div class="line">    std::vector&lt; proshade_double* &gt; symAxes;</div>
<div class="line">    simpleSym-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#af60532f379f5f3549a598aeb504fe311">detectSymmetryInStructure</a>              ( settings, &amp;symAxes );</div>
<div class="line">    std::string symmetryType                          = simpleSym-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#ad5add825ce8d5e5d9f598f6912f07aff">getRecommendedSymmetryType</a> ( settings );</div>
<div class="line">    proshade_unsign symmetryFold                      = simpleSym-&gt;<a class="code" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a8e1bd5bd5a3fd12691a1d83735c13250">getRecommendedSymmetryFold</a> ( settings );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//================================================ Write out the symmetry detection results</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Detected symmetry: &quot;</span> &lt;&lt; symmetryType &lt;&lt; <span class="stringliteral">&quot;-&quot;</span> &lt;&lt; symmetryFold &lt;&lt; <span class="stringliteral">&quot; with axes:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">for</span> ( proshade_unsign axIt = 0; axIt &lt; static_cast&lt;proshade_unsign&gt; ( symAxes.size() ); axIt++ )</div>
<div class="line">    {</div>
<div class="line">       std::cout &lt;&lt; <span class="stringliteral">&quot;Symmetry axis number &quot;</span> &lt;&lt; axIt &lt;&lt; std::endl;</div>
<div class="line">       std::cout &lt;&lt; <span class="stringliteral">&quot; ... Fold             &quot;</span> &lt;&lt; symAxes.at(axIt)[0] &lt;&lt; std::endl;</div>
<div class="line">       std::cout &lt;&lt; <span class="stringliteral">&quot; ... XYZ:             &quot;</span> &lt;&lt; symAxes.at(axIt)[1] &lt;&lt; <span class="stringliteral">&quot; ; &quot;</span> &lt;&lt; symAxes.at(axIt)[2] &lt;&lt; <span class="stringliteral">&quot; ; &quot;</span> &lt;&lt; symAxes.at(axIt)[3] &lt;&lt; std::endl;</div>
<div class="line">       std::cout &lt;&lt; <span class="stringliteral">&quot; ... Angle (radians): &quot;</span> &lt;&lt; symAxes.at(axIt)[4] &lt;&lt; std::endl;</div>
<div class="line">       std::cout &lt;&lt; <span class="stringliteral">&quot; ... Axis peak:       &quot;</span> &lt;&lt; symAxes.at(axIt)[5] &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//================================================ Release the memory</span></div>
<div class="line">    <span class="keyword">delete</span> simpleSym;</div>
<div class="line">    <span class="keyword">delete</span> settings;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//================================================ Done</span></div>
<div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="pyusage"></a>
Using the Python modules</h1>
<p>ProSHADE also provides python2 and python3 modules which allow the same programmatical access to the ProSHADE tool as the dynamic C++ library. These modules are produced using the SWIG tool and contain all the functionality of the dynamic library. Furthermore, both the modules (the python2 and the python3 versions) support the Numpy arrays and do require it to be installed.</p>
<h2><a class="anchor" id="pyinstall"></a>
Python modules installation notes</h2>
<p>There are several caveats that the user should be aware of before using the python modules. This section will discuss these, but if there are any issues installing the modules, please contact the author.</p>
<p><b>Automatic</b> <b>installation</b> </p><ul>
<li>The python modules will be installed automatically as long as the CMake version on your system is version <b>3.1</b> or higher. Having this CMake version and missing any of the python specific dependencies (<em>SWIG</em>, <em>python</em>, <em>python3</em>, <em>Numpy</em>, ...) will cause build errors. If you do not want python modules installed, you can modify the CMakeLists.txt script, but this is recommended only for experienced CMake users.</li>
</ul>
<p><b>Python</b> <b>versions</b> </p><ul>
<li>The CMake installation scripts use the <em>which</em> <em>python</em> or <em>which</em> <em>python2</em> commands to detect the specific python2 interpreter version and the <em>which</em> <em>python3</em> command to detect the specific python3 version. The python library (libpython) appropriate for python version selected in this manner will then be used and linked against by the ProSHADE modules, which will then work only for this python interpreter. Therefore, if you are using multiple python versions, please make sure that the <em>which</em> command in the command line points to the required python version before installing ProSHADE.</li>
</ul>
<p><b>Module</b> <b>locations</b> </p><ul>
<li>The ProSHADE python modules will be installed into the correct <b>site-packages</b> folder for the selected python version if the CMake option -DINSTALL_LOCALLY=FALSE is used. If not, then the modules will be installed locally in the <b>install</b> folder in the ProSHADE folder cloned by git. If the latter is the case, then you will need to suppy your python interpreter with the path to the location of the module before you can import the module - this can be done by calling the <em>sys.path.append</em> function of the <em>sys</em> module. Please note that if the module import fails or ProSHADE gives segmentation error upon simple creation of the first ProSHADE object, then it is likely that the module was built for different python interpreter version.</li>
</ul>
<h2><a class="anchor" id="pyexamples"></a>
Python module examples</h2>
<p>Similarly to the ProSHADE dynamic library, the python code examples are available in the <b>/path/to/proshade/examples/python2</b> (or <b>python3</b> ) folders. The examples are basically identical between the python2 and python3 folders, so just review the examples for the version of python that you intend to use.</p>
<p><b>Simple</b> <b>access</b> </p>
<p>Similarly to the dynamic library case, there are three types of examples available for the python modules. The first set of examples (files named <em>simpleAccess_</em>... ) show the <em>black</em> <em>box</em> experience, which is similar to using ProSHADE binary. The user needs to create the <b><a class="el" href="class_pro_s_h_a_d_e__settings.html" title="This class stores all the settings and is passed to the executive classes instead of a multitude of p...">ProSHADE_settings</a></b> object and can then supply it with all the settings values which will then drive the ProSHADE computations. The same settings are available in the python modules as in the ProSHADE library; the example code below shows only a small selection of these (for full selection, please see the example files). Next, the user creates the <b><a class="el" href="class_pro_s_h_a_d_e__run.html" title="This class provides the access point to the library.">ProSHADE_run</a></b> object, constructor of which takes the settings object as its only argument and then proceeds to do all computations required by the settings in the settings object. The computations are done on this one line and if they take time, the execution of the script will be halted until ProSHADE is done computing. Once completed, the results can be retrieved from the <b><a class="el" href="class_pro_s_h_a_d_e__run.html" title="This class provides the access point to the library.">ProSHADE_run</a></b> object using the public accessor functions; the example code below shows how the symmetry functionality can be run and results retrieved.</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;&quot;&quot; Import the system modules &quot;&quot;&quot;</span></div>
<div class="line"><span class="keyword">import</span> sys</div>
<div class="line"><span class="keyword">import</span> numpy</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Import ProSHADE &quot;&quot;&quot;</span></div>
<div class="line">sys.path.append                               ( <span class="stringliteral">&quot;/path/to/proshade/install/python3&quot;</span> ) <span class="comment"># only needed if ProSHADE was installed locally</span></div>
<div class="line"><span class="keyword">import</span> proshade</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Create the ProSHADE_settings object &quot;&quot;&quot;</span></div>
<div class="line">pSet                                          = proshade.ProSHADE_settings ()</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Set the settings for Symmetry detection &quot;&quot;&quot;</span></div>
<div class="line"><span class="comment"># Required values</span></div>
<div class="line">pSet.task                                     = proshade.Symmetry                     <span class="comment"># The task ProSHADE is expected to perform</span></div>
<div class="line">pSet.verbose                                  = -1                                    <span class="comment"># How verbose should the run be? Use -1 for absolute silence.</span></div>
<div class="line">pSet.setResolution                            ( 8.0 )                                 <span class="comment"># The resolution to which computations are to be done.</span></div>
<div class="line">pSet.addStructure                             ( <span class="stringliteral">&quot;./C2.pdb&quot;</span> )                          <span class="comment"># The path to the structure to be processed.</span></div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Run the Symmetry task &quot;&quot;&quot;</span></div>
<div class="line">pRun                                          = proshade.ProSHADE_run ( pSet )        <span class="comment"># Do the computations. This takes most of the time.</span></div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Get the recommended symmetry &quot;&quot;&quot;</span></div>
<div class="line">detectedSymType                               = proshade.getDetectedSymmetryType ( pRun ) <span class="comment"># Retrieve the results. Takes minimum time as these are already computed</span></div>
<div class="line">detectedSymFold                               = proshade.getDetectedSymmetryFold ( pRun ) <span class="comment"># Retrieve the results. Takes minimum time as these are already computed</span></div>
<div class="line">detectedSymAxes                               = proshade.getDetectedSymmetryAxes ( pRun ) <span class="comment"># Retrieve the results. Takes minimum time as these are already computed</span></div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Print results &quot;&quot;&quot;</span></div>
<div class="line"><span class="keywordflow">print</span> ( <span class="stringliteral">&quot;Detected symmetry &quot;</span> + str( detectedSymType ) + <span class="stringliteral">&quot;-&quot;</span> + str( detectedSymFold ) + <span class="stringliteral">&quot; with axes: &quot;</span> )</div>
<div class="line"><span class="keywordflow">print</span> ( <span class="stringliteral">&quot;Fold      x         y         z       Angle     Height&quot;</span> )</div>
<div class="line"><span class="keywordflow">for</span> iter <span class="keywordflow">in</span> range ( 0, len( detectedSymAxes ) ):</div>
<div class="line">     <span class="keywordflow">print</span> ( <span class="stringliteral">&quot;  %s    %+1.3f    %+1.3f    %+1.3f    %+1.3f    %+1.4f&quot;</span> % ( detectedSymAxes[iter][0], detectedSymAxes[iter][1], detectedSymAxes[iter][2], detectedSymAxes[iter][3], detectedSymAxes[iter][4], detectedSymAxes[iter][5] ) )</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Delete the C++ pointers &quot;&quot;&quot;</span></div>
<div class="line">del pRun</div>
<div class="line">del pSet</div>
</div><!-- fragment --><p><b>Advanced</b> <b>access</b> </p>
<p>If the user needs more control over the ProSHADE exectution, or simply wants any behaviour not simply available by variables in the settings object, then there are the <em>advancedAccess_</em>... examples. These showcase the ability to call internal ProSHADE functions and by ordering them correctly, achieving the requested functionality. This usage of the python modules does required a better understanding the of the ProSHADE tool and the functions it implements. This documentation is a good starting point as to which functions are available and the <a class="el" href="_pro_s_h_a_d_e__tasks_8cpp.html" title="This source file contains the task functions, which drive the computation of a specific task.">ProSHADE_tasks.cpp</a> source file shows how the internal functions can be arranged to achieve the standard ProSHADE tasks. Please be aware that most of the functions do require that a pre-requisite function is run before it, but not all of these pre-requisites have their own warning or error messages. Therefore, if any code causes segmentation error (which usually kills the python interpreter), it is likely that you forgot to call some pre-requisite function.</p>
<p>The following code is an example of how this approach to the ProSHADE python module can be used to compute the shape-wise distances between two structures. After importing the required modules, the code creates the setings object and sets the basic settings (for a full list of settings, please see the example files). It then proceeds to create the <b>ProSHADE_data</b> objects for each structure, reads in the structures from files on the hard-drive (PDB and MAP formats are supported, the mmCIF should work as well). Next, the code processes in data - this is where map centering, masking, normalisation, axis inversion, etc. happens - onto an internal ProSHADE data representation. This representation can then be mapped onto a set of concentric spheres, which can in turn have their spherical harmonics decomposition computed. Once this is done, the shape distances can be computed using the three functions shown.</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;&quot;&quot; Import the system modules &quot;&quot;&quot;</span></div>
<div class="line"><span class="keyword">import</span> sys</div>
<div class="line"><span class="keyword">import</span> numpy</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Import ProSHADE &quot;&quot;&quot;</span></div>
<div class="line">sys.path.append                               ( <span class="stringliteral">&quot;/path/to/proshade/install/python3&quot;</span> ) <span class="comment"># only needed if ProSHADE was installed locally</span></div>
<div class="line"><span class="keyword">import</span> proshade</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Create the ProSHADE_settings object &quot;&quot;&quot;</span></div>
<div class="line">pSet                                          = proshade.ProSHADE_settings ()</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Set the settings for Distances detection &quot;&quot;&quot;</span></div>
<div class="line">pSet.task                                     = proshade.Distances</div>
<div class="line">pSet.verbose                                  = 1</div>
<div class="line">pSet.setResolution                            ( 6.0 )</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Create the structure objects &quot;&quot;&quot;</span></div>
<div class="line">pStruct1                                      = proshade.ProSHADE_data ( pSet )</div>
<div class="line">pStruct2                                      = proshade.ProSHADE_data ( pSet )</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Read in the structure &quot;&quot;&quot;</span></div>
<div class="line">pStruct1.readInStructure                      ( <span class="stringliteral">&quot;./C2.pdb&quot;</span>, 0, pSet )</div>
<div class="line">pStruct2.readInStructure                      ( <span class="stringliteral">&quot;./testMap.map&quot;</span>, 1, pSet )</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Process maps into internal representations &quot;&quot;&quot;</span></div>
<div class="line">pStruct1.processInternalMap                   ( pSet )</div>
<div class="line">pStruct2.processInternalMap                   ( pSet )</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Map internal representations to spheres &quot;&quot;&quot;</span></div>
<div class="line">pStruct1.mapToSpheres                         ( pSet )</div>
<div class="line">pStruct2.mapToSpheres                         ( pSet )</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Compute spherical harmonics of the mapped data &quot;&quot;&quot;</span></div>
<div class="line">pStruct1.computeSphericalHarmonics            ( pSet )</div>
<div class="line">pStruct2.computeSphericalHarmonics            ( pSet )</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Get the results &quot;&quot;&quot;</span></div>
<div class="line">energyLevelsDescriptor                        = proshade.computeEnergyLevelsDescriptor    ( pStruct1, pStruct2, pSet )</div>
<div class="line">traceSigmaDescriptor                          = proshade.computeTraceSigmaDescriptor      ( pStruct1, pStruct2, pSet )</div>
<div class="line">fullRotationFunctionDescriptor                = proshade.computeRotationunctionDescriptor ( pStruct1, pStruct2, pSet )</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Print the results &quot;&quot;&quot;</span></div>
<div class="line"><span class="keywordflow">print</span> ( <span class="stringliteral">&quot;The energy levels distance is          %+1.3f&quot;</span> % ( energyLevelsDescriptor ) )</div>
<div class="line"><span class="keywordflow">print</span> ( <span class="stringliteral">&quot;The trace sigma distance is            %+1.3f&quot;</span> % ( traceSigmaDescriptor ) )</div>
<div class="line"><span class="keywordflow">print</span> ( <span class="stringliteral">&quot;The rotation function distance is      %+1.3f&quot;</span> % ( fullRotationFunctionDescriptor ) )</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Delete the C++ pointers &quot;&quot;&quot;</span></div>
<div class="line">del pStruct1</div>
<div class="line">del pStruct2</div>
<div class="line">del pSet</div>
</div><!-- fragment --><p>One of the advantages of this mode of operating the ProSHADE python modules is that the execution only takes the time required to compute the specific computation the function requires and therefore if the user only needs some preliminary results, or can prepare the data for execution later, this is all allowed by this mode.</p>
<p><b>Direct</b> <b>access</b> </p>
<p>This is the most advanced mode of using the ProSHADE tool, as it allows direct access into the internal ProSHADE working. This in turn allows supplying non-standard values as well as retrieving any partial results for alternative processing by a different code; however, it also requires the deepest understanding of how ProSHADE works, what data are available at which point in the execution and it may require some data format manipulations on the side of the executing code. The following tutorial as well as this documentation should be a good starting point as well as the <b>directAccess.py</b> file.</p>
<p>In order to showcase this approach, we will import the required modules:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;&quot;&quot; Import the system modules &quot;&quot;&quot;</span></div>
<div class="line"><span class="keyword">import</span> sys</div>
<div class="line"><span class="keyword">import</span> numpy</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Import ProSHADE &quot;&quot;&quot;</span></div>
<div class="line">sys.path.append                               ( <span class="stringliteral">&quot;/path/to/proshade/install/python3&quot;</span> ) <span class="comment"># only needed if ProSHADE was installed locally</span></div>
<div class="line"><span class="keyword">import</span> proshade</div>
</div><!-- fragment --><p><em>Reading</em> <em>a</em> <em>structure</em> <em>from</em> <em>file</em> </p>
<p>The first step of most ProSHADE workflows will be reading a structure (be it co-ordinates or map) from a file on the hard-drive. This can be done in the same manner as shown in the <b>advanced</b> <b>access</b> section of this tutorial, that is: Firstly we create the <b><a class="el" href="class_pro_s_h_a_d_e__settings.html" title="This class stores all the settings and is passed to the executive classes instead of a multitude of p...">ProSHADE_settings</a></b> object, which needs to be filled with the initial data. It does not really matter which task you select at this stage, but it may affect some of the default values and therefore it is recommended to use the correct taks. Next, the <b>ProSHADE_data</b> object is created and finally the structure is read in. Please note that on some systems using relative paths may not work and it may result in ProSHADE error stating that the file type cannot be recognised. If this is the case, please use the full path.</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;&quot;&quot; Create the ProSHADE_settings object &quot;&quot;&quot;</span></div>
<div class="line">pSet                                          = proshade.ProSHADE_settings ()</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Set the settings for Distances detection &quot;&quot;&quot;</span></div>
<div class="line">pSet.task                                     = proshade.Distances</div>
<div class="line">pSet.verbose                                  = 1</div>
<div class="line">pSet.setResolution                            ( 6.0 )</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Create the structure objects &quot;&quot;&quot;</span></div>
<div class="line">pStruct1                                      = proshade.ProSHADE_data ( pSet )</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Read in the structure &quot;&quot;&quot;</span></div>
<div class="line">pStruct1.readInStructure                      ( <span class="stringliteral">&quot;./C2.pdb&quot;</span>, 0, pSet )</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Delete the structure as we will proceed with a different object created later &quot;&quot;&quot;</span></div>
<div class="line">del pStruct1</div>
</div><!-- fragment --><p><em>Creating</em> <em>ProSHADE_data</em> <em>object</em> <em>from</em> <em>map</em> </p>
<p>Alteratively, <b>ProSHADE_data</b> object can be created from an already existing map and some of the basic map information data. As an example, we will create a 1D numpy.array, which will hold the density values of a map that we would like to supply to ProSHADE. Of course this array can be the result of any other python module, the only requirement is that the data type is 1D numpy.array with the XYZ axis order.</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;&quot;&quot; Set the density map description values &quot;&quot;&quot;</span></div>
<div class="line">xDimIndices                                   = 100                          <span class="comment"># Number of indices along the x-axis.</span></div>
<div class="line">yDimIndices                                   = 120                          <span class="comment"># Number of indices along the y-axis.</span></div>
<div class="line">zDimIndices                                   = 60                           <span class="comment"># Number of indices along the z-axis.</span></div>
<div class="line">xDimAngstroms                                 = xDimIndices * 1.3            <span class="comment"># X-axis size in Angstroms.</span></div>
<div class="line">yDimAngstroms                                 = yDimIndices * 1.3            <span class="comment"># Y-axis size in Angstroms.</span></div>
<div class="line">zDimAngstroms                                 = zDimIndices * 1.3            <span class="comment"># Z-axis size in Angstroms.</span></div>
<div class="line">xFrom                                         = int ( -xDimIndices/2 )       <span class="comment"># Starting index of the x-axis.</span></div>
<div class="line">yFrom                                         = int ( -yDimIndices/2 )       <span class="comment"># Starting index of the y-axis.</span></div>
<div class="line">zFrom                                         = int ( -zDimIndices/2 )       <span class="comment"># Starting index of the z-axis.</span></div>
<div class="line">xTo                                           = int ( (xDimIndices/2)-1 )    <span class="comment"># Last index of the x-axis.</span></div>
<div class="line">yTo                                           = int ( (yDimIndices/2)-1 )    <span class="comment"># Last index of the y-axis.</span></div>
<div class="line">zTo                                           = int ( (zDimIndices/2)-1 )    <span class="comment"># Last index of the z-axis.</span></div>
<div class="line">ord                                           = 0                            <span class="comment"># The order of the MAP file (the binary writting style, leave 0 unless you strongly prefer different type).</span></div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Create an example map (this will be a ball in the middle of the map) &quot;&quot;&quot;</span></div>
<div class="line">testMap = numpy.empty ( [ ( xDimIndices * yDimIndices * zDimIndices ) ] )</div>
<div class="line"><span class="keywordflow">for</span> xIt <span class="keywordflow">in</span> range( 0, xDimIndices ):</div>
<div class="line">    <span class="keywordflow">for</span> yIt <span class="keywordflow">in</span> range( 0, yDimIndices ):</div>
<div class="line">        <span class="keywordflow">for</span> zIt <span class="keywordflow">in</span> range( 0, zDimIndices ):</div>
<div class="line">            <span class="stringliteral">&quot;&quot;&quot; Compute the 1D array index &quot;&quot;&quot;</span></div>
<div class="line">            ind                               = zIt + zDimIndices * ( yIt + yDimIndices * xIt )</div>
<div class="line"> </div>
<div class="line">            <span class="stringliteral">&quot;&quot;&quot; Save density value for this point &quot;&quot;&quot;</span></div>
<div class="line">            testMap[ind]                      = 1.0 / ( numpy.sqrt( numpy.power ( (xDimIndices/2) - xIt, 2.0 ) +</div>
<div class="line">                                                                    numpy.power ( (yDimIndices/2) - yIt, 2.0 ) +</div>
<div class="line">                                                                    numpy.power ( (zDimIndices/2) - zIt, 2.0 ) ) + 0.01 )</div>
</div><!-- fragment --><p>with an example map created as an 1D numpy.array, it can now be supplied to a <b>ProSHADE_data</b> object, which will then be in the same state as if the data were read in from a file. This can be done with the following call:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;&quot;&quot; Create ProSHADE_data object from numpy.array &quot;&quot;&quot;</span></div>
<div class="line">pStruct                                       = proshade.ProSHADE_data ( pSet,                <span class="comment"># The settings object</span></div>
<div class="line">                                                                         <span class="stringliteral">&quot;python_map_test&quot;</span>,   <span class="comment"># The map title</span></div>
<div class="line">                                                                         testMap,             <span class="comment"># The numpy.array object</span></div>
<div class="line">                                                                         xDimAngstroms,       <span class="comment"># The size of x-axis in Angstroms</span></div>
<div class="line">                                                                         yDimAngstroms,       <span class="comment"># The size of y-axis in Angstroms</span></div>
<div class="line">                                                                         zDimAngstroms,       <span class="comment"># The size of z-axis in Angstroms</span></div>
<div class="line">                                                                         xDimIndices,         <span class="comment"># The number of indices along the x-axis</span></div>
<div class="line">                                                                         yDimIndices,         <span class="comment"># The number of indices along the y-axis</span></div>
<div class="line">                                                                         zDimIndices,         <span class="comment"># The number of indices along the z-axis</span></div>
<div class="line">                                                                         xFrom,               <span class="comment"># The starting x-axis index</span></div>
<div class="line">                                                                         yFrom,               <span class="comment"># The starting y-axis index</span></div>
<div class="line">                                                                         zFrom,               <span class="comment"># The starting z-axis index</span></div>
<div class="line">                                                                         xTo,                 <span class="comment"># The last x-axis index</span></div>
<div class="line">                                                                         yTo,                 <span class="comment"># The last y-axis index</span></div>
<div class="line">                                                                         zTo,                 <span class="comment"># The last z-axis index</span></div>
<div class="line">                                                                         ord )                <span class="comment"># The map file binary order</span></div>
</div><!-- fragment --><p>There are several assumption that the <b>ProSHADE_data</b> constructor shown above makes and not all of these are currently checked with a warning or error message. Some of these are described in the <b>directAccess.py</b> file, but the most common things to consider are the following:</p><ul>
<li>The constructor assumes that the angles between all three axes are 90 degrees. If this is not the case, it is the users responsibility to transform and re-sample the map before submitting it to ProSHADE (support for non-orthogonal maps is on the TODO list).</li>
<li>The map dimensions needs to be the same as the x/y/zDimIndices variables.</li>
<li>The following equality should hold: x/y/zTo - x/y/zFrom + 1 = x/y/zDimIndices.</li>
<li>The constructor assumes that axis grids are equal to indices and that the origins are equal to the starting indices of each axis.</li>
<li>The axis order is XYZ</li>
</ul>
<p>If some of these assumptions do not hold, the <b>ProSHADE_data</b> object is likely to still be created, but it is the users responsibility to change the <b>pStruct</b> (ProSHADE_data) object internal variables to reflect the reality or face the consequences.</p>
<p><em>3D</em> <em>arrays</em> </p>
<p>It is possible that instead of 1D arrays as shown above, some other python module would work with maps using 3D arrays. This poses an issue for ProSHADE, as it is pythonised using SWIG and Numpy.i typedefs, which apparently do not support passing of 3D arrays between the two languages. To bridge this issue, ProSHADE provides a function called <em>convert3Dto1DArray()</em>, which can be used to convert standard 3D numpy.arrays to ProSHADE compatible 1D numpy.arrays. However, as python seems to have problems with multiple for loops, this function may be time consuming compared to other much more complex functions. Nonetheless, the following code will create a different <b>ProSHADE_data</b> object from a 3D numpy.array using the conversion function. It will also delete this object, as the example here will continue with the <b>pStruct</b> object created before.</p>
<div class="fragment"><div class="line">testMap3D = numpy.empty ( ( xDimIndices, yDimIndices, zDimIndices ) )</div>
<div class="line"><span class="keywordflow">for</span> xIt <span class="keywordflow">in</span> range( 0, xDimIndices ):</div>
<div class="line">    <span class="keywordflow">for</span> yIt <span class="keywordflow">in</span> range( 0, yDimIndices ):</div>
<div class="line">        <span class="keywordflow">for</span> zIt <span class="keywordflow">in</span> range( 0, zDimIndices ):</div>
<div class="line">            testMap3D[xIt][yIt][zIt] = 1.0 / ( numpy.sqrt( numpy.power ( (xDimIndices/2) - xIt, 2.0 ) +</div>
<div class="line">                                                           numpy.power ( (yDimIndices/2) - yIt, 2.0 ) +</div>
<div class="line">                                                           numpy.power ( (zDimIndices/2) - zIt, 2.0 ) ) + 0.01 )</div>
<div class="line"> </div>
<div class="line">pStruct2                                      = proshade.ProSHADE_data ( pSet,</div>
<div class="line">                                                                         <span class="stringliteral">&quot;python_map_test&quot;</span>,</div>
<div class="line">                                                                         proshade.convert3Dto1DArray ( testMap3D ),</div>
<div class="line">                                                                         xDimAngstroms,</div>
<div class="line">                                                                         yDimAngstroms,</div>
<div class="line">                                                                         zDimAngstroms,</div>
<div class="line">                                                                         xDimIndices,</div>
<div class="line">                                                                         yDimIndices,</div>
<div class="line">                                                                         zDimIndices,</div>
<div class="line">                                                                         xFrom,</div>
<div class="line">                                                                         yFrom,</div>
<div class="line">                                                                         zFrom,</div>
<div class="line">                                                                         xTo,</div>
<div class="line">                                                                         yTo,</div>
<div class="line">                                                                         zTo,</div>
<div class="line">                                                                         ord )</div>
<div class="line"> </div>
<div class="line">del pStruct2</div>
</div><!-- fragment --><p><em>Writing</em> <em>out</em> <em>maps</em> </p>
<p>Now, it is possible to write out the internal map representation at any point since the <b>ProSHADE_data</b> object has been filled in. To demonstrate this functionality, it is immediately possible to issue the following command, which will write an <b>initialMap.map</b> file onto the hard-drive.</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;&quot;&quot; Write out the initial map &quot;&quot;&quot;</span></div>
<div class="line">pStruct.writeMap                              ( <span class="stringliteral">&quot;initialMap.map&quot;</span> )</div>
</div><!-- fragment --><p><em>Getting</em> <em>back</em> <em>the</em> <em>ProSHADE</em> <em>internal</em> <em>representation</em> <em>map</em> </p>
<p>Here, we will demonstrate how the user can access the ProSHADE internal representation map from the <b>ProSHADE_data</b> object. Please note that this is not limitted to the initial map, this will work for any <b>ProSHADE_data</b> object which has map data in any stage of ProSHADE computations. The user has a choice between a 1D and 3D numpy array maps being returned by ProSHADE; the indexing of the 1D map is the same as above, that is [ z + pStruct.zDimIndices * ( y + pStruct.yDimIndices * x ) ]. Please note that there is the issue with 3D maps and therefore getting a 3D map may be slower (approximately 0.5 seconds per average sized map) as compared to getting a 1D map. The following code shows how the maps can be retrieved back to python:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;&quot;&quot; Get back the ProSHADE internal map representation &quot;&quot;&quot;</span></div>
<div class="line">initialMapArray1D                             = proshade.getMapPython1D ( pStruct )</div>
<div class="line">initialMapArray3D                             = proshade.getMapPython3D ( pStruct )</div>
</div><!-- fragment --><p><em>Changing</em> <em>the</em> <em>already</em> <em>supplied</em> <em>map</em> </p>
<p>A situation may also occur, where the already loaded map needs to be processed, for example, if you want to read in a map file, but then you want to remove some part of the map using algorithm not available in ProSHADE or in the case where you want to apply some ProSHADE processing, then do some more processing with algorithms not available in ProSHADE and then return to ProSHADE for some more calculations. To do this, ProSHADE allows you to modify the retrieved (or any other) map in any way; in the following example we will remove the last 3 indices along the y-axis dimension and divide (or multiply) all density values by 2. Next, it is now the users responsibility to modify the ProSHADE object to reflect the new size and position of the map and finally, the new map can be pushed into ProSHADE using the <em>setNewMapPythonXD()</em>) functions (where X can be 1 or 3). The following example shows how this can be done for both, the 1D and the 3D maps.</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;&quot;&quot; Create a new map arrays with the y-dimension decreased by 3 indices &quot;&quot;&quot;</span></div>
<div class="line">newMapArr1D                                   = numpy.empty ( ( pStruct.xDimIndices * ( pStruct.yDimIndices - 3 ) * pStruct.zDimIndices ) )</div>
<div class="line">newMapArr3D                                   = numpy.empty ( [ pStruct.xDimIndices,  ( pStruct.yDimIndices - 3 ),  pStruct.zDimIndices ] )</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Fill in the new arrays using the previously obtained ProSHADE internal maps &quot;&quot;&quot;</span></div>
<div class="line"><span class="keywordflow">for</span> xIt <span class="keywordflow">in</span> range( 0, pStruct.xDimIndices ):</div>
<div class="line">    <span class="keywordflow">for</span> yIt <span class="keywordflow">in</span> range( 0, pStruct.yDimIndices ):</div>
<div class="line">        <span class="keywordflow">for</span> zIt <span class="keywordflow">in</span> range( 0, pStruct.zDimIndices ):</div>
<div class="line">            <span class="keywordflow">if</span> yIt &gt;= ( pStruct.yDimIndices - 3 ):</div>
<div class="line">                <span class="keywordflow">continue</span></div>
<div class="line">            arrPos                            = zIt + pStruct.zDimIndices * ( yIt  + pStruct.yDimIndices * xIt );</div>
<div class="line">            newMapPos                         = zIt + pStruct.zDimIndices * ( yIt  + (pStruct.yDimIndices-3) * xIt );</div>
<div class="line">            newMapArr1D[newMapPos]            = initialMapArray1D[arrPos] * 2</div>
<div class="line">            newMapArr3D[xIt][yIt][zIt]        = initialMapArray1D[arrPos] / 2</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Now change the ProSHADE_data structure to reflect the new map &quot;&quot;&quot;</span></div>
<div class="line">pStruct.yDimSize                              = pStruct.yDimSize - ( ( pStruct.yDimSize / pStruct.yDimIndices ) * 3 )</div>
<div class="line">pStruct.yDimIndices                           = pStruct.yDimIndices - 3</div>
<div class="line">pStruct.yGridIndices                          = pStruct.yDimIndices</div>
<div class="line">pStruct.yTo                                   = pStruct.yTo - 3</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; And now force ProSHADE to change the internal map &quot;&quot;&quot;</span></div>
<div class="line">proshade.setNewMapPython1D                    ( pStruct, newMapArr1D )</div>
<div class="line">proshade.setNewMapPython3D                    ( pStruct, newMapArr3D )</div>
</div><!-- fragment --><p><em>Initial</em> <em>map</em> <em>procesing</em> </p>
<p>Once the map is read into the <b>ProSHADE_data</b> object, it needs to be processed in order to make sure ProSHADE will be able to use it for any further computations. While processing, ProSHADE offers the following map modifications through the <b>ProSHADE_setting</b> object variables: map invertion (this will invert the map indices along each dimension), map normalisation (making the map density values mean 0 and standard deviation 1), map masking (computing a map mask by blurring and then setting mask as all values above threshold), map centering (moving the map into the centre of mass), adding extra space (in case the map density is close to map edge, what can lead to map artefacts and lower accuracy of further processing) and map phase removal (removing the phase of the map density, effectively producing Patterson maps). The user can chose any, all or none of these, but the processing function needs to be called before any further processing is possible. The following example code showcases how some of the processing functionalities can be chosen and how the map can be processed.</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;&quot;&quot; Set which processing should be done &quot;&quot;&quot;</span></div>
<div class="line">pSet.setMapInversion                          ( <span class="keyword">False</span> )  <span class="comment"># Should all map positions x,y,z be swapped to -x,-y,-z? Use this only if your helices have the wrong hand ...</span></div>
<div class="line">pSet.setNormalisation                         ( <span class="keyword">False</span> )  <span class="comment"># Should internal map representation be normalised to mean 0 and standard deviation 1?</span></div>
<div class="line">pSet.setMasking                               ( <span class="keyword">False</span> )  <span class="comment"># Should maps be masked by blurring?</span></div>
<div class="line">pSet.setMapCentering                          ( <span class="keyword">False</span> )  <span class="comment"># Move structure COM to the centre of map box?</span></div>
<div class="line">pSet.setExtraSpace                            ( 10.0 )   <span class="comment"># Extra space in Angs to be added when creating internap map representation.</span></div>
<div class="line">pSet.setPhaseUsage                            ( <span class="keyword">True</span> )   <span class="comment"># Use full maps, or Patterson-like maps?</span></div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Process the internal map representation &quot;&quot;&quot;</span></div>
<div class="line">pStruct.processInternalMap                    ( pSet )</div>
</div><!-- fragment --><p><em>Computing</em> <em>standard</em> <em>ProSHADE</em> <em>tasks</em> </p>
<p>If the user now wants to use ProSHADE to compute some of the standard ProSHADE taks, <em>i.e</em>. Distances computation, Symmetry detection, Re-boxing or Map overlay, it is recommended that the user proceeds in the same fashion as shown in the the <em>advancedAccess_</em>... example files. Moreover, these are also demonstrated in the <b>directAccess.py</b> file available in the examples folder. Therefore, none of these tasks will be shown here in a step-wise manner; instead, the rest of this tutorial will focus on how partial information and results can be obtained from ProSHADE, should the user want to use them in a way that is not currently supported by ProSHADE.</p>
<p><em>Computing</em> <em>the</em> <em>spherical</em> <em>harmonics</em> <em>decomposition</em> </p>
<p>ProSHADE can compute the spherical harmonics decomposition of the internal map. However, instead of using the spherical-Bessel functions, it firstly creates a set of concentric spheres centered on the centre of indices (xDimIndices/2, yDimIndices/2, zDimIndices/2) point and spaced 2 indices apart, then it maps the density map data onto these spheres and then it computes the spherical harmonics decomposition on each of these spheres independently. There is quite a few settings that relate to the spherical harmonics decompostion computation, such as the bandwidth of the computation, the sphere placement and spacing, the resolution on the spheres, etc.; these arre mostly inter-related and ProSHADE will set them up automatically, unless the user specifies otherwise. Since these are quite technical, the interested users are referred to the second chapter of my Ph.D. thesis, which specifies all the technical details: <a href="https://www.repository.cam.ac.uk/handle/1810/284410">https://www.repository.cam.ac.uk/handle/1810/284410</a> . To issue this computation, please use the functions shown in the following example code:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;&quot;&quot; Map the internal map representation onto a set of concentric spheres &quot;&quot;&quot;</span></div>
<div class="line">pStruct.mapToSpheres                          ( pSet )</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Compute the spherical harmonics decomposition &quot;&quot;&quot;</span></div>
<div class="line">pStruct.computeSphericalHarmonics             ( pSet )</div>
</div><!-- fragment --><p>If the user is interested in the spherical harmonics values (and possibly does not need any further computations from ProSHADE), these can be accessed using the function showcased below. It is worth noting that the organisation of the spherical harmonics is as follows: Each concentric shell has a two dimensional array of values, where the row is the spherical harmonics band, while the column is the spherical harmonics order. Please note that there are only 2 * band + 1 orders for each band and therefore the array is not rectangular. Instead, it is recommended that the users take advantage of the supplied <em>sphericalHarmonicsIndex()</em> function, which takes the order, the band and the shell number as its arguments (in this order) and returns the index of the spherical harmonics value in the retrieved spherical harmonics array. Moreover, please note that the spherical harmonics are complex numbers.</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;&quot;&quot; Obtain all the spherical harmonics values for all shells &quot;&quot;&quot;</span></div>
<div class="line">sphericalHarmonics                            = proshade.getSphericalHarmonics ( pStruct )</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Retrieve s specific value for shell 3, band 4 and order -2 &quot;&quot;&quot;</span></div>
<div class="line">Shell3Band4OrderMin2Value                     = sphericalHarmonics[3][ pStruct.sphericalHarmonicsIndex ( -2, 4, 3 ) ] <span class="comment"># Order -2, band 4, shell 3.</span></div>
</div><!-- fragment --><p><em>Computing</em> <em>the</em> <em>self-rotation</em> <em>function</em> </p>
<p>ProSHADE also allows computing the self-rotation function. More specifically, it firstly computes the so called E matrices, which are matrices of the integral over all the concentric spheres of the spherical harmonics coefficients of order1 and order2, or in mathematical (LaTeX) form: Integral _0 ^rMAX ( c^lm * c'^lm ). It then proceeds to normalise these E matrices, resulting in the SO(3) decomposition (Wigner D based decomposition) coefficients. Finally, by computing the inverse SO(3) Fourier transform (SOFT) on these coefficients, ProSHADE obtains the self-rotation function. In order to isue this computaion, the following code can be used:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;&quot;&quot; Compute the self-rotation function &quot;&quot;&quot;</span></div>
<div class="line">pStruct.getRotationFunction                   ( pSet )</div>
</div><!-- fragment --><p>Once the self-rotation function is computed, ProSHADE allows the user to access all of its interim results as well as the rotation function map. Specifically the E matrices, which are ordered by the band, order1 and order2 (in this order) can be obtained as shown in the following code. The E matrices are 3D arrays, which suffer from the different number of orders for different bands feature of spherical harmonics. Therefore, the band dimensions of the arrays are zero padded; furthermore, as the order indexing goes from -band to +band, but the array indexing starts from zero, the correction to the array indexes is necessary. Regarding the SO(3) coefficients, they have the same technical structure as the E matrices; however, due to some development issues, accessing them is done in a different manner, using the <em>so3CoeffsArrayIndex()</em> function as shown in the example code below. Finally, the self-rotation function map can be accessed as a 1D or 3D numpy.array using the functions shown in the example code below. Again, as passing 3D matrices is not possible using SWIG and Numpy.i typedefs, the 3D version of the function is much slower than the 1D version. Assuming the user would find a point in the map for which he would like to know the rotation matrix (the indices of the self-rotation function are related to the Euler angles in a non-trivial manner), ProSHADE provides the <em>getRotationMatrixFromRotFunIndices()</em> function also shown in the following example code. This function returns the rotation matrix belonging to the given self-rotation function indices in a numpy.array format.</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;&quot;&quot; Obtain the E matrices &quot;&quot;&quot;</span></div>
<div class="line">eMat                                          = proshade.getEMatrix ( pStruct )</div>
<div class="line">Band4OrderOneMin2OrderTwo3EMatrixValue        = eMat[4][-2+4][3+4] <span class="comment"># Band = 4, Order1 = -2 and Order2 = 3</span></div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Obtain the SO(3) coefficients &quot;&quot;&quot;</span></div>
<div class="line">so3Coeffs                                     = proshade.getSO3Coeffs( pStruct )</div>
<div class="line">so3CoeffsOrderOneMin1OrderTwo3Band5           = so3Coeffs[pStruct.so3CoeffsArrayIndex ( -1, 3, 5 )] <span class="comment"># Order1 = -1; Order2 = 3, Band = 5</span></div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Obtain the self-rotation function &quot;&quot;&quot;</span></div>
<div class="line">selfRotationFunction1D                        = proshade.getRotationFunction1D ( pStruct )</div>
<div class="line">selfRotationFunction3D                        = proshade.getRotationFunction3D ( pStruct )</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Convert self-rotation function indices to rotation matrix &quot;&quot;&quot;</span></div>
<div class="line">rotMat                                        = proshade.getRotationMatrixFromRotFunIndices ( pStruct, 10, 11, 7 )</div>
</div><!-- fragment --><p><em>Computing</em> <em>the</em> <em>optimal</em> <em>rotation</em> <em>function</em> </p>
<p>A related ProSHADE functionality is the computation of an optimal rotation function for two input structures. In the standard ProSHADE tasks, this is done for two phase-less structure maps (the phase is removed to achive identical centering on the maps) in order to find the optimal rotation, which overlays the two maps, but the user is free to call this function for any two <b>ProSHADE_data</b> objects which both have their spherical harmonics values computed. To do this, we will create two new <b>ProSHADE_data</b> objects, read in some structures, process them, map them onto spheres, compute their spherical harmonics values and then we call the <em>getOverlayRotationFunction()</em>. This function works similarly to the <em>getRotationFunction()</em> used above, but it uses spherical harmonics coefficients from two different structures as opposed to the same structures.</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;&quot;&quot; Modify the settings object for optimal rotation function computation &quot;&quot;&quot;</span></div>
<div class="line">pSet.task                                     = proshade.OverlayMap</div>
<div class="line">pSet.verbose                                  = 1</div>
<div class="line">pSet.requestedResolution                      = 8.0;</div>
<div class="line">pSet.usePhase                                 = <span class="keyword">False</span>;</div>
<div class="line">pSet.changeMapResolution                      = <span class="keyword">True</span>;</div>
<div class="line">pSet.maskMap                                  = <span class="keyword">False</span>;</div>
<div class="line">pSet.moveToCOM                                = <span class="keyword">False</span>;</div>
<div class="line">pSet.normaliseMap                             = <span class="keyword">False</span>;</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Create the two new ProSHADE_data objects &quot;&quot;&quot;</span></div>
<div class="line">pStruct_static                                = proshade.ProSHADE_data ( pSet )</div>
<div class="line">pStruct_moving                                = proshade.ProSHADE_data ( pSet )</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Read in two structures &quot;&quot;&quot;</span></div>
<div class="line">pStruct_static.readInStructure                ( <span class="stringliteral">&quot;./test1_rotTrs.map&quot;</span>, 0, pSet )</div>
<div class="line">pStruct_moving.readInStructure                ( <span class="stringliteral">&quot;./test1.pdb&quot;</span>, 1, pSet )</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Process, map and get spherical harmonics for both structures &quot;&quot;&quot;</span></div>
<div class="line">pStruct_static.processInternalMap             ( pSet )</div>
<div class="line">pStruct_moving.processInternalMap             ( pSet )</div>
<div class="line"> </div>
<div class="line">pStruct_static.mapToSpheres                   ( pSet )</div>
<div class="line">pStruct_moving.mapToSpheres                   ( pSet )</div>
<div class="line"> </div>
<div class="line">pStruct_static.computeSphericalHarmonics      ( pSet )</div>
<div class="line">pStruct_moving.computeSphericalHarmonics      ( pSet )</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Compute the optimal rotation function &quot;&quot;&quot;</span></div>
<div class="line">pStruct_moving.getOverlayRotationFunction     ( pSet, pStruct_static )</div>
</div><!-- fragment --><p>Now, in order to access the optimal rotation function, the user can use the same functions as for accessing the self-rotation function above, <em>i.e</em>. the <em>getRotationFunction1D()</em> and the <em>getRotationFunction3D()</em> functions, both with the moving structure as their only argument. Moreover, the same function for converting the rotation function indices to the appropriate rotation matrix can also be used as shown in the following example code.</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;&quot;&quot; Obtain the self-rotation function &quot;&quot;&quot;</span></div>
<div class="line">rotationFunction1D                            = proshade.getRotationFunction1D ( pStruct_moving )</div>
<div class="line">rotationFunction3D                            = proshade.getRotationFunction3D ( pStruct_moving )</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Convert self-rotation function indices to rotation matrix &quot;&quot;&quot;</span></div>
<div class="line">rotMat                                        = proshade.getRotationMatrixFromRotFunIndices ( pStruct_moving, 10, 11, 7 )</div>
</div><!-- fragment --><p><em>Finding</em> <em>the</em> <em>optimal</em> <em>rotation</em> </p>
<p>Once the optimal rotation map is computed, the user may be interested in the highest value in the map and the corresponding rotation matrix (or Euler angles), as these will represent the rotation which overlays most of the two structures (within the error of the map sampling). To facilitate this taks, ProSHADE contains the <em>getBestRotationMapPeaksEulerAngles()</em> function, which finds the highest peak in the map and returns the associated Euler angles. The following example code demonstrates how to use this function as well as how to obtain the the rotation matrix from the Euler angles using ProSHADE.</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;&quot;&quot; Find the highest peak in the map, associated Euler angles and rotation matrix &quot;&quot;&quot;</span></div>
<div class="line">optimalRotationAngles                         = pStruct_moving.getBestRotationMapPeaksEulerAngles ( pSet )</div>
<div class="line">optimalRotationMatrix                         = proshade.getRotationMatrixFromEulerZXZ ( optimalRotationAngles )</div>
</div><!-- fragment --><p><em>Rotating</em> <em>the</em> <em>internal</em> <em>map</em> <em>representation</em> </p>
<p>Once the optimal rotation angles are obtained, it is the next logical step to rotate the structure by these angles to get the two structures in identical orientation. This can also be done with ProSHADE function <em>rotateMap()</em>, which works with the Euler angles as reported by ProSHADE. The rotation is done using the spherical harmonics coefficients, which are multiplied by the Wigner D matrices for the required rotation and the resulting rotated coefficients are then inverted back and interpolated to a new map. This process has two side effects: Firstly, the resulting maps tend to suffer from minor artefacts resulting from the sequence termination errors and the interpolation to and from spheres to cartesian co-ordinates. And secondly, the input maps need to have their spherical harmonics coefficients computed. Therefore, this approach is not recommended for any maps that are to be deposited or fitted into, but they are sufficient for computation of most ProSHADE standard tasks as the shape is largely identical.</p>
<p>In terms of this tutorial, since we have already computed the optimal rotation between two structures, we will continue to show how this result can be used to rotate a new structure. This will allow us to demonstrate the next functionality of ProSHADE in the later sections of this tutorial in a more streamlined fashion. To cause <b>ProSHADE_data</b> map rotation, the function in the example code can be used.</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;&quot;&quot; Delete the old structure objects so that new can be created &quot;&quot;&quot;</span></div>
<div class="line">del pStruct_static</div>
<div class="line">del pStruct_moving</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Change the settings to use phased maps &quot;&quot;&quot;</span></div>
<div class="line">pSet.usePhase                                 = <span class="keyword">True</span></div>
<div class="line">pSet.changeMapResolution                      = <span class="keyword">True</span></div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Create the two new ProSHADE_data objects &quot;&quot;&quot;</span></div>
<div class="line">pStruct_static                                = proshade.ProSHADE_data ( pSet )</div>
<div class="line">pStruct_moving                                = proshade.ProSHADE_data ( pSet )</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Read in two structures &quot;&quot;&quot;</span></div>
<div class="line">pStruct_static.readInStructure                ( <span class="stringliteral">&quot;./test1_rotTrs.map&quot;</span>, 0, pSet )</div>
<div class="line">pStruct_moving.readInStructure                ( <span class="stringliteral">&quot;./test1.pdb&quot;</span>, 1, pSet )</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Process the static structure to allow further examples &quot;&quot;&quot;</span></div>
<div class="line">pStruct_static.processInternalMap             ( pSet )</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Process the moving structure and compute the spherical harmonics to allow rotation - this is not needed for the static structure &quot;&quot;&quot;</span></div>
<div class="line">pStruct_moving.processInternalMap             ( pSet )</div>
<div class="line">pStruct_moving.mapToSpheres                   ( pSet )</div>
<div class="line">pStruct_moving.computeSphericalHarmonics      ( pSet )</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Rotate the moving structure &quot;&quot;&quot;</span></div>
<div class="line">pStruct_moving.rotateMap                      ( pSet, optimalRotationAngles[0], optimalRotationAngles[1], optimalRotationAngles[2] )</div>
</div><!-- fragment --><p><em>Computing</em> <em>the</em> <em>translation</em> <em>function</em> </p>
<p>Similarly to the rotation function, the user may be interested in the optimal translation required to overlay two structures. ProSHADE can compute such an optimal translation using the translation function; however, in order to compute it, it requires that the two internal map representation have the same dimensions in terms of map indices and map sampling; identical map sampling is achieved by setting the <b>changeMapResolution</b> setting to true. Still, the identical number of indices will not generally be the case, ProSHADE provides a padding function, which can add zeroes around the internal representation map to make sure that it has given dimensions. Therefore, in order to compute the translation function, it is required that the two structures are modified by the <em>zeroPaddToDims()</em> function to both have the same dimensions; the higher of the two structures are chosen in order to avoid loss of information.</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;&quot;&quot; Add zeroes around he structure to achieve given number of indicel along each dimension &quot;&quot;&quot;</span></div>
<div class="line">pStruct_static.zeroPaddToDims                 ( int ( numpy.max ( [ pStruct_static.getXDim(), pStruct_moving.getXDim() ] ) ),</div>
<div class="line">                                                int ( numpy.max ( [ pStruct_static.getYDim(), pStruct_moving.getYDim() ] ) ),</div>
<div class="line">                                                int ( numpy.max ( [ pStruct_static.getZDim(), pStruct_moving.getZDim() ] ) ) )</div>
<div class="line">pStruct_moving.zeroPaddToDims                 ( int ( numpy.max ( [ pStruct_static.getXDim(), pStruct_moving.getXDim() ] ) ),</div>
<div class="line">                                                int ( numpy.max ( [ pStruct_static.getYDim(), pStruct_moving.getYDim() ] ) ),</div>
<div class="line">                                                int ( numpy.max ( [ pStruct_static.getZDim(), pStruct_moving.getZDim() ] ) ) )</div>
</div><!-- fragment --><p>Once the structures have the same dimensions, it is possible to compute the translation function. This function will compute the Fourier transforms of both maps, combine the Fourier coefficients and compute the inverse Fourier transform on the resulting combined coefficients map, thus obtaining the translation map. Once computed, this map can be accessed from the ProSHADE python module as shown in the following example code, again keeping in mind that the 3D version takes considerably longer to obtain than the 1D version.</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;&quot;&quot; Compute the translation function &quot;&quot;&quot;</span></div>
<div class="line">pStruct_moving.computeTranslationMap          ( pStruct_static )</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot; Access the translation map as 1D or 3D numpy.array &quot;&quot;&quot;</span></div>
<div class="line">translationMap1D                              = proshade.getTranslationFunction1D ( pStruct_moving )</div>
<div class="line">translationMap3D                              = proshade.getTranslationFunction3D ( pStruct_moving )</div>
</div><!-- fragment --><p>Also, similarly to the rotation function, ProSHADE provides a useful function for detecting the highest peak in the translation map and computing the corresponding translation in Angstroms. This is then demonstrated in the following example code:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;&quot;&quot; Find the optimal translation vector &quot;&quot;&quot;</span></div>
<div class="line">optimalTranslationVector                      = pStruct_moving.getBestTranslationMapPeaksAngstrom ( pStruct_static )</div>
</div><!-- fragment --><p><em>Translating</em> <em>the</em> <em>internal</em> <em>representation</em> </p>
<p>Once the optimal translation vector is computed, it makes sense that ProSHADE should also be able to apply it to the internal map representation. Therefore, the function <em>translateMap()</em> is provided to facilitate this task. The translation is done in two steps, firstly, ProSHADE simply modifies the starting indices and axes origins of the map to minimise the movement of the map in the cell by moving the cell as a whole. Next, the remaining translation is then done in the frequency domain (by modifing the Fouries coefficients) of the internal representation.</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;&quot;&quot; Translate the internal representation &quot;&quot;&quot;</span></div>
<div class="line">pStruct_moving.translateMap                   ( pSet, optimalTranslationVector[0], optimalTranslationVector[1], optimalTranslationVector[2] )</div>
</div><!-- fragment --><p><em>Writing</em> <em>out</em> <em>resulting</em> <em>structures</em> </p>
<p>Finally, it is worth noting that while the MAP formatted data can be written out of the <b>ProSHADE_data</b> object at any time (albeit their quality may be decreased if the rotation was applied as discussed in the rotating internal representation map section), ProSHADE can also write out the co-ordinate data for input structures, which were read in from a co-ordinate file. Please note that ProSHADE cannot generate co-ordinate data from maps, the co-ordinate data need to pre-exist ProSHADE run. Nonetheless, in the case of, for example, finding the optimal rotation and translation of one structure to overlay with another structure, the user may be interested in writing out the modified co-ordinates. To do this, ProSHADE contains the <em>writePdb()</em> function, which needs to be supplied with the file name, the required rotation and translation and it will write out the PDB file with these modifications applied.</p>
<p>Also, please note that it is the users responsibility to add any rotations or translations together and to supply this function with the correct cumulative values. The example code below shows how a rotated and translated PDB file can be outputted by ProSHADE.</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;&quot;&quot; Translate the internal representation &quot;&quot;&quot;</span></div>
<div class="line">pStruct_moving.writePdb                       ( <span class="stringliteral">&quot;overlayed.pdb&quot;</span>,</div>
<div class="line">                                                optimalRotationAngles[0],</div>
<div class="line">                                                optimalRotationAngles[1],</div>
<div class="line">                                                optimalRotationAngles[2],</div>
<div class="line">                                                optimalTranslationVector[0],</div>
<div class="line">                                                optimalTranslationVector[1],</div>
<div class="line">                                                optimalTranslationVector[2] )</div>
</div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data_html_a23f9a5f8f6fb7cf0f0324bc1d83d6090"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a23f9a5f8f6fb7cf0f0324bc1d83d6090">ProSHADE_internal_data::ProSHADE_data::computeSphericalHarmonics</a></div><div class="ttdeci">void computeSphericalHarmonics(ProSHADE_settings *settings)</div><div class="ttdoc">This function computes the spherical harmonics decomposition for the whole structure.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__data_8cpp_source.html#l01613">ProSHADE_data.cpp:1613</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data_html_a8e1bd5bd5a3fd12691a1d83735c13250"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a8e1bd5bd5a3fd12691a1d83735c13250">ProSHADE_internal_data::ProSHADE_data::getRecommendedSymmetryFold</a></div><div class="ttdeci">proshade_unsign getRecommendedSymmetryFold(ProSHADE_settings *settings)</div><div class="ttdoc">This function simply returns the detected recommended symmetry fold.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__data_8cpp_source.html#l03234">ProSHADE_data.cpp:3234</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__run_html_a089c19ee79d76d77b50a38691b43940d"><div class="ttname"><a href="class_pro_s_h_a_d_e__run.html#a089c19ee79d76d77b50a38691b43940d">ProSHADE_run::getRotationFunctionVector</a></div><div class="ttdeci">std::vector&lt; proshade_double &gt; getRotationFunctionVector(void)</div><div class="ttdoc">This function returns the full rotation function distances vector from the first to all other structu...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e_8cpp_source.html#l02116">ProSHADE.cpp:2116</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data_html_af60532f379f5f3549a598aeb504fe311"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#af60532f379f5f3549a598aeb504fe311">ProSHADE_internal_data::ProSHADE_data::detectSymmetryInStructure</a></div><div class="ttdeci">void detectSymmetryInStructure(ProSHADE_settings *settings, std::vector&lt; proshade_double * &gt; *axes)</div><div class="ttdoc">This function runs the symmetry detection algorithms on this structure and saves the results in the s...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__data_8cpp_source.html#l01656">ProSHADE_data.cpp:1656</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data_html"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a></div><div class="ttdoc">This class contains all inputed and derived data for a single structure.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__data_8hpp_source.html#l00048">ProSHADE_data.hpp:49</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data_html_ae016c0e3cbba28141d593a6147f0b012"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#ae016c0e3cbba28141d593a6147f0b012">ProSHADE_internal_data::ProSHADE_data::getRotationFunction</a></div><div class="ttdeci">void getRotationFunction(ProSHADE_settings *settings)</div><div class="ttdoc">This function computes the self-rotation function for this structure.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__symmetry_8cpp_source.html#l00034">ProSHADE_symmetry.cpp:34</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__settings_html_a0024967775d544e8512b6b157d53c1d1"><div class="ttname"><a href="class_pro_s_h_a_d_e__settings.html#a0024967775d544e8512b6b157d53c1d1">ProSHADE_settings::addStructure</a></div><div class="ttdeci">void addStructure(std::string structure)</div><div class="ttdoc">Adds a structure file name to the appropriate variable.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e_8cpp_source.html#l00302">ProSHADE.cpp:302</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data_html_a56bfcfacedabd84ec54aa2843d59e014"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a56bfcfacedabd84ec54aa2843d59e014">ProSHADE_internal_data::ProSHADE_data::mapToSpheres</a></div><div class="ttdeci">void mapToSpheres(ProSHADE_settings *settings)</div><div class="ttdoc">This function simply clusters several other functions which should be called together.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__data_8cpp_source.html#l01570">ProSHADE_data.cpp:1570</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__run_html"><div class="ttname"><a href="class_pro_s_h_a_d_e__run.html">ProSHADE_run</a></div><div class="ttdoc">This class provides the access point to the library.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e_8hpp_source.html#l00038">ProSHADE.hpp:39</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__settings_html"><div class="ttname"><a href="class_pro_s_h_a_d_e__settings.html">ProSHADE_settings</a></div><div class="ttdoc">This class stores all the settings and is passed to the executive classes instead of a multitude of p...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__settings_8hpp_source.html#l00085">ProSHADE_settings.hpp:86</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data_html_afcb4202e9ffea1b99c59f73faf06d899"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#afcb4202e9ffea1b99c59f73faf06d899">ProSHADE_internal_data::ProSHADE_data::processInternalMap</a></div><div class="ttdeci">void processInternalMap(ProSHADE_settings *settings)</div><div class="ttdoc">This function simply clusters several other functions which should be called together.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__data_8cpp_source.html#l01472">ProSHADE_data.cpp:1472</a></div></div>
<div class="ttc" id="a_pro_s_h_a_d_e_8hpp_html"><div class="ttname"><a href="_pro_s_h_a_d_e_8hpp.html">ProSHADE.hpp</a></div><div class="ttdoc">This is the main header file providing the main access class and its functions.</div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__run_html_afe51ca33765b921b8e8381527b899cb3"><div class="ttname"><a href="class_pro_s_h_a_d_e__run.html#afe51ca33765b921b8e8381527b899cb3">ProSHADE_run::getEnergyLevelsVector</a></div><div class="ttdeci">std::vector&lt; proshade_double &gt; getEnergyLevelsVector(void)</div><div class="ttdoc">This function returns the energy level distances vector from the first to all other structures.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e_8cpp_source.html#l02096">ProSHADE.cpp:2096</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data_html_ad5add825ce8d5e5d9f598f6912f07aff"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#ad5add825ce8d5e5d9f598f6912f07aff">ProSHADE_internal_data::ProSHADE_data::getRecommendedSymmetryType</a></div><div class="ttdeci">std::string getRecommendedSymmetryType(ProSHADE_settings *settings)</div><div class="ttdoc">This function simply returns the detected recommended symmetry type.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__data_8cpp_source.html#l03223">ProSHADE_data.cpp:3223</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__run_html_a78d93810b15c64493a5a2de49accafbc"><div class="ttname"><a href="class_pro_s_h_a_d_e__run.html#a78d93810b15c64493a5a2de49accafbc">ProSHADE_run::getTraceSigmaVector</a></div><div class="ttdeci">std::vector&lt; proshade_double &gt; getTraceSigmaVector(void)</div><div class="ttdoc">This function returns the trace sigma distances vector from the first to all other structures.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e_8cpp_source.html#l02106">ProSHADE.cpp:2106</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__settings_html_a3e7f4174b62aa402a1f6d3becd8e9dd5"><div class="ttname"><a href="class_pro_s_h_a_d_e__settings.html#a3e7f4174b62aa402a1f6d3becd8e9dd5">ProSHADE_settings::setResolution</a></div><div class="ttdeci">void setResolution(proshade_single resolution)</div><div class="ttdoc">Sets the requested resolution in the appropriate variable.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e_8cpp_source.html#l00318">ProSHADE.cpp:318</a></div></div>
<div class="ttc" id="aclass_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data_html_a59f2f2ce1bfdb90432c5a29600fdd9e6"><div class="ttname"><a href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html#a59f2f2ce1bfdb90432c5a29600fdd9e6">ProSHADE_internal_data::ProSHADE_data::readInStructure</a></div><div class="ttdeci">void readInStructure(std::string fName, proshade_unsign inputO, ProSHADE_settings *settings)</div><div class="ttdoc">This function initialises the basic ProSHADE_data variables and reads in a single structure.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__data_8cpp_source.html#l00419">ProSHADE_data.cpp:419</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
