<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ProSHADE: ProSHADE_internal_maths Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Logo_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ProSHADE
   &#160;<span id="projectnumber">0.7.3 (JUN 2020)</span>
   </div>
   <div id="projectbrief">Protein Shape Detection</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespace_pro_s_h_a_d_e__internal__maths.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ProSHADE_internal_maths Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This namespace contains the internal functions for common mathematical operations.  
<a href="namespace_pro_s_h_a_d_e__internal__maths.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a254fece06e1cfce122a11ddea4f71970"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a254fece06e1cfce122a11ddea4f71970">complexMultiplication</a> (proshade_double *r1, proshade_double *i1, proshade_double *r2, proshade_double *i2, proshade_double *retReal, proshade_double *retImag)</td></tr>
<tr class="memdesc:a254fece06e1cfce122a11ddea4f71970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to multiply two complex numbers.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a254fece06e1cfce122a11ddea4f71970">More...</a><br /></td></tr>
<tr class="separator:a254fece06e1cfce122a11ddea4f71970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca5a3aedba75f52aaf707edc4e790f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ca5a3aedba75f52aaf707edc4e790f7">complexMultiplicationConjug</a> (proshade_double *r1, proshade_double *i1, proshade_double *r2, proshade_double *i2, proshade_double *retReal, proshade_double *retImag)</td></tr>
<tr class="memdesc:a2ca5a3aedba75f52aaf707edc4e790f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to multiply two complex numbers by using the second number's conjugate.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ca5a3aedba75f52aaf707edc4e790f7">More...</a><br /></td></tr>
<tr class="separator:a2ca5a3aedba75f52aaf707edc4e790f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b05344ffead449c29a333a57b404f6"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#ac9b05344ffead449c29a333a57b404f6">complexMultiplicationRealOnly</a> (proshade_double *r1, proshade_double *i1, proshade_double *r2, proshade_double *i2)</td></tr>
<tr class="memdesc:ac9b05344ffead449c29a333a57b404f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to multiply two complex numbers and return the real part only.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#ac9b05344ffead449c29a333a57b404f6">More...</a><br /></td></tr>
<tr class="separator:ac9b05344ffead449c29a333a57b404f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc59a55f5ed21de90e351005c58a871e"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#abc59a55f5ed21de90e351005c58a871e">complexMultiplicationConjugRealOnly</a> (proshade_double *r1, proshade_double *i1, proshade_double *r2, proshade_double *i2)</td></tr>
<tr class="memdesc:abc59a55f5ed21de90e351005c58a871e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to conjuggate multiply two complex numbers and return the real part only.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#abc59a55f5ed21de90e351005c58a871e">More...</a><br /></td></tr>
<tr class="separator:abc59a55f5ed21de90e351005c58a871e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7c6330e101fb6d729aaf6f545db9c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a8a7c6330e101fb6d729aaf6f545db9c8">vectorMeanAndSD</a> (std::vector&lt; proshade_double &gt; *vec, proshade_double *&amp;ret)</td></tr>
<tr class="memdesc:a8a7c6330e101fb6d729aaf6f545db9c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get vector mean and standard deviation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a8a7c6330e101fb6d729aaf6f545db9c8">More...</a><br /></td></tr>
<tr class="separator:a8a7c6330e101fb6d729aaf6f545db9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af185ca14eb5d82fb126092767746e00a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#af185ca14eb5d82fb126092767746e00a">vectorMedianAndIQR</a> (std::vector&lt; proshade_double &gt; *vec, proshade_double *&amp;ret)</td></tr>
<tr class="memdesc:af185ca14eb5d82fb126092767746e00a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get vector median and inter-quartile range.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#af185ca14eb5d82fb126092767746e00a">More...</a><br /></td></tr>
<tr class="separator:af185ca14eb5d82fb126092767746e00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a356017340781739a3bd66c716cfa5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#aa5a356017340781739a3bd66c716cfa5">arrayMedianAndIQR</a> (proshade_double *vec, proshade_unsign vecSize, proshade_double *&amp;ret)</td></tr>
<tr class="memdesc:aa5a356017340781739a3bd66c716cfa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get array median and inter-quartile range.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#aa5a356017340781739a3bd66c716cfa5">More...</a><br /></td></tr>
<tr class="separator:aa5a356017340781739a3bd66c716cfa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894d87e94446db04492b663e54a74bff"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a894d87e94446db04492b663e54a74bff">pearsonCorrCoeff</a> (proshade_double *valSet1, proshade_double *valSet2, proshade_unsign length)</td></tr>
<tr class="memdesc:a894d87e94446db04492b663e54a74bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for computing the Pearson's correlation coefficient.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a894d87e94446db04492b663e54a74bff">More...</a><br /></td></tr>
<tr class="separator:a894d87e94446db04492b663e54a74bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2f7de1bba288270ce2cc772d28d065"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a6e2f7de1bba288270ce2cc772d28d065">getLegendreAbscAndWeights</a> (proshade_unsign order, proshade_double *abscissas, proshade_double *weights, proshade_unsign taylorSeriesCap)</td></tr>
<tr class="memdesc:a6e2f7de1bba288270ce2cc772d28d065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to prepare abscissas and weights for Gauss-Legendre integration.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a6e2f7de1bba288270ce2cc772d28d065">More...</a><br /></td></tr>
<tr class="separator:a6e2f7de1bba288270ce2cc772d28d065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affab74b910cda2ee3faa461740a7a432"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#affab74b910cda2ee3faa461740a7a432">getGLPolyAtZero</a> (proshade_unsign order, proshade_double *polyValue, proshade_double *deriValue)</td></tr>
<tr class="memdesc:affab74b910cda2ee3faa461740a7a432"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function obtains the Legendre polynomial values and its derivative at zero for any positive integer order polynomial.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#affab74b910cda2ee3faa461740a7a432">More...</a><br /></td></tr>
<tr class="separator:affab74b910cda2ee3faa461740a7a432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1823adaca871244e42347ecb8ed834a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a1823adaca871244e42347ecb8ed834a2">getGLFirstEvenRoot</a> (proshade_double polyAtZero, proshade_unsign order, proshade_double *abscAtZero, proshade_double *weighAtZero, proshade_unsign taylorSeriesCap)</td></tr>
<tr class="memdesc:a1823adaca871244e42347ecb8ed834a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds the first root for Legendre polynomials of odd order.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a1823adaca871244e42347ecb8ed834a2">More...</a><br /></td></tr>
<tr class="separator:a1823adaca871244e42347ecb8ed834a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e69b64278319ae1a1268d1a55545675"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a7e69b64278319ae1a1268d1a55545675">evaluateGLSeries</a> (proshade_double *series, proshade_double target, proshade_unsign terms)</td></tr>
<tr class="memdesc:a7e69b64278319ae1a1268d1a55545675"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function evaluates the Taylor expansion.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a7e69b64278319ae1a1268d1a55545675">More...</a><br /></td></tr>
<tr class="separator:a7e69b64278319ae1a1268d1a55545675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2619c7f3b8d628af9cb356778e9807"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a4f2619c7f3b8d628af9cb356778e9807">advanceGLPolyValue</a> (proshade_double from, proshade_double to, proshade_double valAtFrom, proshade_unsign noSteps, proshade_unsign taylorSeriesCap)</td></tr>
<tr class="memdesc:a4f2619c7f3b8d628af9cb356778e9807"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds the next value of the polynomial.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a4f2619c7f3b8d628af9cb356778e9807">More...</a><br /></td></tr>
<tr class="separator:a4f2619c7f3b8d628af9cb356778e9807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c91064de64aef9f8278d533f8188ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a31c91064de64aef9f8278d533f8188ad">completeLegendreSeries</a> (proshade_unsign order, proshade_double *abscissa, proshade_double *weights, proshade_unsign taylorSeriesCap)</td></tr>
<tr class="memdesc:a31c91064de64aef9f8278d533f8188ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function completes the Legendre polynomial series assuming you have obtained the first values.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a31c91064de64aef9f8278d533f8188ad">More...</a><br /></td></tr>
<tr class="separator:a31c91064de64aef9f8278d533f8188ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62133f51851217e3cb28dff2f520d192"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a62133f51851217e3cb28dff2f520d192">gaussLegendreIntegrationReal</a> (proshade_double *vals, proshade_unsign valsSize, proshade_unsign order, proshade_double *abscissas, proshade_double *weights, proshade_double integralOverRange, proshade_double maxSphereDists)</td></tr>
<tr class="memdesc:a62133f51851217e3cb28dff2f520d192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute real part of the Gauss-Legendre integration over spherical harmonic values in different shells.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a62133f51851217e3cb28dff2f520d192">More...</a><br /></td></tr>
<tr class="separator:a62133f51851217e3cb28dff2f520d192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4604176a61820f5fcb95e372861c1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a3d4604176a61820f5fcb95e372861c1d">gaussLegendreIntegration</a> (proshade_complex *vals, proshade_unsign valsSize, proshade_unsign order, proshade_double *abscissas, proshade_double *weights, proshade_double integralOverRange, proshade_double maxSphereDists, proshade_double *retReal, proshade_double *retImag)</td></tr>
<tr class="memdesc:a3d4604176a61820f5fcb95e372861c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute the complete complex Gauss-Legendre integration over spherical harmonic values in different shells.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a3d4604176a61820f5fcb95e372861c1d">More...</a><br /></td></tr>
<tr class="separator:a3d4604176a61820f5fcb95e372861c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98abe6f7fac976a70b608951dbdf993"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#ab98abe6f7fac976a70b608951dbdf993">complexMatrixSVDSigmasOnly</a> (proshade_complex **mat, int dim, double *&amp;singularValues)</td></tr>
<tr class="memdesc:ab98abe6f7fac976a70b608951dbdf993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute the complete complex matrix SVD and return only the sigmas.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#ab98abe6f7fac976a70b608951dbdf993">More...</a><br /></td></tr>
<tr class="separator:ab98abe6f7fac976a70b608951dbdf993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc79bf2506934c9ebbda9c13a2722ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#acdc79bf2506934c9ebbda9c13a2722ad">complexMatrixSVDUandVOnly</a> (proshade_double *mat, int dim, proshade_double *uAndV, bool fail=true)</td></tr>
<tr class="memdesc:acdc79bf2506934c9ebbda9c13a2722ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute the real matrix SVD and return the U and V matrices.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#acdc79bf2506934c9ebbda9c13a2722ad">More...</a><br /></td></tr>
<tr class="separator:acdc79bf2506934c9ebbda9c13a2722ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6c5376edac98e54ef0e418cd05d706"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#acf6c5376edac98e54ef0e418cd05d706">getEulerZXZFromSOFTPosition</a> (proshade_signed band, proshade_signed x, proshade_signed y, proshade_signed z, proshade_double *eulerAlpha, proshade_double *eulerBeta, proshade_double *eulerGamma)</td></tr>
<tr class="memdesc:acf6c5376edac98e54ef0e418cd05d706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to find Euler angles (ZXZ convention) from index position in the inverse SOFT map.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#acf6c5376edac98e54ef0e418cd05d706">More...</a><br /></td></tr>
<tr class="separator:acf6c5376edac98e54ef0e418cd05d706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9fe573a48f499dd7d1df4f779222f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#abd9fe573a48f499dd7d1df4f779222f1">getRotationMatrixFromEulerZXZAngles</a> (proshade_double eulerAlpha, proshade_double eulerBeta, proshade_double eulerGamma, proshade_double *matrix)</td></tr>
<tr class="memdesc:abd9fe573a48f499dd7d1df4f779222f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to find the rotation matrix from Euler angles (ZXZ convention).  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#abd9fe573a48f499dd7d1df4f779222f1">More...</a><br /></td></tr>
<tr class="separator:abd9fe573a48f499dd7d1df4f779222f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc6f1626c7463de53c9f4f6fa11db22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#aafc6f1626c7463de53c9f4f6fa11db22">getAxisAngleFromRotationMatrix</a> (proshade_double *rotMat, proshade_double *x, proshade_double *y, proshade_double *z, proshade_double *ang)</td></tr>
<tr class="memdesc:aafc6f1626c7463de53c9f4f6fa11db22"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts rotation matrix to the axis-angle representation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#aafc6f1626c7463de53c9f4f6fa11db22">More...</a><br /></td></tr>
<tr class="separator:aafc6f1626c7463de53c9f4f6fa11db22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39eafef902a49cc0816a2ed675c14a49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a39eafef902a49cc0816a2ed675c14a49">getRotationMatrixFromAngleAxis</a> (proshade_double *rotMat, proshade_double x, proshade_double y, proshade_double z, proshade_double ang)</td></tr>
<tr class="memdesc:a39eafef902a49cc0816a2ed675c14a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts the axis-angle representation to the rotation matrix representation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a39eafef902a49cc0816a2ed675c14a49">More...</a><br /></td></tr>
<tr class="separator:a39eafef902a49cc0816a2ed675c14a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f6afcef5b90ca77d7d6a9e91824e28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#ae6f6afcef5b90ca77d7d6a9e91824e28">getEulerZXZFromRotMatrix</a> (proshade_double *rotMat, proshade_double *eA, proshade_double *eB, proshade_double *eG)</td></tr>
<tr class="memdesc:ae6f6afcef5b90ca77d7d6a9e91824e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts rotation matrix to the Euler ZXZ angles representation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#ae6f6afcef5b90ca77d7d6a9e91824e28">More...</a><br /></td></tr>
<tr class="separator:ae6f6afcef5b90ca77d7d6a9e91824e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac211e762a46e4c7e25235a651acfdc77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#ac211e762a46e4c7e25235a651acfdc77">multiplyTwoSquareMatrices</a> (proshade_double *A, proshade_double *B, proshade_double *res, proshade_unsign dim)</td></tr>
<tr class="memdesc:ac211e762a46e4c7e25235a651acfdc77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute matrix multiplication.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#ac211e762a46e4c7e25235a651acfdc77">More...</a><br /></td></tr>
<tr class="separator:ac211e762a46e4c7e25235a651acfdc77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6359dd366cdd986f5ad155bff8235a8e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; proshade_signed &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a6359dd366cdd986f5ad155bff8235a8e">primeFactorsDecomp</a> (proshade_signed number)</td></tr>
<tr class="memdesc:a6359dd366cdd986f5ad155bff8235a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to find prime factors of an integer.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a6359dd366cdd986f5ad155bff8235a8e">More...</a><br /></td></tr>
<tr class="separator:a6359dd366cdd986f5ad155bff8235a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01087ea3e0db56758d1771618e2e4a45"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a01087ea3e0db56758d1771618e2e4a45">normalDistributionValue</a> (proshade_double mean, proshade_double standardDev, proshade_double value)</td></tr>
<tr class="memdesc:a01087ea3e0db56758d1771618e2e4a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to the heiht of normal distribution given by mean and standard deviation for a given value.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a01087ea3e0db56758d1771618e2e4a45">More...</a><br /></td></tr>
<tr class="separator:a01087ea3e0db56758d1771618e2e4a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac3b534f974de25b092e9d48d9f7dea"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">computeDotProduct</a> (proshade_double *x1, proshade_double *y1, proshade_double *z1, proshade_double *x2, proshade_double *y2, proshade_double *z2)</td></tr>
<tr class="memdesc:a2ac3b534f974de25b092e9d48d9f7dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple 3D vector dot product computation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">More...</a><br /></td></tr>
<tr class="separator:a2ac3b534f974de25b092e9d48d9f7dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace contains the internal functions for common mathematical operations. </p>
<p>The <a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html" title="This namespace contains the internal functions for common mathematical operations.">ProSHADE_internal_maths</a> namespace contains a set of common mathematical operations used in many places by ProSHADE. These typically include complex number operations and angle conversions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a4f2619c7f3b8d628af9cb356778e9807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2619c7f3b8d628af9cb356778e9807">&#9670;&nbsp;</a></span>advanceGLPolyValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">proshade_double ProSHADE_internal_maths::advanceGLPolyValue </td>
          <td>(</td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>valAtFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>noSteps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>taylorSeriesCap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function finds the next value of the polynomial. </p>
<p>Given the previous value of the polynomial, the distance to proceed and the number of steps to take, this function finds the next value of the polynomial using the Taylor series.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>Current polynomial position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>Polynomial position to move to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valAtFrom</td><td>The current value of the polynomial at the &lt;from&gt; position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noSteps</td><td>Number of steps in which to reach the &lt;to&gt; position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">taylorSeriesCap</td><td>The limit on the Taylor series. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>The polynomial value at the &lt;to&gt; position. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00472">472</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;{</div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;    proshade_double hlpVal                            = 0.0;</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;    proshade_double stepSize                          = 0.0;</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;    proshade_double valChange                         = 0.0;</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;    proshade_double valSecChange                      = 0.0;</div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;    proshade_double squareSteps                       = 0.0;</div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;    proshade_double curVal                            = 0.0;</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;    </div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;    <span class="comment">//================================================ Set initial values</span></div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;    stepSize                                          = ( to - from ) / <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( taylorSeriesCap );</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;    squareSteps                                       = sqrt ( <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( noSteps * ( noSteps + 1 ) ) );</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;    curVal                                            = from;</div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;    </div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;    <span class="comment">//================================================ Go through the series and iteratively improve the estimate</span></div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; taylorSeriesCap; iter++ )</div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;    {</div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;        hlpVal                                        = ( 1.0 - valAtFrom ) * ( 1.0 + valAtFrom );</div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;        valChange                                     = - stepSize * hlpVal / ( squareSteps * sqrt ( hlpVal ) - 0.5 * valAtFrom * sin ( 2.0 * curVal ) );</div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;        valAtFrom                                     = valAtFrom + valChange;</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;                </div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;        curVal                                        = curVal + stepSize;</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;                </div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;        hlpVal                                        = ( 1.0 - valAtFrom ) * ( 1.0 + valAtFrom );</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;        valSecChange                                  = - stepSize * hlpVal / ( squareSteps * sqrt ( hlpVal ) - 0.5 * valAtFrom * sin ( 2.0 * curVal ) );</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;        valAtFrom                                     = valAtFrom + 0.5 * ( valSecChange - valChange );</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;    }</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;    </div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;    <span class="keywordflow">return</span> valAtFrom;</div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;    </div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa5a356017340781739a3bd66c716cfa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a356017340781739a3bd66c716cfa5">&#9670;&nbsp;</a></span>arrayMedianAndIQR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::arrayMedianAndIQR </td>
          <td>(</td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>vecSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get array median and inter-quartile range. </p>
<p>This function takes a pointer to a array of proshade_double's and returns the median and the inter-quartile range of such vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>Pointer to an array of proshade_double's for which median and IQR should be obtained. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vecSize</td><td>The length of the array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>Pointer to array of 2 proshade_double's, which will be the return values - first median and second IQR. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00194">194</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;{</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    <span class="comment">//================================================ Sort the vector</span></div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    std::sort                                         ( vec, vec + vecSize );</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    </div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    <span class="comment">//================================================ Get median</span></div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    <span class="keywordflow">if</span> ( vecSize % 2 == 0)</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;    {</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        ret[0]                                        = ( vec[ ( vecSize / 2 ) - 1 ] + vec[ vecSize / 2 ] ) / 2.0;</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;    }</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    {</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;        ret[0]                                        = vec[ vecSize / 2 ];</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    }</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    </div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    <span class="comment">//================================================ Get first and third quartile</span></div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;    proshade_double Q1, Q3;</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    <span class="keywordflow">if</span> ( vecSize % 2 == 0)</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    {</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;        Q1                                            = ( vec[ ( vecSize / 4 ) - 1 ] + vec[ vecSize / 4 ] ) / 2.0;</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;        Q3                                            = ( vec[ ( ( vecSize / 4 ) * 3 ) - 1 ] + vec[ ( vecSize / 4 ) * 3 ] ) / 2.0;</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;    }</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    {</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;        Q1                                            = vec[ vecSize / 4 ];</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;        Q3                                            = vec[ ( vecSize / 4 ) * 3 ];</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    }</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    </div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    <span class="comment">//================================================ And now save the IQR</span></div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    ret[1]                                            = Q3 -  Q1;</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    </div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;    <span class="comment">//================================================ Return</span></div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;    return ;</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    </div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a31c91064de64aef9f8278d533f8188ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c91064de64aef9f8278d533f8188ad">&#9670;&nbsp;</a></span>completeLegendreSeries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::completeLegendreSeries </td>
          <td>(</td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>abscissas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>taylorSeriesCap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function completes the Legendre polynomial series assuming you have obtained the first values. </p>
<p>Given that the polynomial value at zero is known, this function will complete the Legendre polynomial and with it the absicassas and weights for the Gauss-Legendre integration using the other functions defined above.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>The positive integer value of the polynomial order. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">abscissas</td><td>Pointer to an array of abscissas containing the first value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>Pointer to an array of weights containing the first value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">taylorSeriesCap</td><td>The limit on the Taylor series. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00516">516</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;{</div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;    <span class="comment">//================================================ Initialise internal variables</span></div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;    proshade_double hlpTaylorVal                      = 0.0;</div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;    proshade_double hlpOrderVal                       = <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( order );</div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;    proshade_double abscValueChange                   = 0.0;</div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;    proshade_double prevAbsc                          = 0.0;</div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;    proshade_double *hlpAbscSeries;</div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;    proshade_double *hlpWeightSeries;</div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;    proshade_unsign noSeriesElems                     = 0;</div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;    proshade_unsign oddEvenSwitch                     = 0;</div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;    </div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;    <span class="comment">//================================================ Pre-set internal values</span></div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;    <span class="keywordflow">if</span> ( order % 2 == 1 )</div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;    {</div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;        noSeriesElems                                 = ( order - 1 ) / 2 - 1;</div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;        oddEvenSwitch                                 = 1;</div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;    }</div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;    {</div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;        noSeriesElems                                 = order / 2 - 1;</div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;        oddEvenSwitch                                 = 0;</div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;    }</div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;    </div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;    <span class="comment">//================================================ Allocate memory</span></div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;    hlpAbscSeries                                     = <span class="keyword">new</span> proshade_double[taylorSeriesCap+2];</div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;    hlpWeightSeries                                   = <span class="keyword">new</span> proshade_double[taylorSeriesCap+1];</div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;    </div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;    <span class="comment">//================================================ For each series element</span></div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign serIt = noSeriesElems + 1; serIt &lt; order - 1; serIt++ )</div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;    {</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;        <span class="comment">//============================================ Init loop</span></div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;        prevAbsc                                      = abscissas[serIt];</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;        abscValueChange                               = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a4f2619c7f3b8d628af9cb356778e9807">advanceGLPolyValue</a> ( M_PI/2.0, -M_PI/2.0, prevAbsc, order, taylorSeriesCap ) - prevAbsc;</div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;        </div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;        <span class="comment">//============================================ Init abscissas</span></div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;        hlpAbscSeries[0]                              = 0.0;</div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;        hlpAbscSeries[1]                              = 0.0;</div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;        hlpAbscSeries[2]                              = weights[serIt];</div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;        </div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;        <span class="comment">//============================================ Init weights</span></div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;        hlpWeightSeries[0]                            = 0.0;</div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;        hlpWeightSeries[1]                            = hlpAbscSeries[2];</div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;        </div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;        <span class="comment">//============================================ Taylor expansion</span></div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign tayIt = 0; tayIt &lt;= taylorSeriesCap - 2; tayIt++ )</div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;        {</div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;            hlpTaylorVal                              = <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( tayIt );</div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;                    </div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;            hlpAbscSeries[tayIt+3]                    = ( 2.0 * prevAbsc * ( hlpTaylorVal + 1.0 ) * hlpAbscSeries[tayIt+2] + ( hlpTaylorVal * ( hlpTaylorVal + 1.0 ) - hlpOrderVal *</div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;                                                        ( hlpOrderVal + 1.0 ) ) * hlpAbscSeries[tayIt+1] / ( hlpTaylorVal + 1.0 ) ) / ( 1.0 - prevAbsc ) / ( 1.0 + prevAbsc ) /</div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;                                                        ( hlpTaylorVal + 2.0 );</div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;            </div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;            hlpWeightSeries[tayIt+2]                  = ( hlpTaylorVal + 2.0 ) * hlpAbscSeries[tayIt+3];</div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;        }</div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;        </div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;        <span class="comment">//============================================ Sum over results</span></div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; 5; iter++ )</div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;        {</div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;            abscValueChange                           = abscValueChange - <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a7e69b64278319ae1a1268d1a55545675">evaluateGLSeries</a> ( hlpAbscSeries,   abscValueChange, taylorSeriesCap   ) /</div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;                                                                          <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a7e69b64278319ae1a1268d1a55545675">evaluateGLSeries</a> ( hlpWeightSeries, abscValueChange, taylorSeriesCap-1 );</div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;        }</div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;        </div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;        <span class="comment">//============================================ Save results</span></div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;        abscissas[serIt+1]                            = prevAbsc + abscValueChange;</div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;        weights[serIt+1]                              = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a7e69b64278319ae1a1268d1a55545675">evaluateGLSeries</a> ( hlpWeightSeries, abscValueChange, taylorSeriesCap - 1 );</div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;    }</div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;    </div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign serIt = 0; serIt &lt;= noSeriesElems + oddEvenSwitch; serIt++ )</div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;    {</div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;        abscissas[serIt]                              = -abscissas[order-serIt-1];</div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;        weights[serIt]                                = weights[order-serIt-1];</div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;    }</div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;    </div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;    <span class="comment">//================================================ Free memory</span></div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;    <span class="keyword">delete</span> hlpAbscSeries;</div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;    <span class="keyword">delete</span> hlpWeightSeries;</div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;    </div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;    return ;</div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;    </div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab98abe6f7fac976a70b608951dbdf993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab98abe6f7fac976a70b608951dbdf993">&#9670;&nbsp;</a></span>complexMatrixSVDSigmasOnly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::complexMatrixSVDSigmasOnly </td>
          <td>(</td>
          <td class="paramtype">proshade_complex **&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>singularValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute the complete complex matrix SVD and return only the sigmas. </p>
<p>This function converts the input proshade_complex matrix of dimensions dim onto the LAPACK compatible std::complex&lt;double&gt; matrix. It then proceeds to create a dummy variables for the U and V matrices for saving the SVD results as well as other required variables. It finally proceeds to call LAPACK ZGESDD function to compute the SVD of the complex matrix input, checks the results and terminates. Note that this function does not make use of most of the LAPACK capabilities and is limitted onto square matrices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>Pointer to a complex square matrix with dimensions dim * dim. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>The dimension of the complex matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">singularValues</td><td>Empty array of size dim where the singular values will be saved. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00797">797</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;{</div>
<div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;    <span class="comment">//================================================ Initialise local variables</span></div>
<div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;    <span class="keywordtype">char</span> job                                          = <span class="charliteral">&#39;N&#39;</span>;                              <span class="comment">// Save computation of parts of U and V matrices, they are not needed here</span></div>
<div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;    __extension__ std::complex&lt;double&gt; rotMatU[dim][dim];                                 <span class="comment">// The U matrix space</span></div>
<div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;    __extension__ std::complex&lt;double&gt; rotMatV[dim][dim];                                 <span class="comment">// The V^T matrix space</span></div>
<div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;    __extension__ std::complex&lt;double&gt; work[( 4 * dim)];                                  <span class="comment">// Workspace, minimum required is 3*dim, using more for performance</span></div>
<div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;    <span class="keywordtype">int</span> workDim                                       = ( 4 * dim);                       <span class="comment">// Formalism stating just that</span></div>
<div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;    <span class="keywordtype">double</span>* rwork                                     = <span class="keyword">new</span> <span class="keywordtype">double</span>[(7 * dim)];            <span class="comment">// Required by LAPACK, from 3.7 requires 7 * dim</span></div>
<div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;    <span class="keywordtype">int</span>* iwork                                        = <span class="keyword">new</span> <span class="keywordtype">int</span>[(8 * dim)];               <span class="comment">// Required by LAPACK</span></div>
<div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;    <span class="keywordtype">int</span> returnValue                                   = 0;                                <span class="comment">// This will tell if operation succeeded</span></div>
<div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( rwork, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( iwork, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;    </div>
<div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;    <span class="comment">//================================================ Load input data into array in column-major order</span></div>
<div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;    std::complex&lt;double&gt; *matrixToDecompose           = <span class="keyword">new</span> std::complex&lt;double&gt;[dim*dim];</div>
<div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( matrixToDecompose, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;    <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> rowIt = 0; rowIt &lt; dim; rowIt++ )</div>
<div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;    {</div>
<div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;        <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> colIt = 0; colIt &lt; dim; colIt++ )</div>
<div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;        {</div>
<div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;            matrixToDecompose[(colIt*dim)+rowIt]      = std::complex&lt;double&gt; ( mat[rowIt][colIt][0], mat[rowIt][colIt][1] );</div>
<div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;        }</div>
<div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;    }</div>
<div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;    </div>
<div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;    <span class="comment">//================================================ Run LAPACK ZGESDD</span></div>
<div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;    zgesdd_                                           ( &amp;job, &amp;dim, &amp;dim, matrixToDecompose, &amp;dim, singularValues, *rotMatU, &amp;dim, *rotMatV, &amp;dim,</div>
<div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;                                                        work, &amp;workDim, rwork, iwork, &amp;returnValue );</div>
<div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;    </div>
<div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;    <span class="comment">//================================================ Free memory</span></div>
<div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;    <span class="keyword">delete</span>[] rwork;</div>
<div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;    <span class="keyword">delete</span>[] iwork;</div>
<div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;    <span class="keyword">delete</span>[] matrixToDecompose;</div>
<div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;    </div>
<div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;    <span class="comment">//================================================ Check result</span></div>
<div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;    <span class="keywordflow">if</span> ( returnValue != 0 )</div>
<div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;    {</div>
<div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;        <span class="keywordflow">throw</span> <a class="code" href="class_pro_s_h_a_d_e__exception.html">ProSHADE_exception</a> ( <span class="stringliteral">&quot;The LAPACK complex SVD algorithm did not converge!&quot;</span>, <span class="stringliteral">&quot;EL00021&quot;</span>, __FILE__, __LINE__, __func__, <span class="stringliteral">&quot;LAPACK algorithm for computing the singular value\n                    : decomposition of complex matrices did not converge and\n                    : therefore it was not possible to combine SH coefficients\n                    : from multiple shells. Changing the resolution may help,\n                    : contact me if this error persists.&quot;</span> );</div>
<div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;    }</div>
<div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;    </div>
<div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;    return ;</div>
<div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;    </div>
<div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="acdc79bf2506934c9ebbda9c13a2722ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc79bf2506934c9ebbda9c13a2722ad">&#9670;&nbsp;</a></span>complexMatrixSVDUandVOnly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::complexMatrixSVDUandVOnly </td>
          <td>(</td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>uAndV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fail</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute the real matrix SVD and return the U and V matrices. </p>
<p>This function converts the input proshade_double array of dimensions dim*dim onto the LAPACK compatible std::complex&lt;double&gt; matrix. It then proceeds to create a dummy variables for the U and V matrices for saving the SVD results as well as other required variables. It finally proceeds to call LAPACK ZGESDD function to compute the SVD of the real matrix input, checks the results and saves the U and V matrices for output. Note that this function does not make use of most of the LAPACK capabilities and is limitted onto square matrices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>Pointer to a real square matrix with dimensions dim * dim. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>The dimension of the real matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uAndV</td><td>Empty and allocated array of size dim*6 where the U and V matrices will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fail</td><td>If true and an error is encountered (typically algorithm not converging), this function will stop the program (useful for distances computations). However, if false, the function will simply return -777 as the first matrix element and not fail. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00856">856</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;{</div>
<div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;    <span class="comment">//================================================ Initialise local variables</span></div>
<div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;    <span class="keywordtype">char</span> job                                          = <span class="charliteral">&#39;A&#39;</span>;                              <span class="comment">// Save computation of parts of U and V matrices, they are not needed here</span></div>
<div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;    <span class="keywordtype">double</span>* singularValues                            = <span class="keyword">new</span> <span class="keywordtype">double</span>[dim];                  <span class="comment">// The array of singular values</span></div>
<div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;    __extension__ std::complex&lt;double&gt; rotMatU[dim][dim];                                 <span class="comment">// The U matrix space</span></div>
<div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;    __extension__ std::complex&lt;double&gt; rotMatV[dim][dim];                                 <span class="comment">// The V^T matrix space</span></div>
<div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;    __extension__ std::complex&lt;double&gt; work[<span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span>( ( 3 * dim) + pow( dim, 2 ) * dim)]; <span class="comment">// Workspace, minimum required is 3*dim, using more for performance</span></div>
<div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;    <span class="keywordtype">int</span> workDim                                       = ( 3 * dim) + pow( dim, 2 );       <span class="comment">// Formalism stating just that</span></div>
<div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;    <span class="keywordtype">double</span>* rwork                                     = <span class="keyword">new</span> <span class="keywordtype">double</span>[<span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span>((5 * dim) + 5 * pow(dim,2))]; <span class="comment">// Required by LAPACK</span></div>
<div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;    <span class="keywordtype">int</span>* iwork                                        = <span class="keyword">new</span> <span class="keywordtype">int</span>[(8 * dim)];               <span class="comment">// Required by LAPACK</span></div>
<div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;    <span class="keywordtype">int</span> returnValue                                   = 0;                                <span class="comment">// This will tell if operation succeeded</span></div>
<div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( singularValues, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( rwork,          __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( iwork,          __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;    </div>
<div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;    <span class="comment">//================================================ Load input data into array in column-major order</span></div>
<div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;    std::complex&lt;double&gt; *matrixToDecompose           = <span class="keyword">new</span> std::complex&lt;double&gt;[dim*dim];</div>
<div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a>     ( matrixToDecompose, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;    <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> rowIt = 0; rowIt &lt; dim; rowIt++ )</div>
<div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;    {</div>
<div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;        <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> colIt = 0; colIt &lt; dim; colIt++ )</div>
<div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;        {</div>
<div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;            matrixToDecompose[(colIt*dim)+rowIt]      = std::complex&lt;double&gt; ( mat[(rowIt*dim)+colIt], 0.0 );</div>
<div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;        }</div>
<div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;    }</div>
<div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;    </div>
<div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;    <span class="comment">//================================================ Run LAPACK ZGESDD</span></div>
<div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;    zgesdd_                                           ( &amp;job, &amp;dim, &amp;dim, matrixToDecompose, &amp;dim, singularValues, *rotMatU, &amp;dim, *rotMatV, &amp;dim,</div>
<div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;                                                        work, &amp;workDim, rwork, iwork, &amp;returnValue );</div>
<div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;    </div>
<div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;    <span class="comment">//================================================ Free memory</span></div>
<div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;    <span class="keyword">delete</span>[] rwork;</div>
<div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;    <span class="keyword">delete</span>[] iwork;</div>
<div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;    <span class="keyword">delete</span>[] matrixToDecompose;</div>
<div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;    <span class="keyword">delete</span>[] singularValues;</div>
<div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;    </div>
<div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;    <span class="comment">//================================================ Check result</span></div>
<div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;    <span class="keywordflow">if</span> ( ( returnValue != 0 ) &amp;&amp; ( fail ) )</div>
<div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;    {</div>
<div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;        <span class="keywordflow">throw</span> <a class="code" href="class_pro_s_h_a_d_e__exception.html">ProSHADE_exception</a> ( <span class="stringliteral">&quot;The LAPACK complex SVD algorithm did not converge!&quot;</span>, <span class="stringliteral">&quot;EL00022&quot;</span>, __FILE__, __LINE__, __func__, <span class="stringliteral">&quot;LAPACK algorithm for computing the singular value\n                    : decomposition of complex matrices did not converge and\n                    : therefore it was not possible to optimise the peak\n                    : positions in the (self-)rotation function. Changing the\n                    : resolution may help, contact me if this error persists.&quot;</span> );</div>
<div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;    }</div>
<div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;    <span class="keywordflow">if</span> ( ( returnValue != 0 ) &amp;&amp; ( !fail ) )</div>
<div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;    {</div>
<div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;        uAndV[0]                                      =  -777.7;</div>
<div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;        return ;</div>
<div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;    }</div>
<div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;    </div>
<div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;    <span class="comment">//================================================ Save U</span></div>
<div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;    <span class="keywordflow">for</span> ( proshade_signed rowIt = 0; rowIt &lt; dim; rowIt++ )</div>
<div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;    {</div>
<div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;        <span class="keywordflow">for</span> ( proshade_signed colIt = 0; colIt &lt; dim; colIt++ )</div>
<div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;        {</div>
<div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;            uAndV[(rowIt*3)+colIt]                    = rotMatU[rowIt][colIt].real();</div>
<div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;        }</div>
<div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;    }</div>
<div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;    </div>
<div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;    <span class="comment">//================================================ Save V</span></div>
<div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;    <span class="keywordflow">for</span> ( proshade_signed rowIt = 0; rowIt &lt; dim; rowIt++ )</div>
<div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;    {</div>
<div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;        <span class="keywordflow">for</span> ( proshade_signed colIt = 0; colIt &lt; dim; colIt++ )</div>
<div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;        {</div>
<div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;            uAndV[(rowIt*3)+colIt+9]                  = rotMatV[rowIt][colIt].real();</div>
<div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;        }</div>
<div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;    }</div>
<div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;    </div>
<div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;    return ;</div>
<div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;    </div>
<div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a254fece06e1cfce122a11ddea4f71970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254fece06e1cfce122a11ddea4f71970">&#9670;&nbsp;</a></span>complexMultiplication()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::complexMultiplication </td>
          <td>(</td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>retReal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>retImag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to multiply two complex numbers. </p>
<p>This function takes pointers to the real and imaginary parts of two complex numbers and returns the result of their multiplication.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r1</td><td>Pointer to the real value of number 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i1</td><td>Pointer to the imaginary value of number 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r2</td><td>Pointer to the real value of number 2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i2</td><td>Pointer to the imaginary value of number 2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">retReal</td><td>Pointer to the real part of the complex variable to which the result will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">retImag</td><td>Pointer to the imaginary part of the complex variable to which the result will be saved. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00038">38</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;{</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    <span class="comment">//================================================ Multiplication</span></div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    *retReal                                          = (*r1)*(*r2) - (*i1)*(*i2);</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    *retImag                                          = (*r1)*(*i2) + (*i1)*(*r2);</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    </div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <span class="comment">//================================================ Return</span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    return ;</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    </div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2ca5a3aedba75f52aaf707edc4e790f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ca5a3aedba75f52aaf707edc4e790f7">&#9670;&nbsp;</a></span>complexMultiplicationConjug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::complexMultiplicationConjug </td>
          <td>(</td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>retReal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>retImag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to multiply two complex numbers by using the second number's conjugate. </p>
<p>This function takes pointers to the real and imaginary parts of two complex numbers and returns the result of their multiplication, while using the conjugate of the second complex number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r1</td><td>Pointer to the real value of number 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i1</td><td>Pointer to the imaginary value of number 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r2</td><td>Pointer to the real value of number 2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i2</td><td>Pointer to the imaginary value of number 2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">retReal</td><td>Pointer to the real part of the complex variable to which the result will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">retImag</td><td>Pointer to the imaginary part of the complex variable to which the result will be saved. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00062">62</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;{</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    <span class="comment">//================================================ Multiplication</span></div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    *retReal                                          =  (*r1)*(*r2) + (*i1)*(*i2);</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    *retImag                                          = -(*r1)*(*i2) + (*i1)*(*r2);</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    </div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    <span class="comment">//================================================ Return</span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    return ;</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    </div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="abc59a55f5ed21de90e351005c58a871e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc59a55f5ed21de90e351005c58a871e">&#9670;&nbsp;</a></span>complexMultiplicationConjugRealOnly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">proshade_double ProSHADE_internal_maths::complexMultiplicationConjugRealOnly </td>
          <td>(</td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to conjuggate multiply two complex numbers and return the real part only. </p>
<p>This function takes pointers to the real and imaginary parts of two complex numbers and returns the real part of the result of their conjugate multiplication.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r1</td><td>Pointer to the real value of number 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i1</td><td>Pointer to the imaginary value of number 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r2</td><td>Pointer to the real value of number 2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i2</td><td>Pointer to the imaginary value of number 2. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00103">103</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;{</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    <span class="comment">//================================================ Multiplication</span></div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    proshade_double ret                               = (*r1)*(*r2) + (*i1)*(*i2);</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    </div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    <span class="comment">//================================================ Return</span></div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    <span class="keywordflow">return</span>                                            ( ret );</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    </div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac9b05344ffead449c29a333a57b404f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b05344ffead449c29a333a57b404f6">&#9670;&nbsp;</a></span>complexMultiplicationRealOnly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">proshade_double ProSHADE_internal_maths::complexMultiplicationRealOnly </td>
          <td>(</td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to multiply two complex numbers and return the real part only. </p>
<p>This function takes pointers to the real and imaginary parts of two complex numbers and returns the real part of the result of their multiplication.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r1</td><td>Pointer to the real value of number 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i1</td><td>Pointer to the imaginary value of number 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r2</td><td>Pointer to the real value of number 2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i2</td><td>Pointer to the imaginary value of number 2. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00083">83</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;{</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    <span class="comment">//================================================ Multiplication</span></div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    proshade_double ret                               = (*r1)*(*r2) - (*i1)*(*i2);</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    </div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    <span class="comment">//================================================ Return</span></div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    <span class="keywordflow">return</span>                                            ( ret );</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    </div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2ac3b534f974de25b092e9d48d9f7dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac3b534f974de25b092e9d48d9f7dea">&#9670;&nbsp;</a></span>computeDotProduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">proshade_double ProSHADE_internal_maths::computeDotProduct </td>
          <td>(</td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>z1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>z2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple 3D vector dot product computation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x1</td><td>The x-axis element of the first vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y1</td><td>The y-axis element of the first vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z1</td><td>The z-axis element of the first vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x2</td><td>The x-axis element of the second vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y2</td><td>The y-axis element of the second vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z2</td><td>The z-axis element of the second vector. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01304">1304</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160;{</div>
<div class="line"><a name="l01306"></a><span class="lineno"> 1306</span>&#160;    <span class="comment">//================================================ Compute and return</span></div>
<div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;    <span class="keywordflow">return</span>                                            ( (*x1 * *x2) + (*y1 * *y2) + (*z1 * *z2) );</div>
<div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7e69b64278319ae1a1268d1a55545675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e69b64278319ae1a1268d1a55545675">&#9670;&nbsp;</a></span>evaluateGLSeries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">proshade_double ProSHADE_internal_maths::evaluateGLSeries </td>
          <td>(</td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>series</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>terms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function evaluates the Taylor expansion. </p>
<p>This function takes the series array, the target value and the cap on Taylor expansion and proceeds to evaluate the series. The main use of this is to evaluate the series twice, one where the series evaluation 'overshoots' and once where it 'undershoots' and taking value in between those, thus adding accuracy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">series</td><td>Pointer to array with the series values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>The target location on the series value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">terms</td><td>The Taylor expansion cap. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>The value of the series at the target location. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00442">442</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;{</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;    <span class="comment">//================================================ Initalise</span></div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;    proshade_double factorialValue                    = 1.0;</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;    proshade_double value                             = 0.0;</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;    </div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;    <span class="comment">//================================================ Compute</span></div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 1; iter &lt;= terms; iter++ )</div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;    {</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;        value                                         = value + series[iter] * factorialValue;</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;        factorialValue                                = factorialValue * target;</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;    }</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;    </div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;    <span class="keywordflow">return</span> ( value );</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;    </div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3d4604176a61820f5fcb95e372861c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4604176a61820f5fcb95e372861c1d">&#9670;&nbsp;</a></span>gaussLegendreIntegration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::gaussLegendreIntegration </td>
          <td>(</td>
          <td class="paramtype">proshade_complex *&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>valsSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>abscissas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>integralOverRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>maxSphereDists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>retReal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>retImag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute the complete complex Gauss-Legendre integration over spherical harmonic values in different shells. </p>
<p>This function takes the real parts of the spherical harmonics value in different shells and proceeds to compute the Gauss-Legendre integration over them. It uses the shell positions to appropriately place abscissas and their weights, which it assumes were pre-computed by the <a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a6e2f7de1bba288270ce2cc772d28d065" title="Function to prepare abscissas and weights for Gauss-Legendre integration.">getLegendreAbscAndWeights()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vals</td><td>Pointer to a complex array of values over which the integration to be done. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valsSize</td><td>The length of the input array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>The integration order value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">abscissas</td><td>The allocated array for holding the abscissa values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>The allocated array for holding the weight values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">integralOverRange</td><td>The range of the intgral. If progressive shell mapping is used, this will not be max shell radius. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxSphereDists</td><td>Distance between two shells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">retReal</td><td>The real part of the complex result of Gauss-Legendre integration over the shperical harmonics values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">retImag</td><td>The imaginary part of the complex result of Gauss-Legendre integration over the shperical harmonics values. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00704">704</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;{</div>
<div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;    <span class="comment">//================================================ Initialise local variables</span></div>
<div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;    proshade_triplet* intData                         = <span class="keyword">new</span> proshade_triplet [order];</div>
<div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a> ( intData, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;    proshade_triplet posVals;</div>
<div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;    proshade_unsign lesserPos                         = 0;</div>
<div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;    proshade_unsign upperPos                          = 0;</div>
<div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;    proshade_double lesserWeight                      = 0.0;</div>
<div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;    proshade_double upperWeight                       = 0.0;</div>
<div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;    </div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;    <span class="comment">//================================================ Rescale to &lt;order&gt; points</span></div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign absIter = 0; absIter &lt; order; absIter++ )</div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;    {</div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;        <span class="comment">//============================================ Init loop</span></div>
<div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;        posVals[0]                                    = 0.0;</div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;        posVals[1]                                    = 0.0;</div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;        posVals[2]                                    = 0.0;</div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;        </div>
<div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;        <span class="comment">//============================================ Find real position of abscissas</span></div>
<div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;        posVals[0]                                    = ( ( abscissas[absIter] + 1.0 ) / 2.0 ) * integralOverRange;</div>
<div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;        </div>
<div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;        </div>
<div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;        <span class="comment">//============================================ Find lesser and upper bounds</span></div>
<div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign valIt = 0; valIt &lt; valsSize; valIt++ )</div>
<div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;        {</div>
<div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;            <span class="keywordflow">if</span> ( ( ( valIt * maxSphereDists ) &lt;=  posVals[0] ) &amp;&amp; ( ( ( valIt + 1 ) * maxSphereDists ) &gt; posVals[0] ) )</div>
<div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;            {</div>
<div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;                lesserPos                             = <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( valIt );</div>
<div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;                upperPos                              = <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( valIt + 1 );</div>
<div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;                <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;            }</div>
<div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;        }</div>
<div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;        </div>
<div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;        <span class="comment">//============================================ Linear Interpolation</span></div>
<div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;        lesserWeight                                  = 0.0;</div>
<div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;        upperWeight                                   = 0.0;</div>
<div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;        <span class="keywordflow">if</span> ( lesserPos != 0 )</div>
<div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;        {</div>
<div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;            <span class="comment">//======================================== Here we realise that the lesser and upper bounds were determined on scale 1 ... N, while our values are on scale 0 ... N-1 and therefore after determining the linear interpolation weights, we subtract 1 from both lesserPos and upperPos; however ...</span></div>
<div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;            lesserWeight                              = upperPos - ( posVals[0] / maxSphereDists );</div>
<div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;            upperWeight                               = 1.0 - lesserWeight;</div>
<div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;                    </div>
<div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;            posVals[1]                                = ( lesserWeight * vals[lesserPos-1][0] ) + ( upperWeight * vals[upperPos-1][0] );</div>
<div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;            posVals[2]                                = ( lesserWeight * vals[lesserPos-1][1] ) + ( upperWeight * vals[upperPos-1][1] );</div>
<div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;        }</div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;        {</div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;            <span class="comment">//======================================== ... this then means that we would require position -1 for when the integration value is between 0 and the first shell. To resolve this, we assume that the values are 0 below the first shell and proceed as follows:</span></div>
<div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;            upperWeight                               = 1.0 - ( upperPos - ( posVals[0] / maxSphereDists ) );</div>
<div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;                    </div>
<div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;            posVals[1]                                = ( upperWeight * vals[upperPos-1][0] );</div>
<div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;            posVals[2]                                = ( upperWeight * vals[upperPos-1][1] );</div>
<div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;        }</div>
<div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;                </div>
<div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;        intData[absIter][0]                           = posVals[0];</div>
<div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;        intData[absIter][1]                           = posVals[1];</div>
<div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;        intData[absIter][2]                           = posVals[2];</div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;    }</div>
<div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;    </div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;    <span class="comment">//================================================ Integrate</span></div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;   *retReal                                           = 0.0;</div>
<div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;   *retImag                                           = 0.0;</div>
<div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign absPoint = 0; absPoint &lt; order; absPoint++ )</div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;    {</div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;       *retReal                                      += ( weights[absPoint] * intData[absPoint][1] );</div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;       *retImag                                      += ( weights[absPoint] * intData[absPoint][2] );</div>
<div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;    }</div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;    </div>
<div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;    <span class="comment">//================================================ Normalise</span></div>
<div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;   *retReal                                          *= ( integralOverRange / 2.0 );</div>
<div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;   *retImag                                          *= ( integralOverRange / 2.0 );</div>
<div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;    </div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;    <span class="comment">//================================================ Release memory</span></div>
<div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;    <span class="keyword">delete</span>[] intData;</div>
<div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;    </div>
<div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;    return ;</div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;    </div>
<div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a62133f51851217e3cb28dff2f520d192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62133f51851217e3cb28dff2f520d192">&#9670;&nbsp;</a></span>gaussLegendreIntegrationReal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">proshade_double ProSHADE_internal_maths::gaussLegendreIntegrationReal </td>
          <td>(</td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>valsSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>abscissas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>integralOverRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>maxSphereDists</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute real part of the Gauss-Legendre integration over spherical harmonic values in different shells. </p>
<p>This function takes the real parts of the spherical harmonics value in different shells and proceeds to compute the Gauss-Legendre integration over them. It uses the shell positions to appropriately place abscissas and their weights, which it assumes were pre-computed by the <a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a6e2f7de1bba288270ce2cc772d28d065" title="Function to prepare abscissas and weights for Gauss-Legendre integration.">getLegendreAbscAndWeights()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vals</td><td>Pointer to an array of values over which the integration to be done. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valsSize</td><td>The length of the input array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>The integration order value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">abscissas</td><td>The allocated array for holding the abscissa values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>The allocated array for holding the weight values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">integralOverRange</td><td>The range of the intgral. If progressive shell mapping is used, this will not be max shell radius. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxSphereDists</td><td>Distance between two shells. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>The real part of Gauss-Legendre integration over the shperical harmonics values. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00614">614</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;{</div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;    <span class="comment">//================================================ Initialise local variables</span></div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;    proshade_double ret                               = 0.0;</div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;    proshade_complex* intData                         = <span class="keyword">new</span> proshade_complex [order];</div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a> ( intData, __FILE__, __LINE__, __func__ );</div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;    proshade_complex posVals;</div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;    proshade_unsign lesserPos                         = 0;</div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;    proshade_unsign upperPos                          = 0;</div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;    proshade_double lesserWeight                      = 0.0;</div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;    proshade_double upperWeight                       = 0.0;</div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;    </div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;    <span class="comment">//================================================ Rescale to &lt;order&gt; points</span></div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign absIter = 0; absIter &lt; order; absIter++ )</div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;    {</div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;        <span class="comment">//============================================ Init loop</span></div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;        posVals[0]                                    = 0.0;</div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;        posVals[1]                                    = 0.0;</div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;        </div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;        <span class="comment">//============================================ Find real position of abscissas</span></div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;        posVals[0]                                    = ( ( abscissas[absIter] + 1.0 ) / 2.0 ) * integralOverRange;</div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;        </div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160; </div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;        <span class="comment">//============================================ Find lesser and upper bounds</span></div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign valIt = 0; valIt &lt; valsSize; valIt++ )</div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;        {</div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;            <span class="keywordflow">if</span> ( ( ( valIt * maxSphereDists ) &lt;=  posVals[0] ) &amp;&amp; ( ( ( valIt + 1 ) * maxSphereDists ) &gt; posVals[0] ) )</div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;            {</div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;                lesserPos                             = <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( valIt );</div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;                upperPos                              = <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( valIt + 1 );</div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;                <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;            }</div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;        }</div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;        </div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;        <span class="comment">//============================================ Linear Interpolation</span></div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;        lesserWeight                                  = 0.0;</div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;        upperWeight                                   = 0.0;</div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;        <span class="keywordflow">if</span> ( lesserPos != 0 )</div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;        {</div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;            <span class="comment">//======================================== Here we realise that the lesser and upper bounds were determined on scale 1 ... N, while our values are on scale 0 ... N-1 and therefore after determining the linear interpolation weights, we subtract 1 from both lesserPos and upperPos; however ...</span></div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;            lesserWeight                              = upperPos - ( posVals[0] / maxSphereDists );</div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;            upperWeight                               = 1.0 - lesserWeight;</div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;                    </div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;            posVals[1]                                = ( lesserWeight * vals[lesserPos-1] ) + ( upperWeight * vals[upperPos-1] );</div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;        }</div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;        {</div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;            <span class="comment">//======================================== ... this then means that we would require position -1 for when the integration value is between 0 and the first shell. To resolve this, we assume that the values are 0 below the first shell and proceed as follows:</span></div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;            upperWeight                               = 1.0 - ( upperPos - ( posVals[0] / maxSphereDists ) );</div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;                    </div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;            posVals[1]                                = ( upperWeight * vals[upperPos-1] );</div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;        }</div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;                </div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;        intData[absIter][0]                           = posVals[0];</div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;        intData[absIter][1]                           = posVals[1];</div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;    }</div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160; </div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;    <span class="comment">//================================================ Integrate</span></div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign absPoint = 0; absPoint &lt; order; absPoint++ )</div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;    {</div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;        ret                                          += ( weights[absPoint] * intData[absPoint][1] );</div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;    }</div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;    </div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;    <span class="comment">//================================================ Normalise</span></div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;    ret                                              *= ( integralOverRange / 2.0 );</div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;    </div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;    <span class="comment">//================================================ Release memory</span></div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;    <span class="keyword">delete</span>[] intData;</div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;    </div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;    <span class="keywordflow">return</span>                                            ( ret );</div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;    </div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aafc6f1626c7463de53c9f4f6fa11db22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc6f1626c7463de53c9f4f6fa11db22">&#9670;&nbsp;</a></span>getAxisAngleFromRotationMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::getAxisAngleFromRotationMatrix </td>
          <td>(</td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>rotMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>ang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts rotation matrix to the axis-angle representation. </p>
<p>This function takes a rotation matrix as an array of 9 numbers and converts it to the Angle-Axis representation, which is the main rotation representation used in ProSHADE. This function deals with both the North and South pole singularity of the rotation matrices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rotMat</td><td>Rotation matrix as an array of 9 values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Pointer to which the x-axis value of the axis vector will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Pointer to which the y-axis value of the axis vector will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>Pointer to which the z-axis value of the axis vector will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ang</td><td>Pointer to which the angle value will be saved. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00994">994</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;{</div>
<div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;    <span class="comment">//================================================ Initialise</span></div>
<div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;    proshade_double singAtPiCheck                     = 0.01;</div>
<div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;    proshade_double singAtIdentity                    = 0.05;</div>
<div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;    </div>
<div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;    <span class="comment">//================================================ Check input for singularities</span></div>
<div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;    <span class="keywordflow">if</span> ( ( std::abs ( rotMat[1] - rotMat[3] ) &lt; singAtPiCheck ) &amp;&amp;</div>
<div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;         ( std::abs ( rotMat[2] - rotMat[6] ) &lt; singAtPiCheck ) &amp;&amp;</div>
<div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;         ( std::abs ( rotMat[5] - rotMat[7] ) &lt; singAtPiCheck ) )</div>
<div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;    {</div>
<div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;        <span class="comment">//============================================ Singularity in input! Check for identity matrix</span></div>
<div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;        <span class="keywordflow">if</span> ( ( std::abs ( rotMat[1] + rotMat[3] ) &lt; singAtIdentity ) &amp;&amp;</div>
<div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;             ( std::abs ( rotMat[2] + rotMat[6] ) &lt; singAtIdentity ) &amp;&amp;</div>
<div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;             ( std::abs ( rotMat[5] + rotMat[7] ) &lt; singAtIdentity ) &amp;&amp;</div>
<div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;             ( std::abs ( rotMat[0] + rotMat[4] + rotMat[8] - 3.0 ) &lt; singAtIdentity ) )</div>
<div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;        {</div>
<div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;            <span class="comment">//======================================== Identity matrix. Return 0 angle.</span></div>
<div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;           *x                                         = 1.0;</div>
<div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;           *y                                         = 0.0;</div>
<div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;           *z                                         = 0.0;</div>
<div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;           *ang                                       = 0.0;</div>
<div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;            </div>
<div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;            <span class="comment">//======================================== Done</span></div>
<div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;            return ;</div>
<div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;        }</div>
<div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;        </div>
<div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;        <span class="comment">//============================================ If we got here, this is the 180deg (pi rad) singularity. Find which axis should the rotation be done along</span></div>
<div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;       *ang                                           = M_PI;</div>
<div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;                </div>
<div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;        proshade_double xx                            = ( rotMat[0] + 1.0 ) / 2.0;</div>
<div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;        proshade_double yy                            = ( rotMat[4] + 1.0 ) / 2.0;</div>
<div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;        proshade_double zz                            = ( rotMat[8] + 1.0 ) / 2.0;</div>
<div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;        proshade_double xy                            = ( rotMat[1] + rotMat[3] ) / 4.0;</div>
<div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;        proshade_double xz                            = ( rotMat[2] + rotMat[6] ) / 4.0;</div>
<div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;        proshade_double yz                            = ( rotMat[5] + rotMat[7] ) / 4.0;</div>
<div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;        </div>
<div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;        <span class="keywordflow">if</span> ( ( xx &gt; yy ) &amp;&amp; ( xx &gt; zz ) ) <span class="comment">// XX is the largest diagonal</span></div>
<div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;        {</div>
<div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;            <span class="keywordflow">if</span> ( xx &lt; singAtPiCheck ) <span class="comment">// and is still 0</span></div>
<div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;            {</div>
<div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;               *x                                     = 0.0;</div>
<div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;               *y                                     = 1.0 / sqrt(2);</div>
<div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;               *z                                     = 1.0 / sqrt(2);</div>
<div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;            }</div>
<div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;            {</div>
<div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;               *x                                     =  sqrt ( xx );</div>
<div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;               *y                                     =  xy / sqrt ( xx );</div>
<div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;               *z                                     =  xz / sqrt ( xx );</div>
<div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;            }</div>
<div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;        }</div>
<div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;        </div>
<div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( yy &gt; zz ) <span class="comment">// YY is the largest diagonal</span></div>
<div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;        {</div>
<div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;            <span class="keywordflow">if</span> ( yy &lt; singAtPiCheck ) <span class="comment">// and is still 0</span></div>
<div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;            {</div>
<div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;               *x                                     =  1.0 / sqrt(2);</div>
<div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;               *y                                     =  0.0;</div>
<div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;               *z                                     =  1.0 / sqrt(2);</div>
<div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;            }</div>
<div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;            {</div>
<div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;               *y                                     =  sqrt ( yy );</div>
<div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;               *x                                     =  xy / sqrt ( yy );</div>
<div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;               *z                                     =  yz / sqrt ( yy );</div>
<div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;            }</div>
<div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;        }</div>
<div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;        </div>
<div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;        <span class="keywordflow">else</span> <span class="comment">// ZZ is the largest diagonal</span></div>
<div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;        {</div>
<div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;            <span class="keywordflow">if</span> ( zz &lt; singAtPiCheck ) <span class="comment">// and is still 0</span></div>
<div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;            {</div>
<div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;               *x                                     = 1.0 / sqrt(2);</div>
<div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;               *y                                     = 1.0 / sqrt(2);</div>
<div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;               *z                                     = 0.0;</div>
<div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;            }</div>
<div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;            {</div>
<div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;               *z                                     = sqrt ( zz );</div>
<div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;               *x                                     = xz / sqrt ( zz );</div>
<div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;               *y                                     = yz / sqrt ( zz );</div>
<div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;            }</div>
<div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;        }</div>
<div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;        </div>
<div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;        <span class="comment">//============================================ Done</span></div>
<div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;        return ;</div>
<div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;    }</div>
<div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;    </div>
<div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;    <span class="comment">//================================================ No singularities! Now get angle</span></div>
<div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;   *ang                                               = std::acos ( ( std::max ( -1.0, std::min ( 3.0, rotMat[0] + rotMat[4] + rotMat[8] ) ) - 1.0 ) / 2.0 );</div>
<div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;    </div>
<div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;    <span class="comment">//================================================ Init return values</span></div>
<div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;   *x                                                 = 1.0;</div>
<div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;   *y                                                 = 0.0;</div>
<div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;   *z                                                 = 0.0;</div>
<div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;    </div>
<div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;    <span class="comment">//================================================ Is angle 0? This should not happen, but will</span></div>
<div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;    <span class="keywordflow">if</span> ( std::abs ( *ang ) &lt; singAtPiCheck )</div>
<div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;    {</div>
<div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;       *ang                                           = 0.0;</div>
<div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;        return ;</div>
<div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;    }</div>
<div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;    </div>
<div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;    <span class="comment">//================================================ Axis</span></div>
<div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;   *x                                                 = rotMat[7] - rotMat[5];</div>
<div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;   *y                                                 = rotMat[2] - rotMat[6];</div>
<div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;   *z                                                 = rotMat[3] - rotMat[1];</div>
<div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;    proshade_double normFactor                        = pow ( *x, 2.0 ) + pow ( *y, 2.0 ) + pow ( *z, 2.0 );</div>
<div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;            </div>
<div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;    <span class="keywordflow">if</span> ( normFactor &gt; singAtPiCheck )</div>
<div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;    {</div>
<div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;        normFactor                                    = sqrt ( normFactor );</div>
<div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;       *x                                            /= normFactor;</div>
<div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;       *y                                            /= normFactor;</div>
<div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;       *z                                            /= normFactor;</div>
<div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;    }</div>
<div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;    </div>
<div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;    return ;</div>
<div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;    </div>
<div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae6f6afcef5b90ca77d7d6a9e91824e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f6afcef5b90ca77d7d6a9e91824e28">&#9670;&nbsp;</a></span>getEulerZXZFromRotMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::getEulerZXZFromRotMatrix </td>
          <td>(</td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>rotMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>eA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>eB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>eG</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts rotation matrix to the Euler ZXZ angles representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rotMat</td><td>Rotation matrix as an array of 9 values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eA</td><td>Pointer to which the Euler angle alpha value will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eB</td><td>Pointer to which the Euler angle beta value will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eG</td><td>Pointer to which the Euler angle gamma value will be saved. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01176">1176</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;{</div>
<div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;    <span class="comment">//================================================ Get ZXZ Euler from matrix</span></div>
<div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;   *eA                                                = atan2 ( rotMat[7],  rotMat[6] );</div>
<div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;   *eB                                                = acos  ( rotMat[8] );</div>
<div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;   *eG                                                = atan2 ( rotMat[5], -rotMat[2] );</div>
<div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;    </div>
<div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;    <span class="comment">//================================================ Solve undefined 0,0 inputs (i.e. identity matrix)</span></div>
<div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;    proshade_double errLimit                          = 0.001;</div>
<div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;    <span class="keywordflow">if</span> ( ( ( rotMat[7] &lt; errLimit ) &amp;&amp; ( rotMat[7] &gt; -errLimit ) ) &amp;&amp; ( ( rotMat[6] &lt; errLimit ) &amp;&amp; ( rotMat[6] &gt; -errLimit ) ) )</div>
<div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;    {</div>
<div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;        <span class="comment">//============================================ atan2 (0,0) is undefined, we want 0.0 here</span></div>
<div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;       *eA                                            = 0.0;</div>
<div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;    }</div>
<div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;    </div>
<div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;    <span class="keywordflow">if</span> ( ( ( rotMat[5] &lt; errLimit ) &amp;&amp; ( rotMat[5] &gt; -errLimit ) ) &amp;&amp; ( ( rotMat[2] &lt; errLimit ) &amp;&amp; ( rotMat[2] &gt; -errLimit ) ) )</div>
<div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;    {</div>
<div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;        <span class="comment">//============================================ atan2 (0,0) is undefined, we want 0.0 here</span></div>
<div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;       *eG                                            = 0.0;</div>
<div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;    }</div>
<div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;    </div>
<div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;    <span class="comment">//================================================ Get the angles to proper range</span></div>
<div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;    <span class="keywordflow">if</span> ( *eA &lt; 0.0 ) { *eA                            = 2.0 * M_PI + *eA; }</div>
<div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;    <span class="keywordflow">if</span> ( *eB &lt; 0.0 ) { *eB                            =       M_PI + *eB; }</div>
<div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;    <span class="keywordflow">if</span> ( *eG &lt; 0.0 ) { *eG                            = 2.0 * M_PI + *eG; }</div>
<div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;    </div>
<div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;    return ;</div>
<div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;    </div>
<div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="acf6c5376edac98e54ef0e418cd05d706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6c5376edac98e54ef0e418cd05d706">&#9670;&nbsp;</a></span>getEulerZXZFromSOFTPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::getEulerZXZFromSOFTPosition </td>
          <td>(</td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>band</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>eulerAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>eulerBeta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>eulerGamma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to find Euler angles (ZXZ convention) from index position in the inverse SOFT map. </p>
<p>This function proceeds to convert the inverse SOFT map x, y and z position to Euler ZXZ convention angles, saving these into the inputted pointers. It also changes the Euler angle ranges from (0,2PI&gt; to (-PI,PI&gt; as preferred by the functions using the results.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">band</td><td>The maximum bandwidth of the computation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The x-axis position in the inverse SOFT map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The x-axis position in the inverse SOFT map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>The x-axis position in the inverse SOFT map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eulerAlpha</td><td>Pointer to where the Euler alpha angle will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eulerBeta</td><td>Pointer to where the Euler beta angle will be saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eulerGamma</td><td>Pointer to where the Euler gamma angle will be saved. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00941">941</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;{</div>
<div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;    <span class="comment">//================================================ Convert index to Euler angles</span></div>
<div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;   *eulerGamma                                        = ( M_PI * y / ( <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( band ) ) );</div>
<div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;   *eulerBeta                                         = ( M_PI * ( 2.0 * x + 1.0 ) / <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( 4.0 * band ) )  ;</div>
<div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;   *eulerAlpha                                        = ( M_PI * z / ( <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( band ) ) );</div>
<div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;    </div>
<div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;    return ;</div>
<div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;    </div>
<div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1823adaca871244e42347ecb8ed834a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1823adaca871244e42347ecb8ed834a2">&#9670;&nbsp;</a></span>getGLFirstEvenRoot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::getGLFirstEvenRoot </td>
          <td>(</td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>polyAtZero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>abscAtZero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>weighAtZero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>taylorSeriesCap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function finds the first root for Legendre polynomials of odd order. </p>
<p>The Legendre polynomials with odd order have zero as the first root, but the even oder polenomials have different value and this function serves the purpose of finding this value (i.e. the first root of the polynomial if the order is even).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polyAtZero</td><td>The value of the polynomial at zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>The positive integer value of the polynomial order. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">abscAtZero</td><td>Pointer to variable storing the abscissa value at zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weightAtZero</td><td>Pointer to variable storing the weight value at zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">taylorSeriesCap</td><td>The limit on the Taylor series. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00379">379</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;{</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;    <span class="comment">//================================================ Sanity check</span></div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;    <span class="keywordflow">if</span> ( taylorSeriesCap &lt; 2 )</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;    {</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;        <span class="keywordflow">throw</span> <a class="code" href="class_pro_s_h_a_d_e__exception.html">ProSHADE_exception</a> ( <span class="stringliteral">&quot;The Taylor series cap is too low.&quot;</span>, <span class="stringliteral">&quot;EI00020&quot;</span>, __FILE__, __LINE__, __func__, <span class="stringliteral">&quot;The Taylor series expansion limit is less than 2. This\n                    : seems very low; if you have a very small structure or very\n                    : low resolution, please manually increase the integration\n                    : order. Otherwise, please report this as a bug.&quot;</span> );</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;    }</div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;    </div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;   *abscAtZero                                        = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a4f2619c7f3b8d628af9cb356778e9807">advanceGLPolyValue</a> ( 0.0, -M_PI / 2.0, 0.0, order, taylorSeriesCap );</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;    proshade_double hlp                               = 0.0;</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;    proshade_double hlpVal                            = <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( order );</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    proshade_double *abscSteps;</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    proshade_double *weightSteps;</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160; </div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;    <span class="comment">//================================================ Allocate memory</span></div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    abscSteps                                         = <span class="keyword">new</span> proshade_double [taylorSeriesCap+2];</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;    weightSteps                                       = <span class="keyword">new</span> proshade_double [taylorSeriesCap+1];</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160; </div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;    <span class="comment">//================================================ Pre-set values</span></div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;    abscSteps[0]                                      = 0.0;</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;    abscSteps[1]                                      = polyAtZero;</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;    weightSteps[0]                                    = 0.0;</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160; </div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    <span class="comment">//================================================ Fill in abscissa and weight steps</span></div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt;= taylorSeriesCap - 2; iter = iter + 2 )</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;    {</div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;        hlp                                           = <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( iter );</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;        </div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;        abscSteps[iter+2]                             = 0.0;</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;        abscSteps[iter+3]                             = ( hlp * ( hlp + 1.0 ) - hlpVal * ( hlpVal + 1.0 ) ) * abscSteps[iter+1] / (hlp + 1.0) / (hlp + 2.0 );</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;        </div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;        weightSteps[iter+1]                           = 0.0;</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;        weightSteps[iter+2]                           = ( hlp + 2.0 ) * abscSteps[iter+3];</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;    }</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160; </div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;    <span class="comment">//================================================ Find abscissa and weights</span></div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;    <span class="keywordflow">for</span> ( proshade_double iter = 0; iter &lt; 5; iter++ )</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;    {</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;        *abscAtZero                                   = *abscAtZero - <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a7e69b64278319ae1a1268d1a55545675">evaluateGLSeries</a> ( abscSteps, *abscAtZero, taylorSeriesCap ) / <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a7e69b64278319ae1a1268d1a55545675">evaluateGLSeries</a> ( weightSteps, *abscAtZero, taylorSeriesCap-1 );</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;    }</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    *weighAtZero                                      = <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a7e69b64278319ae1a1268d1a55545675">evaluateGLSeries</a> ( weightSteps, *abscAtZero, taylorSeriesCap-1 );</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160; </div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;    <span class="comment">//================================================ Free memory</span></div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;    <span class="keyword">delete</span> abscSteps;</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;    <span class="keyword">delete</span> weightSteps;</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160; </div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    return ;</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;    </div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="affab74b910cda2ee3faa461740a7a432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affab74b910cda2ee3faa461740a7a432">&#9670;&nbsp;</a></span>getGLPolyAtZero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::getGLPolyAtZero </td>
          <td>(</td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>polyValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>deriValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function obtains the Legendre polynomial values and its derivative at zero for any positive integer order polynomial. </p>
<p>This function takes the positive integer order of the Legendre polynomial and uses the recursive properties of the polynomials to work up to the order, computing the value at zero and its derivative for all lesser orders. It then returns the final values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Positive integer order of the Legendre polynomial which value at zero we want. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polyValue</td><td>Pointer to variable which will store the resulting polynomial value at zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deriValue</td><td>Pointer to variable which will store the derivative of the zero value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00342">342</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;{</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    <span class="comment">//================================================ Initialise</span></div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;    proshade_double hlpVal                            = 0.0;</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;    proshade_double prevPoly                          = 1.0;</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;    proshade_double prevPrevPoly                      = 0.0;</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    proshade_double prevDeri                          = 0.0;</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;    proshade_double prevPrevDeri                      = 0.0;</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;    </div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign ordIt = 0; ordIt &lt; order; ordIt++ )</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;    {</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;        hlpVal                                        = <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( ordIt );</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;        *polyValue                                    = -hlpVal * prevPrevPoly / ( hlpVal + 1.0 );</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;        *deriValue                                    = ( ( 2.0 * hlpVal + 1.0 ) * prevPoly - hlpVal * prevPrevDeri ) / ( hlpVal + 1.0 );</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;        prevPrevPoly                                  = prevPoly;</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;        prevPoly                                      = *polyValue;</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;        prevPrevDeri                                  = prevDeri;</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;        prevDeri                                      = *deriValue;</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    }</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;    </div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;    return ;</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;    </div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6e2f7de1bba288270ce2cc772d28d065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2f7de1bba288270ce2cc772d28d065">&#9670;&nbsp;</a></span>getLegendreAbscAndWeights()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::getLegendreAbscAndWeights </td>
          <td>(</td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>abscissas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>taylorSeriesCap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to prepare abscissas and weights for Gauss-Legendre integration. </p>
<p>...</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>The order to which the abscissas and weights should be prepared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">abscissas</td><td>The array holding the abscissa values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>The array holding the weight values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">taylorSeriesCap</td><td>The limit on the Taylor series. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00282">282</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;{</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;    <span class="comment">//================================================ Sanity check</span></div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;    <span class="keywordflow">if</span> ( order &lt; 2 )</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;    {</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;        <span class="keywordflow">throw</span> <a class="code" href="class_pro_s_h_a_d_e__exception.html">ProSHADE_exception</a> ( <span class="stringliteral">&quot;The integration order is too low.&quot;</span>, <span class="stringliteral">&quot;EI00019&quot;</span>, __FILE__, __LINE__, __func__, <span class="stringliteral">&quot;The Gauss-Legendre integration order is less than 2. This\n                    : seems very low; if you have a very small structure or very\n                    : low resolution, please manually increase the integration\n                    : order. Otherwise, please report this as a bug.&quot;</span> );</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;    }</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;    </div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;    <span class="comment">//================================================ Initialise</span></div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;    proshade_double polyValue                         = 0.0;</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;    proshade_double deriValue                         = 0.0;</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    proshade_double weightSum                         = 0.0;</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;    </div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;    <span class="comment">//================================================ Find the polynomial and derivative values at 0</span></div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#affab74b910cda2ee3faa461740a7a432">getGLPolyAtZero</a>                                   ( order,</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;                                                       &amp;polyValue,</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;                                                       &amp;deriValue );</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;    </div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    <span class="comment">//================================================ If the order is odd, then 0 is a root ...</span></div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;    <span class="keywordflow">if</span> ( order % 2 == 1 )</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;    {</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;        abscissas[((order-1)/2)]                      = polyValue;</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;        weights[((order-1)/2)]                        = deriValue;</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;    }</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;    {</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;        <span class="comment">// ... and if order is even, find the first root</span></div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a1823adaca871244e42347ecb8ed834a2">getGLFirstEvenRoot</a>                            ( polyValue, order, &amp;abscissas[(order/2)], &amp;weights[(order/2)], taylorSeriesCap );</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    }</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160; </div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;    <span class="comment">//================================================ Now, having computed the first roots, complete the series</span></div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;    <a class="code" href="namespace_pro_s_h_a_d_e__internal__maths.html#a31c91064de64aef9f8278d533f8188ad">completeLegendreSeries</a>                            ( order, abscissas, weights, taylorSeriesCap );</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160; </div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;    <span class="comment">//================================================ Correct weights by anscissa values</span></div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; order; iter++ )</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;    {</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;        weights[iter]                                 = 2.0 / ( 1.0 - abscissas[iter] ) / ( 1.0 + abscissas[iter] ) / weights[iter] / weights[iter];</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;        weightSum                                     = weightSum + weights[iter];</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;    }</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160; </div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;    <span class="comment">//================================================ Normalise weights</span></div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; order; iter++ )</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;    {</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;        weights[iter]                                 = 2.0 * weights[iter] / weightSum;</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;    }</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;    </div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;    return ;</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a39eafef902a49cc0816a2ed675c14a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39eafef902a49cc0816a2ed675c14a49">&#9670;&nbsp;</a></span>getRotationMatrixFromAngleAxis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::getRotationMatrixFromAngleAxis </td>
          <td>(</td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>rotMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>ang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts the axis-angle representation to the rotation matrix representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rotMat</td><td>Rotation matrix as an array of 9 values will be saved to this pointer, must already be allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The x-axis value of the axis vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The y-axis value of the axis vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>The z-axis value of the axis vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angThe</td><td>angle value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01125">1125</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;{</div>
<div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;    <span class="comment">//================================================ If angle is 0 or infinity (anything divided by 0), return identity matrix</span></div>
<div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;    <span class="keywordflow">if</span> ( ( ang == 0.0 ) || ( std::isinf ( ang ) ) )</div>
<div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;    {</div>
<div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;        <span class="comment">//============================================ Create identity</span></div>
<div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign i = 0; i &lt; 9; i++ ) { rotMat[i] = 0.0; }</div>
<div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;        rotMat[0]                                     = 1.0;</div>
<div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;        rotMat[4]                                     = 1.0;</div>
<div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;        rotMat[8]                                     = 1.0;</div>
<div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;        </div>
<div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;        <span class="comment">//============================================ Done</span></div>
<div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;        return ;</div>
<div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;    }</div>
<div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;    </div>
<div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;    <span class="comment">//================================================ Compute the matrix</span></div>
<div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;    proshade_double cAng                              = cos ( ang );</div>
<div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;    proshade_double sAng                              = sin ( ang );</div>
<div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;    proshade_double tAng                              = 1.0 - cAng;</div>
<div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;            </div>
<div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;    rotMat[0]                                         = cAng + x * x * tAng;</div>
<div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;    rotMat[4]                                         = cAng + y * y * tAng;</div>
<div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;    rotMat[8]                                         = cAng + z * z * tAng;</div>
<div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;            </div>
<div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;    proshade_double tmp1                              = x * y * tAng;</div>
<div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;    proshade_double tmp2                              = z * sAng;</div>
<div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;    rotMat[3]                                         = tmp1 + tmp2;</div>
<div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;    rotMat[1]                                         = tmp1 - tmp2;</div>
<div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;            </div>
<div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;    tmp1                                              = x * z * tAng;</div>
<div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;    tmp2                                              = y * sAng;</div>
<div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;    rotMat[6]                                         = tmp1 - tmp2;</div>
<div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;    rotMat[2]                                         = tmp1 + tmp2;</div>
<div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;            </div>
<div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;    tmp1                                              = y * z * tAng;</div>
<div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;    tmp2                                              = x * sAng;</div>
<div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;    rotMat[7]                                         = tmp1 + tmp2;</div>
<div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;    rotMat[5]                                         = tmp1 - tmp2;</div>
<div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;    </div>
<div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;    return ;</div>
<div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;    </div>
<div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="abd9fe573a48f499dd7d1df4f779222f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd9fe573a48f499dd7d1df4f779222f1">&#9670;&nbsp;</a></span>getRotationMatrixFromEulerZXZAngles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::getRotationMatrixFromEulerZXZAngles </td>
          <td>(</td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>eulerAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>eulerBeta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>eulerGamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to find the rotation matrix from Euler angles (ZXZ convention). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eulerAlpha</td><td>The Euler alpha angle value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eulerBeta</td><td>The Euler beta angle value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eulerGamma</td><td>The Euler gamma angle value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>A pointer to array of 9 values to which the results of the function will be saved. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00960">960</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;{</div>
<div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;    <span class="comment">//================================================ First row</span></div>
<div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;    matrix[0]                                         =  cos ( eulerAlpha ) * cos ( eulerBeta  ) * cos ( eulerGamma ) - sin ( eulerAlpha ) * sin ( eulerGamma );</div>
<div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;    matrix[1]                                         =  sin ( eulerAlpha ) * cos ( eulerBeta  ) * cos ( eulerGamma ) + cos ( eulerAlpha ) * sin ( eulerGamma );</div>
<div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;    matrix[2]                                         = -sin ( eulerBeta  ) * cos ( eulerGamma );</div>
<div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;  </div>
<div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;    <span class="comment">//================================================ Second row</span></div>
<div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;    matrix[3]                                         = -cos ( eulerAlpha ) * cos ( eulerBeta  ) * sin ( eulerGamma ) - sin ( eulerAlpha ) * cos ( eulerGamma );</div>
<div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;    matrix[4]                                         = -sin ( eulerAlpha ) * cos ( eulerBeta  ) * sin ( eulerGamma ) + cos ( eulerAlpha ) * cos ( eulerGamma );</div>
<div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;    matrix[5]                                         =  sin ( eulerBeta  ) * sin ( eulerGamma );</div>
<div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;  </div>
<div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;    <span class="comment">//================================================ Third row</span></div>
<div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;    matrix[6]                                         =  cos ( eulerAlpha ) * sin ( eulerBeta  );</div>
<div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;    matrix[7]                                         =  sin ( eulerAlpha ) * sin ( eulerBeta  );</div>
<div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;    matrix[8]                                         =  cos ( eulerBeta  );</div>
<div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;    </div>
<div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;    return ;</div>
<div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;    </div>
<div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac211e762a46e4c7e25235a651acfdc77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac211e762a46e4c7e25235a651acfdc77">&#9670;&nbsp;</a></span>multiplyTwoSquareMatrices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::multiplyTwoSquareMatrices </td>
          <td>(</td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute matrix multiplication. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function assumes the second matrix has been transposed already!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>The left matrix of the matrix multiplication to be solved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>The right matrix of the matrix multiplication to be solved. (Assuming it already has been transposed). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Matrix containing the results. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>The dimension of all the matrices (i.e. assuming square dim*dim matrices). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01216">1216</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160;{</div>
<div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160;    <span class="comment">//================================================ Compute the matrix multiplication</span></div>
<div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign row = 0; row &lt; dim; row++ )</div>
<div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;    {</div>
<div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;        <span class="keywordflow">for</span> ( proshade_unsign col  = 0; col &lt; dim; col++ )</div>
<div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;        {</div>
<div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;            <span class="keywordflow">for</span> ( proshade_unsign inner = 0; inner &lt; dim; inner++ )</div>
<div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;            {</div>
<div class="line"><a name="l01225"></a><span class="lineno"> 1225</span>&#160;                res[(row*dim)+col]                   += A[(inner*dim)+row] * B[(col*dim)+inner];</div>
<div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;            }</div>
<div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;        }</div>
<div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;    }</div>
<div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;    </div>
<div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;    return ;</div>
<div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;    </div>
<div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a01087ea3e0db56758d1771618e2e4a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01087ea3e0db56758d1771618e2e4a45">&#9670;&nbsp;</a></span>normalDistributionValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">proshade_double ProSHADE_internal_maths::normalDistributionValue </td>
          <td>(</td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>standardDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to the heiht of normal distribution given by mean and standard deviation for a given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mean</td><td>The mean of the normal distribution. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">standardDev</td><td>The standard deviation of the normal distribution. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value on the axis for which the height of the normal distribution is to be obtained. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>The height of the normal distribution at point given by the value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01288">1288</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;{</div>
<div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;    <span class="comment">//================================================ Compute and return</span></div>
<div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;    <span class="keywordflow">return</span>                                            ( ( 1.0 / sqrt ( 2.0 * M_PI * pow(standardDev,2.0) ) ) * std::exp ( - pow( value - mean, 2.0 ) / 2.0 * pow(standardDev,2.0) ) );</div>
<div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;    </div>
<div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a894d87e94446db04492b663e54a74bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a894d87e94446db04492b663e54a74bff">&#9670;&nbsp;</a></span>pearsonCorrCoeff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">proshade_double ProSHADE_internal_maths::pearsonCorrCoeff </td>
          <td>(</td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>valSet1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&#160;</td>
          <td class="paramname"><em>valSet2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_unsign&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for computing the Pearson's correlation coefficient. </p>
<p>This function takes two numerical arrays of same length and proceeds to compute the Pearson's correlation coefficient, which it then returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">valSet1</td><td>This is the set of x-values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valSet2</td><td>This is the set of y-values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length of both arrays (both arrays have to have the same length). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>The Pearson's correlation coefficient value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00240">240</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;{</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    <span class="comment">//================================================ Find vector means</span></div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    proshade_double xMean                             = 0.0;</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;    proshade_double yMean                             = 0.0;</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;    proshade_double zeroCount                         = 0.0;</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; length; iter++ )</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;    {</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;        xMean                                        += valSet1[iter];</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;        yMean                                        += valSet2[iter];</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;    }</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;    xMean                                            /= <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( length - zeroCount );</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;    yMean                                            /= <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( length - zeroCount );</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;    </div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;    <span class="comment">//================================================ Get Pearson&#39;s correlation coefficient</span></div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;    proshade_double xmmymm                            = 0.0;</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;    proshade_double xmmsq                             = 0.0;</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;    proshade_double ymmsq                             = 0.0;</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign iter = 0; iter &lt; length; iter++ )</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;    {</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;        xmmymm                                       += ( valSet1[iter] - xMean ) * ( valSet2[iter] - yMean );</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;        xmmsq                                        += pow( valSet1[iter] - xMean, 2.0 );</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;        ymmsq                                        += pow( valSet2[iter] - yMean, 2.0 );</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;    }</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;    </div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;    proshade_double ret                               = xmmymm / ( sqrt(xmmsq) * sqrt(ymmsq) );</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;    </div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;    <span class="keywordflow">if</span> ( std::isnan ( ret ) ) { <span class="keywordflow">return</span> ( 0.0 ); }</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;    <span class="keywordflow">return</span>                                            ( ret );</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    </div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6359dd366cdd986f5ad155bff8235a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6359dd366cdd986f5ad155bff8235a8e">&#9670;&nbsp;</a></span>primeFactorsDecomp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; proshade_signed &gt; ProSHADE_internal_maths::primeFactorsDecomp </td>
          <td>(</td>
          <td class="paramtype">proshade_signed&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to find prime factors of an integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">number</td><td>A single integer number to be decomposed into its prime factors. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l01239">1239</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160;{</div>
<div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160;    <span class="comment">//================================================ Initialise variables</span></div>
<div class="line"><a name="l01242"></a><span class="lineno"> 1242</span>&#160;    std::vector &lt; proshade_signed &gt; ret;</div>
<div class="line"><a name="l01243"></a><span class="lineno"> 1243</span>&#160;    </div>
<div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;    <span class="comment">//================================================ Deal with negative numbers</span></div>
<div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;    <span class="keywordtype">bool</span> changeSign                                   = <span class="keyword">false</span>;</div>
<div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;    <span class="keywordflow">if</span> ( number &lt; 0 ) { changeSign = <span class="keyword">true</span>; number = -number; }</div>
<div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;    </div>
<div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;    <span class="comment">//================================================ Deal with zero and one</span></div>
<div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;    <span class="keywordflow">if</span> ( number == 0 ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a8a52d854a63ecad80c1805d601ffcf96">ProSHADE_internal_misc::addToSignedVector</a> ( &amp;ret, 0 ); <span class="keywordflow">return</span> ( ret ); }</div>
<div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;    <span class="keywordflow">if</span> ( number == 1 ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a8a52d854a63ecad80c1805d601ffcf96">ProSHADE_internal_misc::addToSignedVector</a> ( &amp;ret, 1 ); <span class="keywordflow">return</span> ( ret ); }</div>
<div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;    </div>
<div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;    <span class="comment">//================================================ Divide by 2 as long as you can</span></div>
<div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;    <span class="keywordflow">while</span> ( number % 2 == 0 )</div>
<div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;    {</div>
<div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;        <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a8a52d854a63ecad80c1805d601ffcf96">ProSHADE_internal_misc::addToSignedVector</a>     ( &amp;ret, 2 );</div>
<div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160;        number                                        = number / 2;</div>
<div class="line"><a name="l01257"></a><span class="lineno"> 1257</span>&#160;    }</div>
<div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160;    </div>
<div class="line"><a name="l01259"></a><span class="lineno"> 1259</span>&#160;    <span class="comment">//================================================ Check all odd numbers up to the square root</span></div>
<div class="line"><a name="l01260"></a><span class="lineno"> 1260</span>&#160;    <span class="keywordflow">for</span> ( proshade_unsign posDiv = 3; posDiv &lt;= sqrt ( number ); posDiv += 2)</div>
<div class="line"><a name="l01261"></a><span class="lineno"> 1261</span>&#160;    {</div>
<div class="line"><a name="l01262"></a><span class="lineno"> 1262</span>&#160;        <span class="comment">// If posDiv is a divisor of the number, save the result</span></div>
<div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;        <span class="keywordflow">while</span> ( number % posDiv == 0 )</div>
<div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;        {</div>
<div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;            <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a8a52d854a63ecad80c1805d601ffcf96">ProSHADE_internal_misc::addToSignedVector</a> ( &amp;ret, posDiv );</div>
<div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;            number                                    = number / posDiv;</div>
<div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;        }</div>
<div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;    }</div>
<div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;    </div>
<div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;    <span class="comment">//================================================ If the number was a large prime number, save it as it is</span></div>
<div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;    <span class="keywordflow">if</span> ( number &gt; 2 ) { <a class="code" href="namespace_pro_s_h_a_d_e__internal__misc.html#a8a52d854a63ecad80c1805d601ffcf96">ProSHADE_internal_misc::addToSignedVector</a> ( &amp;ret, number ); }</div>
<div class="line"><a name="l01272"></a><span class="lineno"> 1272</span>&#160; </div>
<div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160;    <span class="comment">//================================================ Finish dealing with negative numbers</span></div>
<div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160;    <span class="keywordflow">if</span> ( changeSign ) { ret.at(0) = -ret.at(0); }</div>
<div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;    </div>
<div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;    <span class="comment">//================================================ Done</span></div>
<div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160;    <span class="keywordflow">return</span>                                            ( ret );</div>
<div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;    </div>
<div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8a7c6330e101fb6d729aaf6f545db9c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7c6330e101fb6d729aaf6f545db9c8">&#9670;&nbsp;</a></span>vectorMeanAndSD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::vectorMeanAndSD </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double &gt; *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get vector mean and standard deviation. </p>
<p>This function takes a pointer to a vector of proshade_double's and returns the mean and standard deviation of such vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>Pointer to a vector of proshade_double's for which mean and sd should be obtained. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>Pointer to array of 2 proshade_double's, which will be the return values - first mean and second sd. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00121">121</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;{</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    <span class="comment">//================================================ Get mean</span></div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    ret[0]                                            = std::accumulate ( vec-&gt;begin(), vec-&gt;end(), 0.0 ) / <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( vec-&gt;size() );</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    </div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    <span class="comment">//================================================ Get standard deviation</span></div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    proshade_double squaredSum                        = std::inner_product ( vec-&gt;begin(), vec-&gt;end(), vec-&gt;begin(), 0.0 );</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    ret[1]                                            = std::sqrt ( ( squaredSum / <span class="keyword">static_cast&lt;</span>proshade_double<span class="keyword">&gt;</span> ( vec-&gt;size() ) ) - std::pow ( ret[0], 2.0 ) );</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    </div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    <span class="comment">//================================================ Return</span></div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    return ;</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    </div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af185ca14eb5d82fb126092767746e00a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af185ca14eb5d82fb126092767746e00a">&#9670;&nbsp;</a></span>vectorMedianAndIQR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProSHADE_internal_maths::vectorMedianAndIQR </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; proshade_double &gt; *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proshade_double *&amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get vector median and inter-quartile range. </p>
<p>This function takes a pointer to a vector of proshade_double's and returns the median and the inter-quartile range of such vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>Pointer to a vector of proshade_double's for which median and IQR should be obtained. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>Pointer to array of 2 proshade_double's, which will be the return values - first median and second IQR. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00143">143</a> of file <a class="el" href="_pro_s_h_a_d_e__maths_8cpp_source.html">ProSHADE_maths.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;{</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;    <span class="comment">//================================================ Sanity check</span></div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    <span class="keywordflow">if</span> ( vec-&gt;size() &lt; 3 ) { ret[0] = 0.0; ret[1] = 0.0; <span class="keywordflow">return</span>; }</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    </div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    <span class="comment">//================================================ Sort the vector</span></div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    std::sort                                         ( vec-&gt;begin(), vec-&gt;end() );</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    </div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;    <span class="comment">//================================================ Get median</span></div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    <span class="keywordflow">if</span> ( <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( vec-&gt;size() ) % 2 == 0)</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;    {</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;        ret[0]                                        = ( vec-&gt;at( ( <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( vec-&gt;size() ) / 2 ) - 1 ) +</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;                                                        vec-&gt;at(   <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( vec-&gt;size() ) / 2 ) ) / 2.0;</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    }</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;    {</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;        ret[0]                                        = vec-&gt;at( <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( vec-&gt;size() ) / 2 );</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    }</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    </div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    <span class="comment">//================================================ Get first and third quartile</span></div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    proshade_double Q1, Q3;</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;    <span class="keywordflow">if</span> ( <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( vec-&gt;size() ) % 2 == 0)</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    {</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        Q1                                            = ( vec-&gt;at( ( <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( vec-&gt;size() ) / 4 ) - 1 ) +</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;                                                          vec-&gt;at(   <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( vec-&gt;size() ) / 4 ) ) / 2.0;</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        Q3                                            = ( vec-&gt;at( ( ( <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( vec-&gt;size() ) / 4 ) * 3 ) - 1 ) +</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;                                                          vec-&gt;at(   ( <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( vec-&gt;size() ) / 4 ) * 3 ) ) / 2.0;</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    }</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;    {</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;        Q1                                            = vec-&gt;at( <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( vec-&gt;size() ) / 4 );</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;        Q3                                            = vec-&gt;at( ( <span class="keyword">static_cast&lt;</span>proshade_unsign<span class="keyword">&gt;</span> ( vec-&gt;size() ) / 4 ) * 3 );</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;    }</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;    </div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;    <span class="comment">//================================================ And now save the IQR</span></div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    ret[1]                                            = Q3 -  Q1;</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    </div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    <span class="comment">//================================================ Return</span></div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    return ;</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    </div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclass_pro_s_h_a_d_e__exception_html"><div class="ttname"><a href="class_pro_s_h_a_d_e__exception.html">ProSHADE_exception</a></div><div class="ttdoc">This class is the representation of ProSHADE exception.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__exceptions_8hpp_source.html#l00036">ProSHADE_exceptions.hpp:37</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a7e69b64278319ae1a1268d1a55545675"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a7e69b64278319ae1a1268d1a55545675">ProSHADE_internal_maths::evaluateGLSeries</a></div><div class="ttdeci">proshade_double evaluateGLSeries(proshade_double *series, proshade_double target, proshade_unsign terms)</div><div class="ttdoc">This function evaluates the Taylor expansion.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00442">ProSHADE_maths.cpp:442</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a1823adaca871244e42347ecb8ed834a2"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a1823adaca871244e42347ecb8ed834a2">ProSHADE_internal_maths::getGLFirstEvenRoot</a></div><div class="ttdeci">void getGLFirstEvenRoot(proshade_double polyAtZero, proshade_unsign order, proshade_double *abscAtZero, proshade_double *weighAtZero, proshade_unsign taylorSeriesCap)</div><div class="ttdoc">This function finds the first root for Legendre polynomials of odd order.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00379">ProSHADE_maths.cpp:379</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__misc_html_a8a52d854a63ecad80c1805d601ffcf96"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__misc.html#a8a52d854a63ecad80c1805d601ffcf96">ProSHADE_internal_misc::addToSignedVector</a></div><div class="ttdeci">void addToSignedVector(std::vector&lt; proshade_signed &gt; *vecToAddTo, proshade_signed elementToAdd)</div><div class="ttdoc">Adds the element to the vector.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__misc_8cpp_source.html#l00121">ProSHADE_misc.cpp:121</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_affab74b910cda2ee3faa461740a7a432"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#affab74b910cda2ee3faa461740a7a432">ProSHADE_internal_maths::getGLPolyAtZero</a></div><div class="ttdeci">void getGLPolyAtZero(proshade_unsign order, proshade_double *polyValue, proshade_double *deriValue)</div><div class="ttdoc">This function obtains the Legendre polynomial values and its derivative at zero for any positive inte...</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00342">ProSHADE_maths.cpp:342</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a4f2619c7f3b8d628af9cb356778e9807"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a4f2619c7f3b8d628af9cb356778e9807">ProSHADE_internal_maths::advanceGLPolyValue</a></div><div class="ttdeci">proshade_double advanceGLPolyValue(proshade_double from, proshade_double to, proshade_double valAtFrom, proshade_unsign noSteps, proshade_unsign taylorSeriesCap)</div><div class="ttdoc">This function finds the next value of the polynomial.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00472">ProSHADE_maths.cpp:472</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__misc_html_af556836aa9286c1571196de442a6b493"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__misc.html#af556836aa9286c1571196de442a6b493">ProSHADE_internal_misc::checkMemoryAllocation</a></div><div class="ttdeci">void checkMemoryAllocation(chVar checkVar, std::string fileP, unsigned int lineP, std::string funcP, std::string infoP=&quot;This error may occurs when ProSHADE requests memory to be\n                    : allocated to it and this operation fails. This could\n                    : happen when not enough memory is available, either due to\n                    : other processes using a lot of memory, or when the machine\n                    : does not have sufficient memory available. Re-run to see\n                    : if this problem persists.&quot;)</div><div class="ttdoc">Checks if memory was allocated properly.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__misc_8hpp_source.html#l00063">ProSHADE_misc.hpp:63</a></div></div>
<div class="ttc" id="anamespace_pro_s_h_a_d_e__internal__maths_html_a31c91064de64aef9f8278d533f8188ad"><div class="ttname"><a href="namespace_pro_s_h_a_d_e__internal__maths.html#a31c91064de64aef9f8278d533f8188ad">ProSHADE_internal_maths::completeLegendreSeries</a></div><div class="ttdeci">void completeLegendreSeries(proshade_unsign order, proshade_double *abscissa, proshade_double *weights, proshade_unsign taylorSeriesCap)</div><div class="ttdoc">This function completes the Legendre polynomial series assuming you have obtained the first values.</div><div class="ttdef"><b>Definition:</b> <a href="_pro_s_h_a_d_e__maths_8cpp_source.html#l00516">ProSHADE_maths.cpp:516</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html">ProSHADE_internal_maths</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
